#!/bin/sh
set -a
_APPLICATION_NAME=system-maintenance
_beep() {
  [ ! -e /dev/speaker ] && return 1
  flock -n -w 0 $RSRC_BEEP printf '%s' "$1" >/dev/speaker || {
    debug "Another 'beep' is in progress"
    return 2
  }
}
_sudo_precmd() {
  _beep $_CONF_LOG_SUDO_BEEP_TONE
}
_context_id_is_valid() {
  printf '%s' "$1" | $_CONF_GNU_GREP -Pq '^[a-zA-Z0-9_+-]+$' || error "Context ID *MUST* only contain alphanumeric characters and +-: '^[a-zA-Z0-9_+-]+$' | ($1)"
}
_variable_is_set() {
  env | grep -cq "^$1=.*$"
}
_environment_filter() {
  $_CONF_GNU_GREP -P "(^_CONF_|^_OPTN_|^_INSTALL_|^${_TARGET_APPLICATION_NAME}_)"
}
_environment_dump() {
  [ -z "$_APPLICATION_PIPE_DIR" ] && return
  [ -z "$_ENVIRONMENT_FILE" ] && _ENVIRONMENT_FILE=$_APPLICATION_PIPE_DIR/environment
  mkdir -p $(dirname $_ENVIRONMENT_FILE)
  env | _environment_filter | sort -u | grep -v '^$' | sed -e 's/=/="/' -e 's/$/"/' >>$_ENVIRONMENT_FILE
}
_call() {
  local _function_name=$1
  type $_function_name >/dev/null 2>&1 || {
    debug "${_function_name} does not exist"
    return 255
  }
  [ $# -gt 1 ] && {
    shift
    $_function_name "$@"
    return $?
  }
  $_function_name
}
_() {
  if [ -n "$_EXEC_ATTEMPTS" ]; then
    local attempt=1
    while [ $attempt -le $_EXEC_ATTEMPTS ]; do
      _WARN_ON_ERROR=1 _do_exec "$@" && return
      attempt=$(($attempt + 1))
    done
    error "Failed after $attempt attempts: $*"
  fi
  _do_exec "$@"
}
_do_exec() {
  local _successfulExitStatus=0
  if [ -n "$_SUCCESSFUL_EXIT_STATUS" ]; then
    _successfulExitStatus=$_SUCCESSFUL_EXIT_STATUS
    unset _SUCCESSFUL_EXIT_STATUS
  fi
  info "## $*"
  if [ -z "$_DRY_RUN" ]; then
    if [ -n "$_CMD_LOGFILE" ]; then
      _exec_to_file "$_CMD_LOGFILE" "$@"
    else
      if [ -z "$_LOGFILE" ]; then
        "$@"
      else
        _exec_to_file "$_LOGFILE" "$@"
      fi
    fi
    local _exit_status=$?
    if [ $_exit_status -ne $_successfulExitStatus ]; then
      if [ -n "$_ON_FAILURE" ]; then
        $_ON_FAILURE
        return
      fi
      if [ -z "$_WARN_ON_ERROR" ]; then
        error "Previous cmd failed: $* - $_exit_status"
      else
        unset _WARN_ON_ERROR
        warn "Previous cmd failed: $* - $_exit_status"
        _ENVIRONMENT_FILE=$(_mktemp error) _environment_dump
        return $_exit_status
      fi
    fi
  fi
}
_exec_to_file() {
  local logfile=$1
  shift
  mkdir -p $(dirname $logfile)
  type $_function_name >/dev/null 2>&1 || {
    "$@" >>$logfile 2>>$logfile
    return $?
  }
  "$@"
}
error() {
  if [ $# -ge 2 ]; then
    _EXIT_STATUS=$2
  else
    _EXIT_STATUS=1
  fi
  _EXIT_LOG_LEVEL=4
  _EXIT_STATUS_CODE="ERR"
  _EXIT_COLOR_CODE="$_CONF_LOG_C_ERR"
  _EXIT_MESSAGE="$1 ($_EXIT_STATUS)"
  _EXIT_BEEP=$_CONF_LOG_BEEP_ERR
  _defer _environment_dump
  _defer _log_app_exit
  exit $_EXIT_STATUS
}
_success() {
  _EXIT_STATUS=0
  _EXIT_LOG_LEVEL=1
  _EXIT_STATUS_CODE="SCS"
  _EXIT_COLOR_CODE="$_CONF_LOG_C_SCS"
  _EXIT_MESSAGE="$1"
  _EXIT_BEEP=$_CONF_LOG_BEEP_SCS
  _defer _long_running_cmd
  _defer _log_app_exit
  [ -z "$_EXIT" ] && exit 0
}
_on_exit() {
  [ $_EXIT ] && return 1
  _EXIT=0
  [ -z "$_EXIT_STATUS" ] && _success "completed successfully"
  if [ -n "$_DEFERS" ]; then
    local defer
    for defer in $_DEFERS; do
      _call $defer
    done
    unset _DEFERS
  fi
  return $_EXIT
}
_defer() {
  if [ -n "$_DEFERS" ]; then
    local defer
    for defer in $_DEFERS; do
      [ "$defer" = "$1" ] && {
        debug "not deferring: $1 as it was already deferred"
        return
      }
    done
  fi
  debug "deferring: $1"
  _DEFERS="$1 $_DEFERS"
}
_log_app_exit() {
  [ "$_EXIT_MESSAGE" ] && {
    local current_time=$(date +%s)
    local timeout=$(($_APPLICATION_START_TIME + $_CONF_LOG_BEEP_TIMEOUT))
    [ $current_time -le $timeout ] && unset _EXIT_BEEP
    _print_log $_EXIT_LOG_LEVEL "$_EXIT_STATUS_CODE" "$_EXIT_COLOR_CODE" "$_EXIT_BEEP" "$_EXIT_MESSAGE"
  }
  _log_app exit
  [ -n "$_LOGFILE" ] && [ -n "$_OPTN_LOG_EXIT_CMD" ] && {
    $_OPTN_LOG_EXIT_CMD -file $_LOGFILE
  }
}
_print_help() {
  if [ -e $2 ]; then
    info "$1:"
    cat $2
    printf '\n'
  fi
}
_print_help_and_exit() {
  _print_help 'system-wide options' $_CONF_LIBRARY_PATH/install/help/default
  if [ "$_APPLICATION_NAME" != "install" ]; then
    _print_help $_APPLICATION_NAME $_CONF_LIBRARY_PATH/$_APPLICATION_NAME/help/default
    _print_help "$_APPLICATION_NAME/$_APPLICATION_CMD" $_CONF_LIBRARY_PATH/$_APPLICATION_NAME/help/$_APPLICATION_CMD
  fi
  exit 0
}
_include() {
  local include_file
  for include_file in "$@"; do
    [ -f $HOME/.config/walterjwhite/$include_file ] && . $HOME/.config/walterjwhite/$include_file
  done
}
_init_logging() {
  [ -n "$_LOGFILE" ] && _set_logfile "$_LOGFILE"
  case $_CONF_LOG_LEVEL in
  0)
    local logfile=$(_mktemp debug)
    warn "Writing debug contents to: $logfile"
    _set_logfile "$logfile"
    set -x
    ;;
  esac
}
_set_logfile() {
  [ -z "$1" ] && return 1
  _LOGFILE=$1
  mkdir -p $(dirname $1)
  _reset_indent
  [ -n "$_CHILD_LOG" ] || exec 3>&1 4>&2
  exec >>$_LOGFILE 2>&1
  [ -z "$_PRESERVE_LOG" ] && [ -z "$_CHILD_LOG" ] && truncate -s 0 $1 >/dev/null 2>&1
}
warn() {
  _print_log 3 WRN "$_CONF_LOG_C_WRN" "$_CONF_LOG_BEEP_WRN" "$1"
}
info() {
  _print_log 2 INF "$_CONF_LOG_C_INFO" "$_CONF_LOG_BEEP_INFO" "$1"
}
detail() {
  _print_log 2 DTL "$_CONF_LOG_C_DETAIL" "$_CONF_LOG_BEEP_DETAIL" "$1"
}
debug() {
  _print_log 1 DBG "$_CONF_LOG_C_DEBUG" "$_CONF_LOG_BEEP_DEBUG" "($$) $1"
}
_log() {
  :
}
_sed_remove_nonprintable_characters() {
  sed -e 's/[^[:print:]]//g'
}
_print_log() {
  if [ -z "$5" ]; then
    if test ! -t 0; then
      local _line
      cat - | _sed_remove_nonprintable_characters |
        while read _line; do
          _print_log $1 $2 $3 $4 "$_line"
        done
      return
    fi
    return
  fi
  local message="$5"
  [ $1 -lt $_CONF_LOG_LEVEL ] && return
  [ -n "$_LOGGING_CONTEXT" ] && message="$_LOGGING_CONTEXT - $message"
  local _message_date_time=$(date +"$_CONF_LOG_DATE_FORMAT")
  if [ $_BACKGROUNDED ] && [ $_OPTN_INSTALL_BACKGROUND_NOTIFICATION_METHOD ]; then
    $_OPTN_INSTALL_BACKGROUND_NOTIFICATION_METHOD "$2" "$_message" &
  fi
  [ -n "$4" ] && _beep "$4"
  _log_to_file "$2" "$_message_date_time" "${_LOG_INDENT}$message"
  _log_to_console "$3" "$2" "$_message_date_time" "${_LOG_INDENT}$message"
  [ -z "$INTERACTIVE" ] && _syslog "$message"
  return 0
}
_reset_indent() {
  unset _LOG_INDENT
}
_log_to_file() {
  [ -z "$_LOGFILE" ] && return
  if [ $_CONF_LOG_AUDIT -gt 0 ]; then
    printf '%s %s %s\n' "$1" "$2" "$3" >>$_LOGFILE
    return
  fi
  printf '%s\n' "$3" >>$_LOGFILE
}
_log_to_console() {
  local stderr=2
  [ ! -t $stderr ] && stderr=4
  [ ! -t $stderr ] && return
  if [ $_CONF_LOG_AUDIT -gt 0 ]; then
    printf >&$stderr '\033[%s%s \033[0m%s %s\n' "$1" "$2" "$3" "$4"
    return
  fi
  printf >&$stderr '\033[%s%s \033[0m\n' "$1" "$4"
}
_log_app() {
  debug "$_APPLICATION_NAME:$_APPLICATION_CMD - $1 ($$)"
}
_mktemp() {
  local suffix=$1
  [ -n "$suffix" ] && suffix=".$suffix"
  local sudo_prefix
  [ -n "$_SUDO_USER" ] && sudo_prefix=_sudo
  $sudo_prefix mktemp -${_MKTEMP_OPTIONS}t ${_APPLICATION_NAME}.${_APPLICATION_CMD}${suffix}.XXXXXXXX
}
_sub_platform() {
  which lsb_release >/dev/null 2>&1 && {
    _SUB_PLATFORM=$(lsb_release -a | grep ID | cut -f2 -d: | tr -d '\t')
    return
  }
  [ -e $_ROOT/etc/os-release ] && {
    _SUB_PLATFORM=$(grep ^NAME= $_ROOT/etc/os-release | cut -f2 -d= | sed -e 's/"//g' -e 's/ Linux//')
  }
  [ -e $_ROOT/etc/gentoo-release ] && _SUB_PLATFORM=Gentoo
}
_setup_app_pipe() {
  _APPLICATION_PIPE=$_APPLICATION_CMD_DIR/$$
  _APPLICATION_PIPE_DIR=$(dirname $_APPLICATION_PIPE)
  mkdir -p $_APPLICATION_PIPE_DIR
  mkfifo $_APPLICATION_PIPE
  _defer _cleanup_app_pipe
}
_cleanup_app_pipe() {
  rm -f $_APPLICATION_PIPE
}
_kill_all() {
  _do_kill_all $_APPLICATION_PIPE_DIR
}
_kill_all_group() {
  _do_kill_all $_APPLICATION_CONTEXT_GROUP
}
_do_kill_all() {
  for _EXISTING_APPLICATION_PIPE in $(find $1 -type p -not -name $$); do
    _kill $(basename $_EXISTING_APPLICATION_PIPE)
  done
}
_kill() {
  warn "Killing $1"
  kill -TERM $1
}
_list() {
  _list_pidinfos $_APPLICATION_PIPE_DIR
}
_list_group() {
  _list_pidinfos $_APPLICATION_CONTEXT_GROUP
}
_list_pidinfos() {
  info "Running processes:"
  _EXECUTABLE_NAME_SED_SAFE=$(_sed_safe $0)
  for _EXISTING_APPLICATION_PIPE in $(find $1 -type p -not -name $$); do
    _list_pidinfo
  done
}
_parent_processes_pgrep() {
  pgrep -P $1
}
_is_backgrounded() {
  case $(ps -o stat= -p $$) in
  *+*)
    return 1
    ;;
  esac
  return 0
}
_list_pidinfo() {
  _TARGET_PID=$(basename $_EXISTING_APPLICATION_PIPE)
  _TARGET_PS_DTL=$(ps -o command -p $_TARGET_PID | sed 1d | sed -e "s/^.*$_EXECUTABLE_NAME_SED_SAFE/$_EXECUTABLE_NAME_SED_SAFE/")
  info " $_TARGET_PID - $_TARGET_PS_DTL"
}
_syslog() {
  logger -i -t "$_APPLICATION_NAME.$_APPLICATION_CMD" "$1"
}
_sudo() {
  [ $# -eq 0 ] && error 'No arguments were provided to _sudo'
  _require "$_SUDO_CMD" _SUDO_CMD
  _sudo_is_required || {
    "$@"
    return
  }
  [ -n "$INTERACTIVE" ] && {
    $_SUDO_CMD -n ls >/dev/null 2>&1 || _sudo_precmd "$@"
  }
  $_SUDO_CMD $sudo_options "$@"
  unset sudo_options
}
_sudo_is_required() {
  [ -n "$_SUDO_USER" ] && {
    [ "$_SUDO_USER" = "$USER" ] && return 1
    sudo_options="$sudo_options -u $_SUDO_USER"
    return 0
  }
  [ "$USER" = "root" ] && return 1
  return 0
}
_waitee_init() {
  [ -z "$_WAITEE" ] && return
  _setup_app_pipe
  warn "($_APPLICATION_CMD) Please use -w=$$"
  _defer _waitee_done
}
_waitee_done() {
  if [ -n "$_WAITEE" ] && [ -e $_APPLICATION_PIPE ]; then
    info "$0 process completed, notifying ($_EXIT_STATUS)"
    printf '%s\n' "$_EXIT_STATUS" >$_APPLICATION_PIPE
    info "$0 downstream process picked up"
  fi
}
_waiter() {
  [ -z "$_WAITER_PID" ] && return
  _UPSTREAM_APPLICATION_PIPE=$(find $_APPLICATION_CONTEXT_GROUP -type p -name $_WAITER_PID 2>/dev/null | head -1)
  [ -z "$_UPSTREAM_APPLICATION_PIPE" ] && error "$_WAITER_PID not found"
  [ ! -e $_UPSTREAM_APPLICATION_PIPE ] && {
    warn "$_UPSTREAM_APPLICATION_PIPE does not exist, did upstream start?"
    return
  }
  info "Waiting for upstream to complete: $_WAITER_PID"
  while [ 1 ]; do
    if [ ! -e $_UPSTREAM_APPLICATION_PIPE ]; then
      error "Upstream pipe no longer exists"
    fi
    _UPSTREAM_APPLICATION_STATUS=$(_timeout $_CONF_WAIT_INTERVAL "_waiter:upstream" cat $_UPSTREAM_APPLICATION_PIPE 2>/dev/null)
    local _UPSTREAM_STATUS=$?
    if [ $_UPSTREAM_STATUS -eq 0 ]; then
      if [ -z "$_UPSTREAM_APPLICATION_STATUS" ] || [ $_UPSTREAM_APPLICATION_STATUS -gt 0 ]; then
        error "Upstream exited with error ($_UPSTREAM_APPLICATION_STATUS)"
      fi
      warn "Upstream finished: $_UPSTREAM_APPLICATION_PIPE ($_UPSTREAM_STATUS)"
      break
    fi
    detail " Upstream is still running: $_UPSTREAM_APPLICATION_PIPE ($_UPSTREAM_STATUS)"
    sleep 1
  done
}
_require() {
  local level=error
  if [ -z "$1" ]; then
    [ -n "$_WARN" ] && level=warn
    $level "$2 required $_REQUIRE_DETAILED_MESSAGE" $3
    return 1
  fi
  unset _REQUIRE_DETAILED_MESSAGE
}
_mail() {
  if [ $# -lt 3 ]; then
    warn "recipients[0], subject[1], message[2] is required - $# arguments provided"
    return 1
  fi
  local recipients=$(printf '%s' "$1" | tr '|' ' ')
  shift
  local subject="$1"
  shift
  local message="$1"
  shift
  printf "$message" | mail -s "$subject" $recipients
}
_alert() {
  _print_log 5 ALRT "$_CONF_LOG_C_ALRT" "$_CONF_LOG_BEEP_ALRT" "$1"
  local recipients="$_OPTN_LOG_ALERT_RECIPIENTS"
  local subject="Alert: $0 - $1"
  if [ -z "$recipients" ]; then
    warn "recipients is empty, aborting"
    return 1
  fi
  _mail "$recipients" "$subject" "$2"
}
_long_running_cmd() {
  [ -n "$_OPTN_DISABLE_LONG_RUNNING_CMD_NOTIFICATION" ] && return
  _APPLICATION_END_TIME=$(date +%s)
  _APPLICATION_RUNTIME=$(($_APPLICATION_END_TIME - $_APPLICATION_START_TIME))
  [ $_APPLICATION_RUNTIME -lt $_CONF_LOG_LONG_RUNNING_CMD ] && return
  local subject="[$_APPLICATION_NAME] - $_EXIT_MESSAGE - ($_EXIT_STATUS)"
  local message=""
  if [ -n "$_LOGFILE" ]; then
    message=$(tail -$_CONF_LOG_LONG_RUNNING_CMD_LINES $_LOGFILE)
  fi
  _alert "$subject" "$message"
}
_features() {
  cd $PWD
  if [ ! -e $1 ]; then
    if [ -z "$_WARN" ]; then
      warn "No features to install: $PWD $1"
    fi
    return 1
  fi
  info "Installing ${_FEATURE_MESSAGE}features"
  local feature
  for feature in $(_features_find $1 | sort -u); do
    _FEATURE_NAME=$(printf '%s' $feature | sed -e 's/\.feature/\.feature\n/g' | $_CONF_GNU_GREP -Po '/[a-zA-Z0-9-_]*.feature$' | sed -e 's/^\///' -e 's/\.feature$//' | tr '\n' '_' | sed -e 's/_$//')
    _application_defaults $feature
    _is_feature_enabled $_FEATURE_NAME || {
      _FEATURE_DISABLED=1 _disable_feature $_FEATURE_NAME
      _features_unset
      continue
    }
    _feature $feature || {
      _disable_feature $_FEATURE_NAME
      _features_unset
      continue
      featureerror=1
    }
    _FEATURE_MESSAGE="children " _WARN=0 _features $feature/feature
    _features_unset
  done
}
_features_unset() {
  unset _FEATURE_NAME _FEATURE_DISABLED
}
_features_find() {
  if [ -z "$_FEATURE_MESSAGE" ]; then
    find $1 -type d \( -name '*.feature' -and ! -path '*/*.feature/*' \)
  else
    find $1 -type d -name '*.feature' -and ! -path "$1"
  fi
}
_feature() {
  detail $_FEATURE_NAME
  _install $1 || return $?
  _feature_setup $1 || return $?
}
_feature_setup() {
  local setup_script
  for setup_script in $(find $1 -type f \( -path "$1/setup/*" \) | sort -u); do
    _setup_run_script $setup_script || return 1
  done
}
_install() {
  _sudo mkdir -p $_INSTALL_BIN_PATH
  _install_help $1
  local installed_files=$(_mktemp)
  _install_cmds $1 $installed_files
  _install_uninstall $1
  _install_files_files $1 $installed_files
  _install_update_files $installed_files
  if [ -e $1/.metadata ]; then
    cat $1/.metadata | _write "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.metadata"
  fi
}
_install_files() {
  if [ -e $1 ] && [ $(find $1 -type f | wc -l) -gt 0 ]; then
    if [ -n "$3" ]; then
      local files_sed_safe=$(_sed_safe $1)
      local target_sed_safe=$(_sed_safe $2)
      find $1 -type f | sed -e "s/^$files_sed_safe/$target_sed_safe/" >>$3
    fi
    _sudo mkdir -p $2
    tar -c $_TAR_ARGS -C $1 . | _sudo tar -xop $_TAR_ARGS -C $2
  fi
}
_install_help() {
  _install_files $1/help $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/help
}
_install_cmds() {
  if [ "$_TARGET_APPLICATION_NAME" = "$_APPLICATION_NAME" ]; then
    printf '%s\n' "$_INSTALL_BIN_PATH/$(basename $0)" >>$2
  fi
  _install_files $1/bin $_INSTALL_BIN_PATH $2
}
_install_uninstall() {
  _install_files $1/uninstall $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/uninstall
}
_install_files_files() {
  _install_files $1/files/_ROOT_ $_ROOT $2
  _install_files $1/files/_APPLICATION_ROOT_ "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME" $2
}
_install_update_files() {
  if [ -n "$_ROOT" ] && [ "$_ROOT" != "/" ]; then
    local root_sed_safe=$(_sed_safe $_ROOT)
    $_CONF_GNU_SED -i "s/^$root_sed_safe//" $1
  fi
  _INSTALLED_FILES="$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.files"
  cat $1 | _write "$_INSTALLED_FILES"
  rm -f $1
  _sudo chmod 444 $_INSTALLED_FILES
}
_install_metadata_write() {
  _write $_APPLICATION_METADATA_PATH
}
_metadata_write_platform() {
  env | grep '^_BOOTSTRAP_' | _install_metadata_write
}
app_bootstrap() {
  :
}
app_install() {
  _DEPENDENCY=1 app-install $1
}
app_uninstall() {
  app-uninstall $1
}
app_is_installed() {
  [ -e $_CONF_LIBRARY_PATH/$1/.metadata ] && return 0
  return 1
}
app_is_file() {
  return 1
}
crontab_bootstrap() {
  :
}
crontab_install() {
  local oSUDO_USER=$_SUDO_USER
  _SUDO_USER=root
  crontab_uninstall
  local temp_crontab=$(_mktemp)
  _sudo cp $1 $temp_crontab
  _sudo $_CONF_GNU_SED -i "s/$/ # app.$_TARGET_APPLICATION_NAME/" $temp_crontab
  printf '\n' | _sudo tee -a $temp_crontab >/dev/null 2>&1
  _sudo $_CONF_GNU_SED -i "1i # app.$_TARGET_APPLICATION_NAME" $temp_crontab
  _sudo $_CONF_GNU_SED -i "1i \\" $temp_crontab
  crontab_append $_SUDO_USER $temp_crontab
  _sudo rm -f $temp_crontab
  _SUDO_USER=$oSUDO_USER
}
crontab_uninstall() {
  local oSUDO_USER=$_SUDO_USER
  _SUDO_USER=root
  local temp_crontab=$(_mktemp)
  crontab_remove $temp_crontab
  crontab_write $_SUDO_USER $temp_crontab
  _sudo rm -f $temp_crontab
  _SUDO_USER=$oSUDO_USER
}
crontab_remove() {
  crontab_get $_SUDO_USER $1
  _sudo $_CONF_GNU_SED -i '/^$/d' $1
  _sudo $_CONF_GNU_SED -i "/# app.$_TARGET_APPLICATION_NAME/d" $1
}
crontab_is_installed() {
  local oSUDO_USER=$_SUDO_USER
  _SUDO_USER=root
  local temp_crontab=$(_mktemp)
  crontab_get $_SUDO_USER $temp_crontab
  _sudo grep -qm1 "# app.$_TARGET_APPLICATION_NAME" $temp_crontab
  _sudo rm -f $temp_crontab
  _SUDO_USER=$oSUDO_USER
}
crontab_enabled() {
  return 0
}
crontab_is_file() {
  return 0
}
expect_install() {
  $1 >/dev/null 2>&1
}
expect_uninstall() {
  warn "expect uninstall - Not implemented"
}
expect_is_installed() {
  return 1
}
expect_is_file() {
  return 0
}
go_bootstrap() {
  go_bootstrap_is_go_available || {
    package_install $go_PACKAGE
    go_bootstrap_is_go_available || go_DISABLED=1
  }
}
go_bootstrap_is_go_available() {
  which go >/dev/null 2>&1
}
go_install() {
  GO111MODULE=on GOPATH=$go_INSTALL_PATH sudo_options="--preserve-env=GO111MODULE,GOPATH" _sudo go install $go_OPTIONS "$@" || {
    warn "go install failed: $go_OPTIONS $@"
    warn "  http_proxy: $http_proxy"
    warn "  git  proxy: $(git config --global http.proxy)"
  }
}
go_update() {
  :
}
go_uninstall() {
  _sudo go uninstall "$@"
}
go_is_installed() {
  return 1
}
go_is_file() {
  return 1
}
npm_bootstrap() {
  npm_bootstrap_is_npm_available || {
    package_install $npm_PACKAGE
    npm_bootstrap_is_npm_available || npm_DISABLED=1
  }
  npm_setup_proxy
}
npm_bootstrap_is_npm_available() {
  which npm >/dev/null 2>&1
}
npm_install() {
  local npm_package
  for npm_package in "$@"; do
    npm_is_installed $npm_package || _sudo npm install -s -g "$npm_package"
  done
}
npm_uninstall() {
  _sudo npm uninstall -s -g "$@"
}
npm_is_installed() {
  npm list -g $1 >/dev/null
}
npm_is_file() {
  return 1
}
npm_setup_proxy() {
  if [ -n "$http_proxy" ]; then
    warn "Configuring NPM to use an HTTP proxy: $http_proxy"
    npm config set proxy $http_proxy
    npm config set https-proxy $https_proxy
    _defer npm_clear_proxy
  fi
}
npm_clear_proxy() {
  warn "Reverting NPM HTTP proxy: $http_proxy"
  npm config rm proxy
  npm config rm https-proxy
}
package_bootstrap() {
  :
}
package_install() {
  local packages
  local package
  for package in "$@"; do
    package_is_installed $package || {
      if [ -n "$packages" ]; then
        packages="$packages $package"
      else
        packages="$package"
      fi
    }
  done
  if [ -n "$packages" ]; then
    package_install_do "$packages"
  else
    warn "Packages [$*] are already installed, skipping"
    return 0
  fi
}
package_is_file() {
  return 1
}
package_enabled() {
  return 0
}
pypi_bootstrap() {
  pypi_bootstrap_is_pypi_available || {
    package_install $pypi_PACKAGE
    pypi_bootstrap_is_pypi_available || pypi_DISABLED=1
  }
}
pypi_bootstrap_is_pypi_available() {
  which pip >/dev/null 2>&1
}
pypi_install() {
  _sudo pip install -U --no-input "$@" >/dev/null
}
pypi_uninstall() {
  _sudo pip uninstall -y "$@" >/dev/null
}
pypi_is_installed() {
  error "PIP - is installed - NOT IMPLEMENTED"
}
pypi_is_file() {
  return 1
}
run_bootstrap() {
  :
}
run_install() {
  sh $1
}
run_uninstall() {
  warn "run uninstall - Not implemented"
}
run_is_installed() {
  return 1
}
run_is_file() {
  return 0
}
rust_bootstrap() {
  rust_bootstrap_is_rust_available || {
    package_install $rust_PACKAGE
    rust_bootstrap_is_rust_available || rust_DISABLED=1
  }
}
rust_bootstrap_is_rust_available() {
  which cargo >/dev/null 2>&1
}
rust_install() {
  _sudo cargo install "$@"
}
rust_update() {
  _sudo cargo update "$@"
}
rust_uninstall() {
  _sudo cargo uninstall "$@"
}
rust_is_installed() {
  error "RUST - is installed - NOT IMPLEMENTED"
}
rust_is_file() {
  return 1
}
user_is_file() {
  return 0
}
_bootstrap() {
  [ "$_APPLICATION_NAME" = "$_TARGET_APPLICATION_NAME" ] && _metadata_write_platform
  [ -z "$_PLATFORM_PACKAGES" ] && return 1
  [ -n "$_BOOTSTRAP_PLATFORM_PACKAGES_INSTALLED" ] && return 2
  info "Installing pre-requisites"
  _setup_run_do_bootstrap package
  package_install $_PLATFORM_PACKAGES
  _BOOTSTRAP_PLATFORM_PACKAGES_INSTALLED=1
  _metadata_write_platform
}
_application_defaults() {
  local default_file
  for default_file in $(find $1/cfg -type f 2>/dev/null); do
    _include $default_file
  done
}
_setup_run_script() {
  local setup_type_name=$(basename $1)
  _setup_contains_subtype $setup_type_name && {
    _setup_sub_platform_matches $setup_type_name || {
      warn "Ignoring $1, does not target this sub-platform"
      return
    }
  }
  case $setup_type_name in
  *.*)
    setup_type_name=$(printf '%s' $setup_type_name | sed -e "s/^.*\.//")
    ;;
  esac
  setup_type_name=${setup_type_name%_*}
  type ${setup_type_name}_bootstrap >/dev/null 2>&1 || {
    warn "Unknown type: $setup_type_name"
    return
  }
  if [ ! -e $1 ]; then
    warn "$1 no longer exists, ignoring"
    return 0
  fi
  _variable_is_set ${setup_type_name}_disabled && return
  _sudo mkdir -p "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type"
  _setup_run_do_bootstrap $setup_type_name
  ${setup_type_name}_is_file
  if [ $? -eq 0 ]; then
    _WARN=$_CONF_LOG_FEATURE_TIMEOUT_ERROR_LEVEL ${setup_type_name}_install $1 || {
      local error=$?
      warn "Error installing: $setup_type_name: $1"
      return $error
    }
    _call ${setup_type_name}_get_data $1 | _write "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type/.${setup_type_name}"
  else
    local packages=$($_CONF_GNU_GREP -Pv '(^$|^#)' $1 | tr '\n' ' ')
    _WARN=$_CONF_LOG_FEATURE_TIMEOUT_ERROR_LEVEL ${setup_type_name}_install $packages || {
      local error=$?
      warn "Error installing $packages"
      return $error
    }
    printf "$packages" | tr ' ' '\n' | _write "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type/.${setup_type_name}"
  fi
  _call ${setup_type_name}_cleanup
  return 0
}
_setup_contains_subtype() {
  [ -z "$_SUB_PLATFORM" ] && return 1
  case $1 in
  *_*)
    return 0
    ;;
  esac
  return 1
}
_setup_sub_platform_matches() {
  local setup_type_sub_platform=${1##*_}
  setup_type_sub_platform=${setup_type_sub_platform%%.*}
  [ -z "$setup_type_sub_platform" ] && return 0
  [ "$setup_type_sub_platform" = "$_SUB_PLATFORM" ] && return 0
  return 1
}
_setup_run_do_bootstrap() {
  _setup_type_bootstrapped $1 || {
    _call ${1}_bootstrap
    _call ${1}_bootstrap_post
    export _BOOTSTRAP_${1}=1
    printf '_BOOTSTRAP_%s=1\n' "$1" | _install_metadata_write
  }
}
_setup_type_bootstrapped() {
  _variable_is_set _BOOTSTRAP_${1}
}
_package_update() {
  _package_sync
  info "updating world packages"
  _sudo emerge $_EMERGE_OPTIONS --newuse -uD world $@
  info "updated world packages"
  if [ -n "$_OPTN_INSTALL_GENTOO_DEPCLEAN" ]; then
    info "running depclean"
    _sudo emerge $_EMERGE_OPTIONS --depclean $@
    info "depclean completed"
  fi
}
package_install_do() {
  _package_sync
  _sudo emerge $_EMERGE_OPTIONS $@
}
package_is_installed() {
  [ -f $_ROOT/var/lib/portage/world ] && {
    $_CONF_GNU_GREP -Pqm1 "^${1}$" $_ROOT/var/lib/portage/world && {
      return 0
    }
  }
  local package_group=$(printf '%s' $1 | cut -f1 -d/)
  local package_name=$(printf '%s' $1 | cut -f2 -d/)
  if [ -e $_ROOT/var/db/pkg/$package_group ]; then
    find $_ROOT/var/db/pkg/$package_group -type f | $_CONF_GNU_GREP -Pqm1 "/$package_name-[\d_\-\.]_.ebuild" && {
      return 0
    }
  fi
  return 1
}
_package_sync() {
  _EMERGE_SYNC_FILE=$_CONF_APPLICATION_DATA_PATH/emerge.sync.time
  _package_synced && {
    debug "portage was already synced today"
    return
  }
  _sudo mkdir -p $(dirname $_EMERGE_SYNC_FILE)
  info "syncing portage"
  _sudo emerge $_EMERGE_OPTIONS --sync && date +%s >$_EMERGE_SYNC_FILE
  info "synced portage"
}
_package_synced() {
  [ ! -e $_EMERGE_SYNC_FILE ] && return 1
  local last_synced=$(head -1 $_EMERGE_SYNC_FILE)
  local current_time=$(date +%s)
  [ $(($current_time - $last_synced)) -gt 86400 ] && return 1
  return 0
}
00_accept_keywords_bootstrap() {
  :
}
00_accept_keywords_install() {
  _gentoo_portage_install_file package.accept_keywords $1
}
00_accept_keywords_uninstall() {
  _gentoo_portage_uninstall_file package.accept_keywords $1
}
00_accept_keywords_is_installed() {
  _gentoo_portage_is_installed package.accept_keywords $1
}
00_accept_keywords_enabled() {
  return 0
}
00_accept_keywords_is_file() {
  return 0
}
00_license_bootstrap() {
  :
}
00_license_install() {
  _gentoo_portage_install_file package.license $1
}
00_license_uninstall() {
  _gentoo_portage_uninstall_file package.license $1
}
00_license_is_installed() {
  _gentoo_portage_is_installed package.license $1
}
00_license_enabled() {
  return 0
}
00_license_is_file() {
  return 0
}
00_mask_bootstrap() {
  :
}
00_mask_install() {
  _gentoo_portage_install_file package.mask $1
}
00_mask_uninstall() {
  _gentoo_portage_uninstall_file package.mask $1
}
00_mask_is_installed() {
  _gentoo_portage_is_installed package.mask $1
}
00_mask_enabled() {
  return 0
}
00_mask_is_file() {
  return 0
}
00_package_use_bootstrap() {
  :
}
00_package_use_install() {
  _gentoo_portage_install_file package.use $1
}
00_package_use_uninstall() {
  _gentoo_portage_uninstall_file package.use $1
}
00_package_use_is_installed() {
  _gentoo_portage_is_installed package.use $1
}
00_package_use_enabled() {
  return 0
}
00_package_use_is_file() {
  return 0
}
00_use_bootstrap() {
  :
}
00_use_install() {
  local name_suffix=$(_get_feature_name $1)
  printf '# app.%s%s\n' $_TARGET_APPLICATION_NAME "$name_suffix" | _sudo tee -a /etc/portage/make.conf >/dev/null 2>&1
  printf 'USE="$USE %s" # app.%s%s\n' "$(cat $1)" $_TARGET_APPLICATION_NAME "$name_suffix" | _sudo tee -a /etc/portage/make.conf >/dev/null 2>&1
}
00_use_uninstall() {
  local name_suffix=$(_get_feature_name $1)
  _sudo $_CONF_GNU_SED -i "s/ app.$_TARGET_APPLICATION_NAME${name_suffix}/ /" /etc/portage/make.conf
}
00_use_is_installed() {
  local name_suffix=$(_get_feature_name $1)
  grep -qm1 " # app.$_TARGET_APPLICATION_NAME${name_suffix}" /etc/portage/make.conf
}
00_use_enabled() {
  return 0
}
00_use_is_file() {
  return 0
}
user_uninstall() {
  . "$1"
  _require "$username" "username"
  userdel $username
}
_get_feature_name() {
  case $1 in
  *feature*)
    printf '%s' "$1" | sed \
      -e 's/^.*\/feature\///' \
      -e 's/.feature\/.*//' \
      -e 's/^/./' \
      -e 's/\//./g'
    ;;
  *)
    printf ''
    ;;
  esac
}
_gentoo_portage_install_file() {
  _sudo mkdir -p /etc/portage/$1
  _sudo cp $2 /etc/portage/$1/app.$_TARGET_APPLICATION_NAME$(_get_feature_name $2)
}
_gentoo_portage_uninstall_file() {
  _sudo rm -f /etc/portage/$1/app.$_TARGET_APPLICATION_NAME$(_get_feature_name $2)
}
_gentoo_portage_is_installed() {
  [ -e /etc/portage/$1/app.$_TARGET_APPLICATION_NAME$(_get_feature_name $2) ]
}
_crontab_get() {
  _require "$1" "Crontab User"
  _require "$2" "Crontab Filename to write to"
  _crontab_${_CONF_CRON_PROVIDER}_get "$@"
}
_crontab_write() {
  _require "$1" "Crontab User"
  _require_file "$2" "Crontab File"
  _crontab_${_CONF_CRON_PROVIDER}_write "$@"
}
_crontab_append() {
  _require "$1" "Crontab User"
  _require_file "$2" "Crontab File"
  _has_contents $2 || return 1
  local current_crontab=$(_SUDO_USER=$1 _mktemp)
  _crontab_get $1 $current_crontab
  _sudo cat $2 | _sudo tee -a $current_crontab >/dev/null 2>&1
  _crontab_${_CONF_CRON_PROVIDER}_write $1 $current_crontab
  _sudo rm -f $current_crontab
}
_include beep context logging net paths platform system-maintenance wait  
: ${_CONF_LOG_HEADER:="##################################################"}
: ${_CONF_LOG_C_ALRT:="1;31m"}
: ${_CONF_LOG_C_ERR:="1;31m"}
: ${_CONF_LOG_C_SCS:="1;32m"}
: ${_CONF_LOG_C_WRN:="1;33m"}
: ${_CONF_LOG_C_INFO:="1;36m"}
: ${_CONF_LOG_C_DETAIL:="1;0;36m"}
: ${_CONF_LOG_C_DEBUG:="1;35m"}
: ${_CONF_LOG_C_STDIN:="1;34m"}
: ${_CONF_LOG_DATE_FORMAT:="%Y/%m/%d|%H:%M:%S"}
: ${_CONF_LOG_DATE_TIME_FORMAT:="%Y/%m/%d %H:%M:%S"}
: ${_CONF_LOG_AUDIT:=0}
: ${_CONF_LOG_LEVEL:=2}
: ${_CONF_LOG_INDENT:="  "}
: ${_CONF_LOG_CONF_VALIDATION_FUNCTION:=warn}
: ${_CONF_LOG_WAITER_LEVEL:=debug}
: ${_CONF_LOG_FEATURE_TIMEOUT_ERROR_LEVEL:=warn}
: ${_CONF_LOG_LONG_RUNNING_CMD:=30}
: ${_CONF_LOG_LONG_RUNNING_CMD_LINES:=1000}
[ -t 0 ] && INTERACTIVE=1
: ${LIB:="beep.sh context.sh environment.sh exec.sh exit.sh help.sh include.sh logging.sh mktemp.sh platform.sh processes.sh stdin.sh syslog.sh sudo.sh wait.sh validation.sh net/mail.sh alert.sh"}
: ${CFG:="logging platform context wait beep paths net"}
: ${SUPPORTED_PLATFORMS:="Apple FreeBSD Linux Windows"}
: ${BUILD_PLATFORMS:="FreeBSD Linux Apple Windows"}
which pgrep >/dev/null 2>&1 && _PARENT_PROCESSES_FUNCTION=_parent_processes_pgrep
_DETECTED_PLATFORM=$(uname)
case $_DETECTED_PLATFORM in
	Darwin)
		_DETECTED_PLATFORM=Apple
		;;
	MINGW64_NT-*)
		_DETECTED_PLATFORM=Windows
		;;
esac
: ${_CONF_INSTALL_CONTEXT:=$_CONSOLE_CONTEXT_ID}
: ${_CONF_INSTALL_CONTEXT:=default}
: ${_CONF_WAIT_INTERVAL:=30}
: ${RSRC_BEEP:=/tmp/beep}
: ${_CONF_LOG_BEEP_TIMEOUT:=5}
: ${_CONF_LOG_BEEP_ERR:='L32c'}
: ${_CONF_LOG_BEEP_ALRT:='L32f'}
: ${_CONF_LOG_BEEP_SCS:='L32a'}
: ${_CONF_LOG_BEEP_WRN:=''}
: ${_CONF_LOG_BEEP_INFO:=''}
: ${_CONF_LOG_BEEP_DETAIL:=''}
: ${_CONF_LOG_BEEP_DEBUG:=''}
: ${_CONF_LOG_BEEP_STDIN:='L32ab'}
[ "$HOME" = "/" ] && HOME=/root
: ${_CONF_LIBRARY_PATH:=/usr/local/walterjwhite}
: ${_CONF_BIN_PATH:=/usr/local/bin}
_CONF_DATA_PATH=$HOME/.data
_CONF_CACHE_PATH=$_CONF_DATA_PATH/.cache
_CONF_CONFIG_PATH=$HOME/.config/walterjwhite
_CONF_RUN_PATH=/tmp/$USER/walterjwhite/app
_CONF_DATA_ARTIFACTS_PATH=$_CONF_DATA_PATH/install-v2/artifacts
_CONF_DATA_REGISTRY_PATH=$_CONF_DATA_PATH/install-v2/registry
_CONF_APPLICATION_DATA_PATH=$_CONF_DATA_PATH/$_APPLICATION_NAME
_CONF_APPLICATION_CONFIG_PATH=$_CONF_CONFIG_PATH/$_APPLICATION_NAME
_CONF_APPLICATION_LIBRARY_PATH=$_CONF_LIBRARY_PATH/$_APPLICATION_NAME
: ${_CONF_NETWORK_TEST_TIMEOUT:=5}
: ${_CONF_NETWORK_TEST_TARGETS:="http://connectivity-check.ubuntu.com http://example.org http://www.google.com http://telehack.com http://lxer.com"}
_REQUIRED_APP_CONF="_CONF_APP_REGISTRY_GIT_URL _CONF_CLEAN_APP_REGISTRY_WORKSPACE _CONF_GNU_GREP _CONF_GNU_SED _CONF_INSTALL_CHECKSUM_CMD _CONF_LOG_SUDO_BEEP_TONE"
_sub_platform
case $_SUB_PLATFORM in
Alpine)
  _INSTALL_INSTALLER=apk
  _CONF_INSTALL_STAT_ARGUMENTS='-c %a'
  _CONF_GNU_GREP=ugrep
  _CONF_GNU_SED=sed
  _is_backgrounded() {
    :
  }
  REMOVE_UNUSED_FUNCTIONS=''
  ;;
Debian | Ubuntu)
  _INSTALL_INSTALLER=apt
  _CONF_GNU_GREP=grep
  _CONF_GNU_SED=sed
  ;;
Gentoo)
  _CONF_GNU_GREP=grep
  _CONF_GNU_SED=sed
  _PLATFORM_PACKAGES="app-eselect/eselect-repository app-portage/mirrorselect app-portage/cpuid2cpuflags sys-apps/pciutils sys-fs/dosfstools dev-vcs/git dev-tcltk/expect net-misc/curl dev-util/sh app-admin/sudo sys-apps/usbutils"
  _PLATFORM_PACKAGES_ACCEPT_KEYWORDS="dev-util/sh ~amd64"
  _NPM_PACKAGE="net-libs/nodejs"
  _RUST_PACKAGE="dev-lang/rust"
  _PYPI_PACKAGE="dev-lang/python"
  _GO_PACKAGE="dev-lang/go"
  _INSTALL_INSTALLER=emerge
  _CONF_INSTALL_STAT_ARGUMENTS='-c %a'
  ASSUME_ALWAYS_YES=yes
  : ${_EMERGE_OPTIONS:="-q --quiet-build --quiet-fail"}
  [ -n "$_ROOT" ] && [ "$_ROOT" != "/" ] && _EMERGE_OPTIONS="$_EMERGE_OPTIONS --root=$_ROOT"
  ;;
CentOS | RedHat)
  _CONF_GNU_GREP=grep
  _CONF_GNU_SED=sed
  _INSTALL_INSTALLER=yum
  ;;
*)
  error "Unknown Linux Distribution: $_SUB_PLATFORM"
  ;;
esac
_is_backgrounded && _BACKGROUNDED=1
_init_logging
unset _DEFERS _EXIT
_APPLICATION_START_TIME=$(date +%s)
_APPLICATION_CMD=$(basename $0)
trap _on_exit INT 0 1 2 3 4 6 15
for _ARG in "$@"; do
  case $_ARG in
  -conf-* | -[a-z0-9][a-z0-9][a-z0-9]*)
    _configuration_name=${_ARG#*-}
    _configuration_name=${_configuration_name%%=*}
    if [ $(printf '%s' "$_configuration_name" | grep -c '_') -eq 0 ]; then
      if [ $(printf '%s' "$_configuration_name" | grep -c '^conf') -gt 0 ]; then
        _configuration_name=$(printf '%s' "$_configuration_name" | sed -e "s/-/-$_APPLICATION_NAME-/")
      else
        _configuration_name=$(printf '%s' "$_configuration_name" | sed -e "s/^/$_APPLICATION_NAME-/")
      fi
    fi
    _configuration_name=$(printf '%s' $_configuration_name | tr '-' '_' | tr '[:lower:]' '[:upper:]')
    if [ $(printf '%s' "$_ARG" | grep -c '=') -eq 0 ]; then
      _configuration_value=1
    else
      _configuration_value=${_ARG#*=}
    fi
    export _$_configuration_name="$_configuration_value"
    unset _configuration_name
    shift
    ;;
  -h | --help)
    _print_help_and_exit
    ;;
  -w=*)
    _WAITER_PID="${1#*=}"
    shift
    ;;
  -w)
    _WAITEE=1
    shift
    ;;
  *)
    break
    ;;
  esac
done
for _REQUIRED_APP_CONF_ITEM in $_REQUIRED_APP_CONF; do
  _variable_is_set $_REQUIRED_APP_CONF_ITEM || {
    warn "$_REQUIRED_APP_CONF_ITEM is unset"
    _MISSING_REQUIRED_CONF=1
  }
done
[ -n "$_MISSING_REQUIRED_CONF" ] && error "Required configuration is missing, please refer to above error(s)"
if [ -z "$_CONTEXT_VALIDATED" ]; then
  _context_id_is_valid "$_CONF_INSTALL_CONTEXT"
  _CONTEXT_VALIDATED=0
fi
_APPLICATION_CONTEXT_GROUP=$_CONF_RUN_PATH/$_CONF_INSTALL_CONTEXT
_APPLICATION_CMD_DIR=$_APPLICATION_CONTEXT_GROUP/$_APPLICATION_NAME/$_APPLICATION_CMD
_waitee_init
_waiter
_package_update
