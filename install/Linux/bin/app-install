#!/bin/sh
set -a
_APPLICATION_NAME=install
_beep() {
	beep $1 &
}
_sudo_precmd() {
	_beep "$_CONF_LOG_SUDO_BEEP_TONE"
}
_context_id_is_valid() {
	printf '%s' "$1" | $_CONF_GNU_GREP -Pq '^[a-zA-Z0-9_+-]+$' || _ERROR "Context ID *MUST* only contain alphanumeric characters and +-: '^[a-zA-Z0-9_+-]+$' | ($1)"
}
_variable_is_set() {
	env | grep -cqm1 "^$1=.*$"
}
_environment_filter() {
	$_CONF_GNU_GREP -P "(^_CONF_|^_OPTN_|^_INSTALL_|^${_TARGET_APPLICATION_NAME}_)"
}
_environment_dump() {
	[ -z "$_APPLICATION_PIPE_DIR" ] && return
	[ -z "$_ENVIRONMENT_FILE" ] && _ENVIRONMENT_FILE=$_APPLICATION_PIPE_DIR/environment
	mkdir -p $(dirname $_ENVIRONMENT_FILE)
	env | _environment_filter | sort -u | grep -v '^$' | sed -e 's/=/="/' -e 's/$/"/' >>$_ENVIRONMENT_FILE
}
_call() {
	local function_name=$1
	type $function_name >/dev/null 2>&1 || {
		_DEBUG "${function_name} does not exist"
		return 255
	}
	[ $# -gt 1 ] && {
		shift
		$function_name "$@"
		return $?
	}
	$function_name
}
_() {
	_reset_indent
	if [ -n "$_EXEC_ATTEMPTS" ]; then
		local attempt=1
		while [ $attempt -le $_EXEC_ATTEMPTS ]; do
			_WARN_ON_ERROR=1 _do_exec "$@" && return
			attempt=$(($attempt + 1))
		done
		_ERROR "Failed after $attempt attempts: $*"
	fi
	_do_exec "$@"
}
_do_exec() {
	local successful_exit_status=0
	if [ -n "$_SUCCESSFUL_EXIT_STATUS" ]; then
		successful_exit_status=$_SUCCESSFUL_EXIT_STATUS
		unset _SUCCESSFUL_EXIT_STATUS
	fi
	_INFO "## $*"
	local exit_status
	if [ -z "$_DRY_RUN" ]; then
		"$@"
		exit_status=$?
	else
		_WARN "using dry run status: $_DRY_RUN"
		exit_status=$_DRY_RUN
	fi
	if [ $exit_status -ne $successful_exit_status ]; then
		if [ -n "$_ON_FAILURE" ]; then
			$_ON_FAILURE
			return
		fi
		if [ -z "$_WARN_ON_ERROR" ]; then
			_ERROR "Previous cmd failed: $* - $exit_status"
		else
			unset _WARN_ON_ERROR
			_WARN "Previous cmd failed: $* - $exit_status"
			_ENVIRONMENT_FILE=$(_mktemp error) _environment_dump
			return $exit_status
		fi
	fi
}
_ERROR() {
	if [ $# -ge 2 ]; then
		_EXIT_STATUS=$2
	else
		_EXIT_STATUS=1
	fi
	_EXIT_LOG_LEVEL=4
	_EXIT_STATUS_CODE="ERR"
	_EXIT_COLOR_CODE="$_CONF_LOG_C_ERR"
	_EXIT_MESSAGE="$1 ($_EXIT_STATUS)"
	_EXIT_BEEP="$_CONF_LOG_BEEP_ERR"
	_defer _environment_dump
	_defer _log_app_exit
	_run_defers
	exit $_EXIT_STATUS
}
_success() {
	_EXIT_STATUS=0
	_EXIT_LOG_LEVEL=1
	_EXIT_STATUS_CODE="SCS"
	_EXIT_COLOR_CODE="$_CONF_LOG_C_SCS"
	_EXIT_MESSAGE="$1"
	_EXIT_BEEP="$_CONF_LOG_BEEP_SCS"
	_defer _long_running_cmd
	_defer _log_app_exit
	_run_defers
	exit $_EXIT_STATUS
}
_on_hup() {
	:
}
_on_int() {
	_ERROR "interrupted"
}
_on_quit() {
	_ERROR "quit"
}
_on_illegal() {
	_ERROR "illegal instruction"
}
_on_abort() {
	_ERROR "abort"
}
_on_alarm() {
	_ERROR "alarm"
}
_on_term() {
	_ERROR "term"
}
_defer() {
	if [ -n "$_DEFERS" ]; then
		local defer
		for defer in $_DEFERS; do
			[ "$defer" = "$1" ] && {
				_DEBUG "not deferring: $1 as it was already deferred"
				return
			}
		done
	fi
	_DEBUG "deferring: $1"
	_DEFERS="$1 $_DEFERS"
}
_run_defers() {
	[ -z "$_DEFERS" ] && return 1
	local defer
	for defer in $_DEFERS; do
		_call $defer
	done
	unset _DEFERS
}
_log_app_exit() {
	[ "$_EXIT_MESSAGE" ] && {
		local current_time=$(date +%s)
		local timeout=$(($_APPLICATION_START_TIME + $_CONF_LOG_BEEP_TIMEOUT))
		[ $current_time -le $timeout ] && unset _EXIT_BEEP
		_print_log $_EXIT_LOG_LEVEL "$_EXIT_STATUS_CODE" "$_EXIT_COLOR_CODE" "$_EXIT_BEEP" "$_EXIT_MESSAGE"
	}
	_log_app exit
	[ -n "$_LOGFILE" ] && [ -n "$_OPTN_LOG_EXIT_CMD" ] && {
		$_OPTN_LOG_EXIT_CMD -file $_LOGFILE
	}
}
_print_help() {
	if [ -e $2 ]; then
		_INFO "$1:"
		cat $2
		printf '\n'
	fi
}
_print_help_and_exit() {
	_print_help 'system-wide options' $_CONF_LIBRARY_PATH/install/help/default
	if [ "$_APPLICATION_NAME" != "install" ]; then
		_print_help $_APPLICATION_NAME $_CONF_LIBRARY_PATH/$_APPLICATION_NAME/help/default
		_print_help "$_APPLICATION_NAME/$_APPLICATION_CMD" $_CONF_LIBRARY_PATH/$_APPLICATION_NAME/help/$_APPLICATION_CMD
	fi
	exit 0
}
_include() {
	local include_file
	for include_file in "$@"; do
		[ -f $HOME/.config/walterjwhite/shell/$include_file ] && . $HOME/.config/walterjwhite/shell/$include_file
	done
}
_init_logging() {
	[ -n "$_LOGFILE" ] && _set_logfile "$_LOGFILE"
	case $_CONF_LOG_LEVEL in
	0)
		local logfile=$(_mktemp debug)
		_WARN "Writing debug contents to: $logfile"
		_set_logfile "$logfile"
		set -x
		;;
	esac
}
_set_logfile() {
	[ -z "$1" ] && return 1
	_LOGFILE=$1
	mkdir -p $(dirname $1)
	_reset_indent
	[ -n "$INTERACTIVE" ] && [ -z "$_CHILD" ] && {
		exec 3>&1 4>&2
		_CONF_LOG_CONSOLE=4
	}
	exec >>$_LOGFILE 2>&1
	_log_to_console "$_CONF_LOG_C_WRN" "writing logs to $_LOGFILE"
	[ -n "$_PRESERVE_LOG" ] && return
	truncate -s 0 $1 >/dev/null 2>&1
}
_WARN() {
	_print_log 3 WRN "$_CONF_LOG_C_WRN" "$_CONF_LOG_BEEP_WRN" "$1"
}
_INFO() {
	_print_log 2 INF "$_CONF_LOG_C_INFO" "$_CONF_LOG_BEEP_INFO" "$1"
}
_DETAIL() {
	_print_log 2 DTL "$_CONF_LOG_C_DETAIL" "$_CONF_LOG_BEEP_DETAIL" "$1"
}
_DEBUG() {
	_print_log 1 DBG "$_CONF_LOG_C_DEBUG" "$_CONF_LOG_BEEP_DEBUG" "($$) $1"
}
_sed_remove_nonprintable_characters() {
	sed -e 's/[^[:print:]]//g'
}
_print_log() {
	if [ -z "$5" ]; then
		if test ! -t 0; then
			local log_line
			cat - | _sed_remove_nonprintable_characters |
				while read log_line; do
					_print_log $1 $2 $3 $4 "$log_line"
				done
			return
		fi
		return
	fi
	local message="$5"
	[ $1 -lt $_CONF_LOG_LEVEL ] && return
	[ -n "$_LOGGING_CONTEXT" ] && message="$_LOGGING_CONTEXT - $message"
	if [ $_BACKGROUNDED ] && [ $_OPTN_INSTALL_BACKGROUND_NOTIFICATION_METHOD ]; then
		$_OPTN_INSTALL_BACKGROUND_NOTIFICATION_METHOD "$2" "$_message" &
	fi
	[ -n "$4" ] && _beep "$4"
	_log_to_file "$2" "${_LOG_INDENT}$message"
	_log_to_console "$3" "${_LOG_INDENT}$message"
	[ -z "$INTERACTIVE" ] && _syslog "$message"
	return 0
}
_reset_indent() {
	unset _LOG_INDENT
}
_log_to_file() {
	[ -z "$_LOGFILE" ] && return
	printf '%s\n' "$2" >>$_LOGFILE
}
_log_to_console() {
	[ -z "$_CONF_LOG_CONSOLE" ] && return
	printf >&$_CONF_LOG_CONSOLE '\033[%s%s \033[0m\n' "$1" "$2"
}
_log_app() {
	_DEBUG "$_APPLICATION_NAME:$_APPLICATION_CMD - $1 ($$)"
}
_mktemp() {
	local suffix=$1
	[ -n "$suffix" ] && suffix=".$suffix"
	local sudo_prefix
	[ -n "$_SUDO_USER" ] && sudo_prefix=_sudo
	$sudo_prefix mktemp -${_MKTEMP_OPTIONS}t ${_APPLICATION_NAME}.${_APPLICATION_CMD}${suffix}.XXXXXXXX
}
_is_supported_platform() {
	case $_DETECTED_PLATFORM in
	$_PLATFORM)
		return 0
		;;
	*)
		printf '%s\n' "$SUPPORTED_PLATFORMS" | tr ' ' '\n' | grep -cqm1 "^$_DETECTED_PLATFORM$" && {
			_ERROR "Please use the appropriate platform application: ($_DETECTED_PLATFORM)"
		}
		_ERROR "Unsupported platform ($_DETECTED_PLATFORM)"
		;;
	esac
}
_restrict_to_single_process() {
	_has_other_instances && {
		_ERROR "$_APPLICATION_CMD is restricted to a single instance and another instance is running"
	}
	_setup_app_pipe
}
_has_other_instances() {
	find $_APPLICATION_CMD_DIR -maxdepth 1 -type p ! -name $$ 2>/dev/null | grep -qm1 '.'
}
_setup_app_pipe() {
	_APPLICATION_PIPE=$_APPLICATION_CMD_DIR/$$
	_APPLICATION_PIPE_DIR=$(dirname $_APPLICATION_PIPE)
	mkdir -p $_APPLICATION_PIPE_DIR
	mkfifo $_APPLICATION_PIPE
	_defer _cleanup_app_pipe
}
_cleanup_app_pipe() {
	rm -rf $_APPLICATION_PIPE_DIR
}
_parent_processes_pgrep() {
	pgrep -P $1
}
_is_backgrounded() {
	case $(ps -o stat= -p $$) in
	*+*)
		return 1
		;;
	esac
	return 0
}
_syslog() {
	logger -i -t "$_APPLICATION_NAME.$_APPLICATION_CMD" "$1"
}
_sudo() {
	[ $# -eq 0 ] && _ERROR 'No arguments were provided to _sudo'
	_sudo_is_required || {
		"$@"
		return
	}
	_require "$_SUDO_CMD" "_SUDO_CMD - $*"
	[ -n "$INTERACTIVE" ] && {
		$_SUDO_CMD -n ls >/dev/null 2>&1 || _sudo_precmd "$@"
	}
	$_SUDO_CMD $sudo_options "$@"
	unset sudo_options
}
_sudo_is_required() {
	[ -n "$_SUDO_USER" ] && {
		[ "$_SUDO_USER" = "$USER" ] && return 1
		sudo_options="$sudo_options -u $_SUDO_USER"
		return 0
	}
	[ "$USER" = "root" ] && return 1
	return 0
}
_timeout() {
	local timeout=$1
	shift
	local message=$1
	shift
	local timeout_units='s'
	if [ $(printf '%s' "$timeout" | grep -c '[smhd]{1}') -gt 0 ]; then
		unset timeout_units
	fi
	local timeout_level=_ERROR
	[ $_WARN ] && timeout_level=_WARN
	local sudo
	[ -n "$_SUDO_REQUIRED" ] || [ -n "$_SUDO_USER" ] && sudo=_sudo
	$sudo timeout $_OPTIONS $timeout "$@" || {
		local error_status=$?
		local error_message="Other error"
		if [ $error_status -eq 124 ]; then
			error_message="Timed Out"
		fi
		[ $_TIMEOUT_ERR_FUNCTION ] && $_TIMEOUT_ERR_FUNCTION
		$timeout_level "_timeout: $error_message: ${timeout}${timeout_units} - $message ($error_status): $sudo timeout $_OPTIONS $timeout $* ($USER)"
		return $error_status
	}
}
_waitee_init() {
	[ -z "$_WAITEE" ] && return
	_setup_app_pipe
	_WARN "($_APPLICATION_CMD) Please use -w=$$"
	_defer _waitee_done
}
_waitee_done() {
	[ -z "$_WAITEE" ] && return
	[ -e $_APPLICATION_PIPE ] || return
	_INFO "$0 process completed, notifying ($_EXIT_STATUS)"
	printf '%s\n' "$_EXIT_STATUS" >$_APPLICATION_PIPE
	_INFO "$0 downstream process picked up"
}
_waiter() {
	[ -z "$_WAITER_PID" ] && return
	_UPSTREAM_APPLICATION_PIPE=$(find $_APPLICATION_CONTEXT_GROUP -type p -name $_WAITER_PID 2>/dev/null | head -1)
	[ -z "$_UPSTREAM_APPLICATION_PIPE" ] && _ERROR "$_WAITER_PID not found"
	[ ! -e $_UPSTREAM_APPLICATION_PIPE ] && {
		_WARN "$_UPSTREAM_APPLICATION_PIPE does not exist, did upstream start?"
		return
	}
	_INFO "Waiting for upstream to complete: $_WAITER_PID"
	while :; do
		if [ ! -e $_UPSTREAM_APPLICATION_PIPE ]; then
			_ERROR "Upstream pipe no longer exists"
		fi
		_UPSTREAM_APPLICATION_STATUS=$(_timeout $_CONF_WAIT_INTERVAL "_waiter:upstream" cat $_UPSTREAM_APPLICATION_PIPE 2>/dev/null)
		local upstream_status=$?
		if [ $upstream_status -eq 0 ]; then
			if [ -z "$_UPSTREAM_APPLICATION_STATUS" ] || [ $_UPSTREAM_APPLICATION_STATUS -gt 0 ]; then
				_ERROR "Upstream exited with _ERROR ($_UPSTREAM_APPLICATION_STATUS)"
			fi
			_WARN "Upstream finished: $_UPSTREAM_APPLICATION_PIPE ($upstream_status)"
			break
		fi
		_DETAIL " Upstream is still running: $_UPSTREAM_APPLICATION_PIPE ($upstream_status)"
		sleep 1
	done
}
_require() {
	local level=_ERROR
	if [ -z "$1" ]; then
		[ -n "$_WARN_ON_ERROR" ] && level=_WARN
		$level "$2 required $_REQUIRE_DETAILED_MESSAGE" $3
		return 1
	fi
	unset _REQUIRE_DETAILED_MESSAGE
}
_mail() {
	if [ $# -lt 3 ]; then
		_WARN "recipients[0], subject[1], message[2] is required - $# arguments provided"
		return 1
	fi
	local recipients=$(printf '%s' "$1" | tr '|' ' ')
	shift
	local subject="$1"
	shift
	local message="$1"
	shift
	printf "$message" | mail -s "$subject" $recipients
}
_alert() {
	_print_log 5 ALRT "$_CONF_LOG_C_ALRT" "$_CONF_LOG_BEEP_ALRT" "$1"
	local recipients="$_OPTN_LOG_ALERT_RECIPIENTS"
	local subject="Alert: $0 - $1"
	if [ -z "$recipients" ]; then
		_WARN "recipients is empty, aborting"
		return 1
	fi
	_mail "$recipients" "$subject" "$2"
}
_long_running_cmd() {
	[ -n "$_OPTN_DISABLE_LONG_RUNNING_CMD_NOTIFICATION" ] && return
	_APPLICATION_END_TIME=$(date +%s)
	_APPLICATION_RUNTIME=$(($_APPLICATION_END_TIME - $_APPLICATION_START_TIME))
	[ $_APPLICATION_RUNTIME -lt $_CONF_LOG_LONG_RUNNING_CMD ] && return
	local subject="[$_APPLICATION_NAME] - $_EXIT_MESSAGE - ($_EXIT_STATUS)"
	local message=""
	if [ -n "$_LOGFILE" ]; then
		message=$(tail -$_CONF_LOG_LONG_RUNNING_CMD_LINES $_LOGFILE | _sed_remove_nonprintable_characters)
	fi
	_alert "$subject" "$message"
}
_is_app() {
	[ ! -e .app ] && return 1
	return 0
}
_disable_feature() {
	if [ -z "$_FEATURE_DISABLED" ]; then
		_WARN "Error installing feature: $_FEATURE ($1)"
	fi
	printf '%s\n' $(_feature_key $1)_DISABLED=1 | _metadata_write
}
_is_feature_enabled() {
	local _feature_key=$(_feature_key $1)
	if [ $(env | grep -c "^${_feature_key}_DISABLED=1$") -gt 0 ]; then
		_WARN "$1 is disabled"
		return 1
	fi
	return 0
}
_feature_key() {
	printf '%s\n' "_FEATURE_${1}" | tr '[:lower:]' '[:upper:]' | tr '-' '_'
}
_do_clone() {
	[ -e $2 ] && {
		local opwd=$PWD
		cd $2
		git pull || _ERROR "Unable to update : $2"
		cd $opwd
		return
	}
	git clone $1 $2 && _DETAIL "Using $1 -> $2"
}
_build_format_shell_scripts() {
	[ -n "$_DISABLE_SHFMT" ] && return 1
	_is_shell_script $APP_BUILD_OUTPUT_FILE && shfmt -w $APP_BUILD_OUTPUT_FILE
}
_imports_import() {
	_imports_get $1 $2
	_imports $1 $APP_BUILD_OUTPUT_FILE
}
_imports_get() {
	_RAW_IMPORTS=$($_CONF_GNU_GREP -P "^$1 " "$2" | sed -e "s/$1 //" | sort -u)
}
_imports() {
	[ -z "$_RAW_IMPORTS" ] && return 1
	_call $before_function
	local raw_import
	for raw_import in $_RAW_IMPORTS; do
		_import "$1" "$2" "$3$raw_import"
	done
	_imports_get $1 $2
	$_CONF_GNU_SED -i "/^$1 .*/d" $2
	_imports "$@"
}
_import() {
	local import_type=$1
	shift
	local import_ref="$2"
	case $import_ref in
	git:*)
		_setup_git_import "$import_ref"
		case $GIT_IMPORT_TARGET_FILE in
		*.feature/*)
			local feature_patha=$(printf '%s\n' $GIT_IMPORT_TARGET_FILE | $_CONF_GNU_GREP -Po '^feature/.*\.feature')
			local feature_pathb=$(printf '%s\n' $GIT_IMPORT_TARGET_FILE | sed -e 's/^.*\.feature//')
			import_type=$import_type git_import_path=$GIT_IMPORT_PROJECT _import_file_contents $1 $GIT_IMPORT_PATH/$feature_patha/$import_type/%s/$feature_pathb
			;;
		*)
			import_type=$import_type git_import_path=$GIT_IMPORT_PROJECT _import_file_contents $1 $GIT_IMPORT_PATH/$import_type/%s/$GIT_IMPORT_TARGET_FILE
			;;
		esac
		;;
	feature:*)
		local feature_path=$(printf '%s' $1 | $_CONF_GNU_GREP -Po 'feature.*\.feature')
		local feature_arg="${import_ref#*feature:}"
		_import_file_contents $1 $feature_path/$import_type/%s/$feature_arg
		;;
	*.feature/*)
		local feature_patha=$(printf '%s\n' $import_ref | $_CONF_GNU_GREP -Po '^feature/.*\.feature')
		local feature_pathb=$(printf '%s\n' $import_ref | sed -e 's/^.*\.feature//')
		_import_file_contents $1 $feature_patha/$import_type/%s/$feature_pathb
		;;
	.*)
		_import_file_contents $1 $import_type/%s/$import_ref
		;;
	*)
		_import_file_contents $1 $_PROJECT_ROOT/$import_type/%s/$import_ref
		;;
	esac
}
_import_file_contents() {
	local file=$1
	shift
	local platform_path=$(printf "$1" $_TARGET_PLATFORM)
	local all_path=$(printf "$1" all)
	_require_file "$file" "_import_file_contents"
	_import_has_matching_files $platform_path $all_path
	local file_to_import
	for file_to_import in $(find $platform_path $all_path \( -type f -or -type l \) -and ! -name '*.test' 2>/dev/null | sort -u); do
		printf '%s\n' "$IMPORTED" | $_CONF_GNU_GREP -Pcqm1 $file_to_import && {
			_DEBUG "$file_to_import was already imported"
			continue
		}
		IMPORTED="$file_to_import\n$IMPORTED"
		if [ -e ${file_to_import}.test ]; then
			${file_to_import}.test $APP_BUILD_OUTPUT_FILE
			if [ "$?" -eq "0" ]; then
				cat $file_to_import >>$file
			else
				_DEBUG "$file_to_import failed test"
			fi
		else
			cat $file_to_import >>$file
		fi
	done
}
_import_has_matching_files() {
	[ -n "$_OPTIONAL" ] && return
	find $1 $2 -type f -or -type l 2>/dev/null | grep -q . || _ERROR "_import_file_contents - no matching files found: $1 $2"
}
_inject_header() {
	printf '#!/bin/sh\n\n' >$APP_BUILD_OUTPUT_FILE
}
_inject_app_header() {
	printf 'set -a\n' >>$APP_BUILD_OUTPUT_FILE
}
_inject_app_name() {
	printf '_APPLICATION_NAME=%s\n' $_TARGET_APPLICATION_NAME >>$APP_BUILD_OUTPUT_FILE
}
_INJECT_FULL() {
	_inject_header
	_inject_app_header
	_inject_app_name
	_required_arguments $1
	_RAW_IMPORTS="$LIB" _imports lib $APP_BUILD_OUTPUT_FILE
	_inject_lib $1
	_OPTIONAL=1 _RAW_IMPORTS="$CFG . $_TARGET_APPLICATION_NAME" before_function=_inject_cfg_before _imports cfg $APP_BUILD_OUTPUT_FILE
	_inject_cfg $1
	_required_cfg
	_inject_init $1
	chmod +x $APP_BUILD_OUTPUT_FILE $1
	_build_format_shell_scripts
	$_CONF_GNU_GREP -Pvh '^(#|lib |cfg |init |_REQUIRED_ARGUMENTS)' $1 >>$APP_BUILD_OUTPUT_FILE
}
_inject_lib() {
	_imports_import lib $1
	unset IMPORTED
}
_inject_cfg() {
	before_function=_inject_cfg_before _imports_import cfg $1
	unset IMPORTED
}
_inject_cfg_before() {
	local imports=$(printf '%s\n' "$_RAW_IMPORTS" | sort -u | sed -e 's/feature://' -e 's/.\///g' -e 's/^.$//' -e 's/ . / /' | tr '\n' ' ')
	printf '_include %s %s\n' "$imports" >>$APP_BUILD_OUTPUT_FILE
}
_inject_init() {
	_OPTIONAL=1 _import init $APP_BUILD_OUTPUT_FILE platform
	_import init $APP_BUILD_OUTPUT_FILE full
	_imports_import init $1
	unset IMPORTED
}
_INJECT_LITE() {
	$_CONF_GNU_GREP -Pcq '^(init |_REQUIRED_ARGUMENTS )' $1 && _ERROR "Files may not contain init or _REQUIRED_ARGUMENTS"
	_inject_header
	case $1 in
	*.sh)
		_inject_app_name
		;;
	esac
	_inject_lib $1
	_inject_cfg $1
	chmod +x $APP_BUILD_OUTPUT_FILE $1
	_build_format_shell_scripts
	$_CONF_GNU_GREP -Pvh '^(#|lib |cfg )' $1 >>$APP_BUILD_OUTPUT_FILE
}
_INJECT_NONE() {
	cp -p $1 $APP_BUILD_OUTPUT_FILE
}
_required_arguments() {
	_REQUIRED_ARGUMENTS=$($_CONF_GNU_GREP -P "^_REQUIRED_ARGUMENTS=" "$1")
	[ -z "$_REQUIRED_ARGUMENTS" ] && return 1
	printf '%s\n' "$_REQUIRED_ARGUMENTS" >>$APP_BUILD_OUTPUT_FILE
}
_required_cfg() {
	local required_cfg=$($_CONF_GNU_GREP -Pvh '#.*$' $APP_BUILD_OUTPUT_FILE |
		$_CONF_GNU_GREP -Poh '\$_CONF_[\w_]{3,}' | sed -e 's/^\$//' | sort -u)
	local defaults=$($_CONF_GNU_GREP -Poh '_CONF_[\w]{3,}:?=' $APP_BUILD_OUTPUT_FILE | sed -e 's/^\$//' -e 's/:=$//' -e 's/=$//' | sort -u | tr '\n' '|' | sed -e 's/|$//' -e 's/^/(/' -e 's/$/)/')
	local required_app_conf=$(printf '%s\n' "$required_cfg" | $_CONF_GNU_GREP -Pv "$defaults" | tr '\n' ' ' | sed -e 's/ $//')
	[ -n "$required_app_conf" ] && printf '_REQUIRED_APP_CONF="%s"\n' "$required_app_conf" >>$APP_BUILD_OUTPUT_FILE
}
_setup_project() {
	case $_TARGET_APPLICATION_NAME in
	*.zip:*)
		_install_app_registry_from_zip
		;;
	*)
		_clone
		;;
	esac
	_is_latest $_TARGET_APPLICATION_NAME && {
		[ -z "$_INSTALL_FORCE" ] && {
			_WARN "Latest version of app is already installed: $_TARGET_APPLICATION_NAME [$_LATEST_APPLICATION_VERSION]"
			return 1
		}
	}
	_is_app
	_TARGET_PLATFORM=$_PLATFORM
	[ ! -e $_TARGET_PLATFORM ] && _ERROR "No artifacts exist for $_TARGET_PLATFORM"
	_application_settings
	_application_defaults $_TARGET_PLATFORM
	[ $_OPTN_INSTALL_BYPASS_UNINSTALL ] || _uninstall
	_prepare_target
	_bootstrap
	_metadata_write_app
	_install $_TARGET_PLATFORM
	_setup setup
	[ -e $_TARGET_PLATFORM/feature ] && _features $_TARGET_PLATFORM/feature
	_setup post-setup
	_INFO "$_TARGET_APPLICATION_NAME - Completed installation"
}
_is_latest() {
	[ ! -e $_INSTALL_LIBRARY_PATH/$1/.metadata ] && return 1
	_INSTALLED_APPLICATION_GIT_URL=$(grep _APPLICATION_GIT_URL $_INSTALL_LIBRARY_PATH/$1/.metadata 2>/dev/null | cut -f2 -d= | tr -d '"')
	_LATEST_APPLICATION_VERSION=$_TARGET_APPLICATION_VERSION
	_INSTALLED_APPLICATION_VERSION=$(grep _APPLICATION_VERSION $_INSTALL_LIBRARY_PATH/$1/.metadata 2>/dev/null | cut -f2 -d= | tr -d '"')
	[ "$_LATEST_APPLICATION_VERSION" = "$_INSTALLED_APPLICATION_VERSION" ]
}
_bootstrap_install() {
	[ -e $_APPLICATION_METADATA_PATH ] && return
	_DETAIL "Bootstrapping install"
	_PACKAGE_BOOTSTRAP
	_PACKAGE_INSTALL $_PLATFORM_PACKAGES
}
_features() {
	_INFO "Installing ${_FEATURE_MESSAGE}features"
	local feature
	for feature in $(_features_find $1 | sort -u); do
		_FEATURE_NAME=$(printf '%s' $feature | sed -e 's/\.feature/\.feature\n/g' | $_CONF_GNU_GREP -Po '/[a-zA-Z0-9-_]*.feature$' | sed -e 's/^\///' -e 's/\.feature$//' | tr '\n' '_' | sed -e 's/_$//')
		_application_defaults $feature
		_is_feature_enabled $_FEATURE_NAME || {
			_FEATURE_DISABLED=1 _disable_feature $_FEATURE_NAME
			_features_unset
			continue
		}
		_feature $feature || {
			_disable_feature $_FEATURE_NAME
			_features_unset
			continue
			_FEATURE_ERROR=1
		}
		[ -e $feature/feature ] && {
			_FEATURE_MESSAGE="children " _WARN_ON_ERROR=1 _features $feature/feature
		}
		_features_unset
	done
}
_features_unset() {
	unset _FEATURE_NAME _FEATURE_DISABLED
}
_features_find() {
	if [ -z "$_FEATURE_MESSAGE" ]; then
		find $1 -type d \( -name '*.feature' -and ! -path '*/*.feature/*' \)
	else
		find $1 -type d -name '*.feature' -and ! -path "$1"
	fi
}
_feature() {
	_DETAIL $_FEATURE_NAME
	_install $1 || return $?
	_feature_setup $1 || return $?
}
_feature_setup() {
	local setup_script
	for setup_script in $(find $1 -type f \( -path "$1/setup/*" \) | sort -u); do
		_setup_run_script $setup_script || return 1
	done
}
_clone() {
	_INFO "Git Clone: $_TARGET_APPLICATION_NAME"
	_do_clone $_CONF_APP_REGISTRY_GIT_URL $_CONF_DATA_REGISTRY_PATH && {
		cd $_CONF_DATA_REGISTRY_PATH
		cd $_TARGET_APPLICATION_NAME || _ERROR "$_TARGET_APPLICATION_NAME does not exist in the registry"
		_TARGET_APPLICATION_VERSION=$(grep _APPLICATION_VERSION= .app | cut -f2 -d=)
		_DETAIL "Cloned registry and $_TARGET_APPLICATION_NAME exists"
		return
	}
	_ERROR "Unable to clone: $_TARGET_APPLICATION_NAME in any of $_CONF_APP_REGISTRY_GIT_URL"
}
_install_app_registry_from_zip() {
	_DETAIL "Installing from app.registry zip: $_TARGET_APPLICATION_NAME"
	[ -z "$_APP_REGISTRY_ZIP_EXTRACTED" ] && {
		rm -rf $_CONF_DATA_REGISTRY_PATH && mkdir -p $_CONF_DATA_REGISTRY_PATH
		local temp_dir=$(_MKTEMP_OPTIONS=d _mktemp)
		local zip_file="${_TARGET_APPLICATION_NAME%%:*}"
		_extract $zip_file $temp_dir || _ERROR "Error extracting zip"
		cd $temp_dir
		cd $(ls -1 | head -1)
		mv * $_CONF_DATA_REGISTRY_PATH
		_APP_REGISTRY_ZIP_EXTRACTED=1
		cd $_CONF_DATA_REGISTRY_PATH
		rm -rf $temp_dir
	}
	_TARGET_APPLICATION_NAME=${_TARGET_APPLICATION_NAME#*:}
	cd $_CONF_DATA_REGISTRY_PATH
	cd $_TARGET_APPLICATION_NAME || _ERROR "$_TARGET_APPLICATION_NAME does not exist in the registry"
	_TARGET_APPLICATION_VERSION=$(_install_app_registry_checksum)
	_DETAIL "$_TARGET_APPLICATION_NAME exists @ $_TARGET_APPLICATION_VERSION"
}
_install_app_registry_checksum() {
	for f in $(find . -type f | sort -u); do
		sha256sum $f | awk {'print$1'}
	done | sha256sum | awk {'print$1'}
}
_prepare_target() {
	_sudo rm -rf $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME
	_sudo mkdir -p $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME
}
_install() {
	_sudo mkdir -p $_INSTALL_BIN_PATH
	_install_help $1
	local installed_files=$(_mktemp)
	_install_cmds $1 $installed_files
	_install_uninstall $1
	_install_files_files $1 $installed_files
	_install_update_files $installed_files
	if [ -e $1/.metadata ]; then
		cat $1/.metadata | _write "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.metadata"
	fi
}
_install_files() {
	if [ -e $1 ] && [ $(find $1 -type f | wc -l) -gt 0 ]; then
		if [ -n "$3" ]; then
			local files_sed_safe=$(_sed_safe $1)
			local target_sed_safe=$(_sed_safe $2)
			find $1 -type f | sed -e "s/^$files_sed_safe/$target_sed_safe/" >>$3
		fi
		_sudo mkdir -p $2
		tar -c $_TAR_ARGS -C $1 . | _sudo tar -xop $_TAR_ARGS -C $2
	fi
}
_install_help() {
	_install_files $1/help $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/help
}
_install_cmds() {
	if [ "$_TARGET_APPLICATION_NAME" = "$_APPLICATION_NAME" ]; then
		printf '%s\n' "$_INSTALL_BIN_PATH/$(basename $0)" >>$2
	fi
	_install_files $1/bin $_INSTALL_BIN_PATH $2
}
_install_uninstall() {
	_install_files $1/uninstall $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/uninstall
}
_install_files_files() {
	_install_files $1/files/_ROOT_ $_ROOT $2
	_install_files $1/files/_APPLICATION_ROOT_ "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME" $2
}
_install_update_files() {
	if [ -n "$_ROOT" ] && [ "$_ROOT" != "/" ]; then
		local root_sed_safe=$(_sed_safe $_ROOT)
		$_CONF_GNU_SED -i "s/^$root_sed_safe//" $1
	fi
	_INSTALLED_FILES="$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.files"
	cat $1 | _write "$_INSTALLED_FILES"
	rm -f $1
	_sudo chmod 444 $_INSTALLED_FILES
}
_metadata_write_app() {
	_sudo rm -f $_TARGET_APPLICATION_METADATA_PATH
	printf '_APPLICATION_NAME="%s"\n' "$_TARGET_APPLICATION_NAME" | _metadata_write
	printf '_APPLICATION_GIT_URL="%s"\n' "$_TARGET_APPLICATION_GIT_URL" | _metadata_write
	printf '_APPLICATION_INSTALL_DATE="%s"\n' "$_TARGET_APPLICATION_INSTALL_DATE" | _metadata_write
	printf '_APPLICATION_BUILD_DATE="%s"\n' "$_TARGET_APPLICATION_BUILD_DATE" | _metadata_write
	printf '_APPLICATION_VERSION="%s"\n' "$_TARGET_APPLICATION_VERSION" | _metadata_write
}
_metadata_write() {
	_write $_TARGET_APPLICATION_METADATA_PATH
}
_metadata_is_set() {
	grep -cqm1 "$1" $_TARGET_APPLICATION_METADATA_PATH 2>/dev/null
}
_install_metadata_write() {
	_write $_APPLICATION_METADATA_PATH
}
_metadata_write_platform() {
	env | grep '^_BOOTSTRAP_' | _install_metadata_write
}
_APP_BOOTSTRAP() {
	:
}
_APP_INSTALL() {
	_DEPENDENCY=1 app-install $1
}
_APP_UNINSTALL() {
	app-uninstall $1
}
_APP_IS_INSTALLED() {
	[ -e $_CONF_LIBRARY_PATH/$1/.metadata ]
}
_APP_IS_FILE() {
	return 1
}
_CRONTAB_BOOTSTRAP() {
	:
}
_CRONTAB_INSTALL() {
	local osudo_user=$_SUDO_USER
	_SUDO_USER=root
	_CRONTAB_UNINSTALL
	local temp_crontab=$(_mktemp)
	_sudo cp $1 $temp_crontab
	_sudo $_CONF_GNU_SED -i "s/$/ # app.$_TARGET_APPLICATION_NAME/" $temp_crontab
	printf '\n' | _sudo tee -a $temp_crontab >/dev/null 2>&1
	_sudo $_CONF_GNU_SED -i "1i # app.$_TARGET_APPLICATION_NAME" $temp_crontab
	_sudo $_CONF_GNU_SED -i "1i \\" $temp_crontab
	_crontab_append $_SUDO_USER $temp_crontab
	_sudo rm -f $temp_crontab
	_SUDO_USER=$osudo_user
}
_CRONTAB_UNINSTALL() {
	local osudo_user=$_SUDO_USER
	_SUDO_USER=root
	local temp_crontab=$(_mktemp)
	_CRONTAB_REMOVE $temp_crontab
	_crontab_write $_SUDO_USER $temp_crontab
	_sudo rm -f $temp_crontab
	_SUDO_USER=$osudo_user
}
_CRONTAB_REMOVE() {
	_crontab_get $_SUDO_USER $1
	_sudo $_CONF_GNU_SED -i '/^$/d' $1
	_sudo $_CONF_GNU_SED -i "/# app.$_TARGET_APPLICATION_NAME/d" $1
}
_CRONTAB_IS_INSTALLED() {
	local osudo_user=$_SUDO_USER
	_SUDO_USER=root
	local temp_crontab=$(_mktemp)
	_crontab_get $_SUDO_USER $temp_crontab
	_sudo grep -qm1 "# app.$_TARGET_APPLICATION_NAME" $temp_crontab
	_sudo rm -f $temp_crontab
	_SUDO_USER=$osudo_user
}
_CRONTAB_ENABLED() {
	return 0
}
_CRONTAB_IS_FILE() {
	return 0
}
_EXPECT_BOOTSTRAP() {
	_EXPECT_BOOTSTRAP_IS_EXPECT_AVAILABLE || {
		_PACKAGE_INSTALL $EXPECT_PACKAGE
		_EXPECT_BOOTSTRAP_IS_EXPECT_AVAILABLE || EXPECT_DISABLED=1
	}
}
_EXPECT_BOOTSTRAP_IS_EXPECT_AVAILABLE() {
	which expect >/dev/null 2>&1
}
_EXPECT_INSTALL() {
	$1 >/dev/null 2>&1
}
_EXPECT_UNINSTALL() {
	_WARN "expect uninstall - Not implemented"
}
_EXPECT_IS_INSTALLED() {
	return 1
}
_EXPECT_IS_FILE() {
	return 0
}
_GO_BOOTSTRAP() {
	_GO_BOOTSTRAP_IS_GO_AVAILABLE || {
		_PACKAGE_INSTALL $GO_PACKAGE
		_GO_BOOTSTRAP_IS_GO_AVAILABLE || GO_DISABLED=1
	}
}
_GO_BOOTSTRAP_IS_GO_AVAILABLE() {
	which go >/dev/null 2>&1
}
_GO_INSTALL() {
	_GO_BOOTSTRAP
	GO111MODULE=on GOPATH=$GO_INSTALL_PATH sudo_options="--preserve-env=GO111MODULE,GOPATH" _sudo go install $GO_OPTIONS "$@" || {
		_WARN "go install failed: $GO_OPTIONS $@"
		_WARN "  http_proxy: $http_proxy"
		_WARN "  git  proxy: $(git config --global http.proxy)"
	}
}
_GO_UPDATE() {
	:
}
_GO_UNINSTALL() {
	_sudo go uninstall "$@"
}
_GO_IS_INSTALLED() {
	return 1
}
_GO_IS_FILE() {
	return 1
}
_NPM_BOOTSTRAP() {
	_NPM_BOOTSTRAP_IS_NPM_AVAILABLE || {
		_PACKAGE_INSTALL $NPM_PACKAGE
		_NPM_BOOTSTRAP_IS_NPM_AVAILABLE || NPM_DISABLED=1
	}
	_NPM_SETUP_PROXY
}
_NPM_BOOTSTRAP_IS_NPM_AVAILABLE() {
	which npm >/dev/null 2>&1
}
_NPM_INSTALL() {
	local npm_package
	for npm_package in "$@"; do
		_NPM_IS_INSTALLED $npm_package || _sudo npm install -s -g "$npm_package"
	done
}
_NPM_UNINSTALL() {
	_sudo npm uninstall -s -g "$@"
}
_NPM_IS_INSTALLED() {
	npm list -g $1 >/dev/null
}
_NPM_IS_FILE() {
	return 1
}
_NPM_SETUP_PROXY() {
	if [ -n "$http_proxy" ]; then
		_WARN "Configuring NPM to use an HTTP proxy: $http_proxy"
		npm config set proxy $http_proxy
		npm config set https-proxy $https_proxy
		_defer _NPM_CLEAR_PROXY
	fi
}
_NPM_CLEAR_PROXY() {
	_WARN "Reverting NPM HTTP proxy: $http_proxy"
	npm config rm proxy
	npm config rm https-proxy
}
_PACKAGE_BOOTSTRAP() {
	:
}
_PACKAGE_INSTALL() {
	[ $# -eq 0 ] && {
		_WARN "no packages to install, none specified"
		return 1
	}
	local packages
	local package
	for package in "$@"; do
		_PACKAGE_IS_INSTALLED $package || {
			if [ -n "$packages" ]; then
				packages="$packages $package"
			else
				packages="$package"
			fi
		}
	done
	if [ -n "$packages" ]; then
		_PACKAGE_INSTALL_DO "$packages"
	else
		_WARN "Packages [$*] are already installed, skipping"
		return 0
	fi
}
_PACKAGE_IS_FILE() {
	return 1
}
_PACKAGE_ENABLED() {
	return 0
}
_PYPI_BOOTSTRAP() {
	_PYPI_BOOTSTRAP_IS_PYPI_AVAILABLE || {
		_PACKAGE_INSTALL $PYPI_PACKAGE
		_PYPI_BOOTSTRAP_IS_PYPI_AVAILABLE || PYPI_DISABLED=1
	}
}
_PYPI_BOOTSTRAP_IS_PYPI_AVAILABLE() {
	which pip >/dev/null 2>&1
}
_PYPI_INSTALL() {
	_sudo pip install -U --no-input "$@" >/dev/null
}
_PYPI_UNINSTALL() {
	_sudo pip uninstall -y "$@" >/dev/null
}
_PYPI_IS_INSTALLED() {
	_ERROR "PIP - is installed - NOT IMPLEMENTED"
}
_PYPI_IS_FILE() {
	return 1
}
_RUN_BOOTSTRAP() {
	:
}
_RUN_INSTALL() {
	sh $1
}
_RUN_UNINSTALL() {
	_WARN "run uninstall - Not implemented"
}
_RUN_IS_INSTALLED() {
	return 1
}
_RUN_IS_FILE() {
	return 0
}
_RUST_BOOTSTRAP() {
	_RUST_BOOTSTRAP_IS_RUST_AVAILABLE || {
		_PACKAGE_INSTALL $RUST_PACKAGE
		_RUST_BOOTSTRAP_IS_RUST_AVAILABLE || RUST_DISABLED=1
	}
}
_RUST_BOOTSTRAP_IS_RUST_AVAILABLE() {
	which cargo >/dev/null 2>&1
}
_RUST_INSTALL() {
	local rust_root_dir=$(printf '%s' $_INSTALL_BIN_PATH | sed 's/\/bin//')
	_sudo cargo install --root=$rust_root_dir "$@"
}
_RUST_UPDATE() {
	_sudo cargo update "$@"
}
_RUST_UNINSTALL() {
	_sudo cargo uninstall "$@"
}
_RUST_IS_INSTALLED() {
	_ERROR "RUST - is installed - NOT IMPLEMENTED"
}
_RUST_IS_FILE() {
	return 1
}
_USER_IS_FILE() {
	return 0
}
_bootstrap() {
	[ "$_APPLICATION_NAME" = "$_TARGET_APPLICATION_NAME" ] && _metadata_write_platform
	[ -z "$_PLATFORM_PACKAGES" ] && return 1
	[ -n "$_BOOTSTRAP_PLATFORM_PACKAGES_INSTALLED" ] && return 2
	_INFO "Installing pre-requisites"
	_setup_run_do_bootstrap PACKAGE
	_PACKAGE_INSTALL $_PLATFORM_PACKAGES && _BOOTSTRAP_PLATFORM_PACKAGES_INSTALLED=1
	_metadata_write_platform
}
_settings_init() {
	if [ -z "$_ROOT" ]; then
		_ROOT=/
	fi
	_ROOT=$(_readlink $_ROOT)
	_INFO "Using root directory: $_ROOT"
	_INSTALL_BIN_PATH=$(_SUDO_REQUIRED=1 _readlink $_ROOT/$_CONF_BIN_PATH)
	_INSTALL_CONFIG_PATH=$(_SUDO_REQUIRED=1 _readlink $_ROOT/$_CONF_CONFIG_PATH)
	_INSTALL_DATA_PATH=$(_SUDO_REQUIRED=1 _readlink $_ROOT/$_CONF_DATA_PATH)
	_INSTALL_LIBRARY_PATH=$(_SUDO_REQUIRED=1 _readlink $_ROOT/$_CONF_LIBRARY_PATH)
	_APPLICATION_METADATA_PATH=$_INSTALL_LIBRARY_PATH/install/.metadata
	_include $_APPLICATION_METADATA_PATH
	if [ "$_ROOT" != "/" ]; then
		unset $(env | tr '\0' '\n' | $_CONF_GNU_GREP -P '^_BOOTSTRAP_[A-Z0-9_]+=' | sed -e 's/=.*$//' | tr '\n' ' ')
	fi
}
_application_settings() {
	_TARGET_APPLICATION_BUILD_DATE=$(git log --format=%cd -1)
	_TARGET_APPLICATION_INSTALL_DATE=$(date +"%a %b %d %H:%M:%S %Y %z")
	_TARGET_APPLICATION_DATA_PATH=$_INSTALL_DATA_PATH/$_TARGET_APPLICATION_NAME
	_TARGET_APPLICATION_CONFIG_PATH="$_INSTALL_CONFIG_PATH/$_TARGET_APPLICATION_NAME"
	_TARGET_APPLICATION_METADATA_PATH=$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.metadata
	_TARGET_APPLICATION_GIT_URL=$(git remote -v | awk {'print$2'} | head -1)
	mkdir -p $_INSTALL_DATA_PATH/install $_CONF_DATA_PATH $_TARGET_APPLICATION_DATA_PATH
	_include $_TARGET_APPLICATION_CONFIG_PATH
}
_application_defaults() {
	local default_file
	for default_file in $(find $1/cfg -type f 2>/dev/null); do
		_include $default_file
	done
}
_setup() {
	[ "$_TARGET_APPLICATION_NAME" != "install" ] && [ "$_TARGET_APPLICATION_NAME" != "git" ] && _include $_TARGET_APPLICATION_NAME
	[ -e $_CONF_DATA_REGISTRY_PATH/$_TARGET_APPLICATION_NAME/$_TARGET_PLATFORM/$1 ] && _setup_run $1
	return 1
}
_setup_run() {
	local setup_script
	for setup_script in $(find $_CONF_DATA_REGISTRY_PATH/$_TARGET_APPLICATION_NAME/$_TARGET_PLATFORM/$1 -type f 2>/dev/null | sort -u); do
		_setup_run_script "$setup_script"
	done
}
_setup_run_script() {
	_SETUP_TYPE_NAME=$(basename $1)
	_setup_contains_subtype $_SETUP_TYPE_NAME && {
		_setup_sub_platform_matches $_SETUP_TYPE_NAME || {
			_WARN "Ignoring $1, does not target this sub-platform"
			return
		}
	}
	case $_SETUP_TYPE_NAME in
	*.*)
		_SETUP_TYPE_NAME=$(printf '%s' $_SETUP_TYPE_NAME | sed -e "s/^.*\.//")
		;;
	[0-9][0-9]_[[:alnum:]]*)
		_SETUP_TYPE_NAME=f_$_SETUP_TYPE_NAME
		;;
	esac
	_SETUP_TYPE_NAME=${_SETUP_TYPE_NAME%_*}
	_SETUP_TYPE_NAME=$(printf '%s' $_SETUP_TYPE_NAME | tr '[:lower:]' '[:upper:]')
	type _${_SETUP_TYPE_NAME}_BOOTSTRAP >/dev/null 2>&1 || {
		_WARN "Unknown type: $_SETUP_TYPE_NAME"
		return
	}
	if [ ! -e $1 ]; then
		_WARN "$1 no longer exists, ignoring"
		return 0
	fi
	_variable_is_set _${_SETUP_TYPE_NAME}_DISABLED && return
	_sudo mkdir -p "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type"
	_setup_run_do_bootstrap $_SETUP_TYPE_NAME
	_${_SETUP_TYPE_NAME}_IS_FILE
	if [ $? -eq 0 ]; then
		_WARN=$_CONF_LOG_FEATURE_TIMEOUT_ERROR_LEVEL _${_SETUP_TYPE_NAME}_INSTALL $1 || {
			local error=$?
			_WARN "Error installing: $_SETUP_TYPE_NAME: $1"
			return $error
		}
		_call _${_SETUP_TYPE_NAME}_GET_DATA $1 | _write "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type/.${_SETUP_TYPE_NAME}"
	else
		local packages=$($_CONF_GNU_GREP -Pv '(^$|^#)' $1 | tr '\n' ' ')
		_WARN=$_CONF_LOG_FEATURE_TIMEOUT_ERROR_LEVEL _${_SETUP_TYPE_NAME}_INSTALL $packages || {
			local error=$?
			_WARN "Error installing $packages"
			return $error
		}
		printf "$packages" | tr ' ' '\n' | _write "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type/.${_SETUP_TYPE_NAME}"
	fi
	_call _${_SETUP_TYPE_NAME}_CLEANUP
	return 0
}
_setup_contains_subtype() {
	[ -z "$_SUB_PLATFORM" ] && return 1
	case $1 in
	*_*)
		return 0
		;;
	esac
	return 1
}
_setup_sub_platform_matches() {
	local setup_type_sub_platform=${1##*_}
	setup_type_sub_platform=${setup_type_sub_platform%%.*}
	[ -z "$setup_type_sub_platform" ] && return 0
	[ "$setup_type_sub_platform" = "$_SUB_PLATFORM" ] && return 0
	return 1
}
_setup_run_do_bootstrap() {
	_setup_type_bootstrapped $1 || {
		_call _${1}_BOOTSTRAP
		_call _${1}_BOOTSTRAP_POST
		printf '_BOOTSTRAP_%s=1\n' "$1" | _install_metadata_write
	}
}
_setup_type_bootstrapped() {
	_metadata_is_set "_BOOTSTRAP_${1}=1"
}
_uninstall() {
	_require "$_TARGET_APPLICATION_NAME" "_TARGET_APPLICATION_NAME must be set"
	_require "$_INSTALL_LIBRARY_PATH" "_INSTALL_LIBRARY_PATH must be set"
	[ ! -e $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME ] && return 1
	[ ! -e $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.metadata ] && return 1
	_uninstall_script
	_uninstall_files
	_uninstall_type
	_sudo rm -Rf $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME
	_INFO "Uninstalled $_TARGET_APPLICATION_NAME"
}
_uninstall_script() {
	[ !-e $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/uninstall ] && return
	for script in $(find $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/uninstall -type f); do
		_sudo $script
	done
}
_uninstall_files() {
	[ ! -e $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.files ] && return
	if [ "$_ROOT" = "/" ]; then
		_sudo rm -f $(cat $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.files)
	else
		local sed_safe_root=$(_sed_safe $_ROOT)
		_sudo rm -f $(sed -e "s/^/$sed_safe_root/" $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.files)
	fi
	_sudo rm -f $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.files
}
_uninstall_type() {
	[ ! -e $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type ] && return 1
	for _SETUP_TYPE_FILE in $(find $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type -type f -name '.*'); do
		_SETUP_TYPE_NAME=$(basename $_SETUP_TYPE_FILE | sed -e 's/^.//')
		_uninstall_type_do
	done
}
_uninstall_type_do() {
	local packages=$($_CONF_GNU_GREP -Pv '(^$|^#)' $_SETUP_TYPE_FILE)
	if [ -z "$packages" ]; then
		_DETAIL "No ${_SETUP_TYPE_NAME}(s) to uninstall"
		return
	fi
	_INFO "Uninstalling $packages via ${_SETUP_TYPE_NAME}"
	${_SETUP_TYPE_NAME}_uninstall $packages
}
_PACKAGE_UPDATE() {
	_portage_sync
	_INFO "updating world packages"
	_sudo emerge $_EMERGE_FLAGS $_EMERGE_OPTIONS --newuse -uD world $@
	_INFO "updated world packages"
	if [ -n "$_OPTN_INSTALL_GENTOO_DEPCLEAN" ]; then
		_INFO "running depclean"
		_sudo emerge $_EMERGE_FLAGS $_EMERGE_OPTIONS --depclean $@
		_INFO "depclean completed"
	fi
}
_PACKAGE_INSTALL_DO() {
	_portage_sync
	_sudo emerge $_EMERGE_FLAGS $_EMERGE_OPTIONS $@
}
_PACKAGE_UNINSTALL() {
	_portage_sync
	_sudo emerge $_EMERGE_FLAGS $_EMERGE_OPTIONS --depclean $@
}
_PACKAGE_IS_INSTALLED() {
	[ -f $_ROOT/var/lib/portage/world ] && {
		$_CONF_GNU_GREP -Pqm1 "^${1}$" $_ROOT/var/lib/portage/world && {
			return 0
		}
	}
	local package_group=$(printf '%s' $1 | cut -f1 -d/)
	local package_name=$(printf '%s' $1 | cut -f2 -d/)
	if [ -e $_ROOT/var/db/pkg/$package_group ]; then
		find $_ROOT/var/db/pkg/$package_group -type f -name "$package_name-*.ebuild" | grep -Pqm1 '.' && {
			return 0
		}
	fi
	return 1
}
_PACKAGE_BOOTSTRAP() {
	mount | grep -qm1 'overlay on /' && {
		_WARN 'Disabling emerge as it appears we are running on an overlayfs'
		_PACKAGE_DISABLED=1
		return 1
	}
	_portage_use_git
	_portage_mirrors
	_portage_sync
	_portage_package_accept_keywords
}
_portage_sync() {
	_EMERGE_SYNC_FILE=$_CONF_APPLICATION_DATA_PATH/emerge.sync.time
	_portage_synced && {
		_DEBUG "portage was already synced today"
		return
	}
	_sudo emerge $_EMERGE_FLAGS $_EMERGE_OPTIONS --sync && date +%s >$_EMERGE_SYNC_FILE
}
_portage_synced() {
	[ ! -e $_EMERGE_SYNC_FILE ] && return 1
	local last_synced=$(head -1 $_EMERGE_SYNC_FILE)
	local current_time=$(date +%s)
	[ $(($current_time - $last_synced)) -gt $PORTAGE_REFRESH_PERIOD ] && return 1
	return 0
}
_portage_use_git() {
	[ -e $_ROOT/etc/portage/repos.conf/gentoo.conf ] && return 0
	rm -rf $_ROOT/etc/portage/repos.conf && mkdir -p $_ROOT/etc/portage/repos.conf
	printf '
  [DEFAULT]
  main-repo = gentoo
  [gentoo]
  location = /var/db/repos/gentoo
  sync-type = git
  sync-uri = https://github.com/gentoo-mirror/gentoo.git
  auto-sync = yes
  sync-git-verify-commit-signature = yes
  sync-openpgp-key-path = /usr/share/openpgp-keys/gentoo-release.asc
  ' >$_ROOT/etc/portage/repos.conf/gentoo.conf
	rm -rf $_ROOT/var/db/repos/gentoo/* && _portage_sync
}
_portage_mirrors() {
	[ "$_ROOT" = "/" ] && return
	[ ! -e /etc/portage/make.conf ] && return
	grep -qm1 '^GENTOO_MIRRORS=.*$' /etc/portage/make.conf || return
	grep -qm1 '^GENTOO_MIRRORS=.*$' $_ROOT/etc/portage/make.conf && return
	printf '# mirror from host\n' >>$_ROOT/etc/portage/make.conf
	grep '^GENTOO_MIRRORS=.*$' /etc/portage/make.conf >>$_ROOT/etc/portage/make.conf
}
_portage_package_accept_keywords() {
	[ -e $_ROOT/etc/portage/package.accept_keywords/platform ] && return
	_sudo mkdir -p $_ROOT/etc/portage/package.accept_keywords /etc/portage/package.accept_keywords
	printf '%s\n' "$_PLATFORM_PACKAGES_ACCEPT_KEYWORDS" | _write $_ROOT/etc/portage/package.accept_keywords/platform
	printf '%s\n' "$_PLATFORM_PACKAGES_ACCEPT_KEYWORDS" | _write /etc/portage/package.accept_keywords/platform
}
_PACKAGE_BOOTSTRAP_IS_PACKAGE_AVAILABLE() {
	return 0
}
_F_00_MASK_BOOTSTRAP() {
	:
}
_F_00_MASK_INSTALL() {
	_gentoo_portage_install_file package.mask $1
}
_F_00_MASK_UNINSTALL() {
	_gentoo_portage_uninstall_file package.mask $1
}
_F_00_MASK_IS_INSTALLED() {
	_gentoo_portage_is_installed package.mask $1
}
_F_00_MASK_ENABLED() {
	return 0
}
_F_00_MASK_IS_FILE() {
	return 0
}
_F_00_PACKAGE_ACCEPT_KEYWORDS_BOOTSTRAP() {
	:
}
_F_00_PACKAGE_ACCEPT_KEYWORDS_INSTALL() {
	_gentoo_portage_install_file package.accept_keywords $1
}
_F_00_PACKAGE_ACCEPT_KEYWORDS_UNINSTALL() {
	_gentoo_portage_uninstall_file package.accept_keywords $1
}
_F_00_PACKAGE_ACCEPT_KEYWORDS_IS_INSTALLED() {
	_gentoo_portage_is_installed package.accept_keywords $1
}
_F_00_PACKAGE_ACCEPT_KEYWORDS_ENABLED() {
	return 0
}
_F_00_PACKAGE_ACCEPT_KEYWORDS_IS_FILE() {
	return 0
}
_F_00_PACKAGE_LICENSE_BOOTSTRAP() {
	:
}
_F_00_PACKAGE_LICENSE_INSTALL() {
	_gentoo_portage_install_file package.license $1
}
_F_00_PACKAGE_LICENSE_UNINSTALL() {
	_gentoo_portage_uninstall_file package.license $1
}
_F_00_PACKAGE_LICENSE_IS_INSTALLED() {
	_gentoo_portage_is_installed package.license $1
}
_F_00_PACKAGE_LICENSE_ENABLED() {
	return 0
}
_F_00_PACKAGE_LICENSE_IS_FILE() {
	return 0
}
_F_00_PACKAGE_USE_BOOTSTRAP() {
	:
}
_F_00_PACKAGE_USE_INSTALL() {
	_gentoo_portage_install_file package.use $1
}
_F_00_PACKAGE_USE_UNINSTALL() {
	_gentoo_portage_uninstall_file package.use $1
}
_F_00_PACKAGE_USE_IS_INSTALLED() {
	_gentoo_portage_is_installed package.use $1
}
_F_00_PACKAGE_USE_ENABLED() {
	return 0
}
_F_00_PACKAGE_USE_IS_FILE() {
	return 0
}
_F_00_USE_BOOTSTRAP() {
	:
}
_F_00_USE_INSTALL() {
	local name_suffix=$(_get_feature_name $1)
	printf '# app.%s%s\n' $_TARGET_APPLICATION_NAME "$name_suffix" | _sudo tee -a /etc/portage/make.conf >/dev/null 2>&1
	printf 'USE="$USE %s"\n' "$(cat $1)" | _sudo tee -a /etc/portage/make.conf >/dev/null 2>&1
}
_F_00_USE_UNINSTALL() {
	local name_suffix=$(_get_feature_name $1)
	_sudo $_CONF_GNU_SED -i "s/ app.$_TARGET_APPLICATION_NAME${name_suffix}/ /" /etc/portage/make.conf
}
_F_00_USE_IS_INSTALLED() {
	local name_suffix=$(_get_feature_name $1)
	grep -qm1 " # app.$_TARGET_APPLICATION_NAME${name_suffix}" /etc/portage/make.conf
}
_F_00_USE_ENABLED() {
	return 0
}
_F_00_USE_IS_FILE() {
	return 0
}
__APP_DEFAULT_BOOTSTRAP() {
	:
}
__APP_DEFAULT_INSTALL() {
	if [ -n $_USER ]; then
		_SUDO_USER="$USER" _sudo xdg-mime default $1.desktop $2
		return $?
	fi
	xdg-mime default $1.desktop $2
}
__APP_DEFAULT_UNINSTALL() {
	:
}
__APP_DEFAULT_IS_INSTALLED() {
	:
}
__APP_DEFAULT_ENABLED() {
	return 0
}
_NPM_BOOTSTRAP() {
	_NPM_BOOTSTRAP_IS_NPM_AVAILABLE || {
		_npm_setup_use_flags
		_PACKAGE_INSTALL $NPM_PACKAGE
		_NPM_BOOTSTRAP_IS_NPM_AVAILABLE || NPM_DISABLED=1
	}
	_NPM_SETUP_PROXY
}
_npm_setup_use_flags() {
	local use_flag_file=/tmp/install-gentoo-npm.use
	printf '%s npm\n' $NPM_PACKAGE >$use_flag_file
	_F_00_PACKAGE_USE_INSTALL $use_flag_file
	rm -f $use_flag_file
}
_USER_UNINSTALL() {
	. "$1"
	_require "$username" "username"
	_sudo userdel $username
}
_get_feature_name() {
	case $1 in
	*feature*)
		printf '%s' "$1" | sed \
			-e 's/^.*\/feature\///' \
			-e 's/.feature\/.*//' \
			-e 's/^/./' \
			-e 's/\//./g'
		;;
	*)
		printf ''
		;;
	esac
}
_gentoo_portage_install_file() {
	_sudo mkdir -p /etc/portage/$1
	_sudo cp $2 /etc/portage/$1/app.$_TARGET_APPLICATION_NAME$(_get_feature_name $2)
}
_gentoo_portage_uninstall_file() {
	_sudo rm -f /etc/portage/$1/app.$_TARGET_APPLICATION_NAME$(_get_feature_name $2)
}
_gentoo_portage_is_installed() {
	[ -e /etc/portage/$1/app.$_TARGET_APPLICATION_NAME$(_get_feature_name $2) ]
}
_require_file() {
	_require "$1" filename _require_file
	local level=_ERROR
	[ -n "$_WARN_ON_ERROR" ] && level=_WARN
	if [ ! -e $1 ]; then
		$level "File: $1 does not exist | $2"
		return 1
	fi
}
_readlink() {
	if [ $# -lt 1 ] || [ -z "$1" ]; then
		return 1
	fi
	if [ "$1" = "/" ]; then
		printf '%s\n' "$1"
		return
	fi
	if [ ! -e $1 ]; then
		if [ -z $_MKDIR ] || [ $_MKDIR -eq 1 ]; then
			_sudo mkdir -p $1 >/dev/null 2>&1
		fi
	fi
	readlink -f $1
}
_has_contents() {
	_require_file "$1" "_has_contents:$1"
	[ $(_sudo wc -l <$1) -gt 0 ] && return 0
	return 1
}
_write() {
	_sudo tee -a "$1" >/dev/null
}
_sed_safe() {
	printf '%s' $1 | sed -e "s/\//\\\\\//g"
}
_crontab_get() {
	_require "$1" "Crontab User"
	_require "$2" "Crontab Filename to write to"
	_CRONTAB_${_CONF_CRON_PROVIDER}_GET "$@"
}
_crontab_write() {
	_require "$1" "Crontab User"
	_require_file "$2" "Crontab File"
	_CRONTAB_${_CONF_CRON_PROVIDER}_WRITE "$@"
}
_crontab_append() {
	_require "$1" "Crontab User"
	_require_file "$2" "Crontab File"
	_has_contents $2 || return 1
	local current_crontab=$(_SUDO_USER=$1 _mktemp)
	_crontab_get $1 $current_crontab
	_sudo cat $2 | _sudo tee -a $current_crontab >/dev/null 2>&1
	_CRONTAB_${_CONF_CRON_PROVIDER}_WRITE $1 $current_crontab
	_sudo rm -f $current_crontab
}
_CRONTAB_DEFAULT_CLEAR() {
	_SUDO_USER=$1 _sudo crontab -f -r 2>/dev/null
}
_CRONTAB_DEFAULT_GET() {
	_SUDO_USER=$1 _sudo crontab -l >$2 2>/dev/null
}
_CRONTAB_DEFAULT_WRITE() {
	_crontab_default_header $1 $2
	_SUDO_USER=$1 _sudo crontab $2 || {
		_WARN "_ERROR writing crontab"
		_SUDO_USER=$1 _sudo cat $2
	}
}
_crontab_default_header() {
	if [ -n "$_OPTN_INSTALL_CRONTAB_HEADER" ]; then
		printf '%s\n\n' "$_OPTN_INSTALL_CRONTAB_HEADER" | _SUDO_USER=$1 _sudo tee -a $2.new >/dev/null 2>&1
		_SUDO_USER=$1 _sudo cat $2 | _SUDO_USER=$1 _sudo tee -a $2.new >/dev/null 2>&1
		_SUDO_USER=$1 _sudo mv $2.new $2
	fi
	_SUDO_USER=$1 _sudo cat $2 | _SUDO_USER=$1 _sudo tee -a $2.new >/dev/null 2>&1
	_SUDO_USER=$1 _sudo mv $2.new $2
}
_CRONTAB_DCRON_CLEAR() {
	case $1 in
	root)
		_SUDO_USER=$1 _sudo crontab /etc/crontab
		;;
	*)
		_SUDO_USER=$1 _sudo crontab -d
		;;
	esac
}
_CRONTAB_DCRON_GET() {
	_SUDO_USER=$1 _sudo crontab -l | _SUDO_USER=$1 _sudo tee $2 >/dev/null 2>&1
}
_CRONTAB_DCRON_WRITE() {
	_SUDO_USER=$1 _sudo crontab $2
}
_extract() {
	if [ $# -lt 2 ]; then
		_WARN "Expecting 2 arguments, source file, and target to extract to"
		return 1
	fi
	_INFO "### Extracting $1"
	local _extension=$(printf '%s' "$1" | $_CONF_GNU_GREP -Po "\\.(tar\\.gz|tar\\.bz2|tbz2|tgz|zip|tar\\.xz)$")
	local sudo
	[ -n "$_SUDO_REQUIRED" ] && sudo=_sudo
	[ -n "$_CLEAN" ] && {
		$sudo rm -rf $2
		$sudo mkdir -p $2
	}
	case $_extension in
	".tar.gz" | ".tgz" | ".tar.bz2" | ".tbz2" | ".tar.xz")
		$sudo tar xf $1 -C $2
		;;
	".zip")
		$sudo unzip -q $1 -d $2
		;;
	*)
		_WARN "extension unsupported - $_extension $1"
		return 2
		;;
	esac
}
_include logging platform context wait beep paths net install
: ${_CONF_LOG_HEADER:="##################################################"}
: ${_CONF_LOG_C_ALRT:="1;31m"}
: ${_CONF_LOG_C_ERR:="1;31m"}
: ${_CONF_LOG_C_SCS:="1;32m"}
: ${_CONF_LOG_C_WRN:="1;33m"}
: ${_CONF_LOG_C_INFO:="1;36m"}
: ${_CONF_LOG_C_DETAIL:="1;0;36m"}
: ${_CONF_LOG_C_DEBUG:="1;35m"}
: ${_CONF_LOG_C_STDIN:="1;34m"}
: ${_CONF_LOG_DATE_FORMAT:="%Y/%m/%d|%H:%M:%S"}
: ${_CONF_LOG_DATE_TIME_FORMAT:="%Y/%m/%d %H:%M:%S"}
: ${_CONF_LOG_LEVEL:=2}
: ${_CONF_LOG_INDENT:="  "}
: ${_CONF_LOG_CONF_VALIDATION_FUNCTION:=warn}
: ${_CONF_LOG_WAITER_LEVEL:=debug}
: ${_CONF_LOG_FEATURE_TIMEOUT_ERROR_LEVEL:=warn}
: ${_CONF_LOG_LONG_RUNNING_CMD:=30}
: ${_CONF_LOG_LONG_RUNNING_CMD_LINES:=1000}
[ -t 0 ] && INTERACTIVE=1
: ${_CONF_LOG_CONSOLE:=2}
: ${LIB:="beep.sh context.sh environment.sh exec.sh exit.sh help.sh include.sh logging.sh mktemp.sh platform.sh processes.sh stdin.sh syslog.sh sudo.sh time.sh wait.sh validation.sh net/mail.sh alert.sh"}
: ${CFG:="logging platform context wait beep paths net"}
: ${SUPPORTED_PLATFORMS:="Apple FreeBSD Linux Windows"}
which pgrep >/dev/null 2>&1 && _PARENT_PROCESSES_FUNCTION=_parent_processes_pgrep
_DETECTED_PLATFORM=$(uname)
case $_DETECTED_PLATFORM in
Darwin)
	_DETECTED_PLATFORM=Apple
	;;
MINGW64_NT-*)
	_DETECTED_PLATFORM=Windows
	;;
esac
_PLATFORM="Linux"
: ${_CONF_GNU_GREP:=grep}
: ${_CONF_GNU_SED:=sed}
_ARCHITECTURE=$(uname -m)
: ${_CONF_INSTALL_CONTEXT:=$_CONSOLE_CONTEXT_ID}
: ${_CONF_INSTALL_CONTEXT:=default}
: ${_CONF_WAIT_INTERVAL:=30}
: ${RSRC_BEEP:=/tmp/beep}
: ${_CONF_LOG_BEEP_TIMEOUT:=5}
: ${_CONF_LOG_BEEP_ERR:='-f 1000 -l 1000'}
: ${_CONF_LOG_BEEP_ALRT:='-f 1000 -l 100 -n -f 1000 -l 100'}
: ${_CONF_LOG_BEEP_SCS:='-f 1600 -l 100'}
: ${_CONF_LOG_BEEP_WRN:='-f 1500 -l 100 -n -f 1000'}
: ${_CONF_LOG_BEEP_INFO:=''}
: ${_CONF_LOG_BEEP_DETAIL:=''}
: ${_CONF_LOG_BEEP_DEBUG:=''}
: ${_CONF_LOG_BEEP_STDIN:='-f 1000 -l 100 -n -f 1400'}
: ${_CONF_LOG_SUDO_BEEP_TONE:='-f 1000 -l 100 -n -f 1400 -l 50 -n -f 1200'}
[ "$HOME" = "/" ] && HOME=/root
: ${_CONF_LIBRARY_PATH:=/usr/local/walterjwhite}
: ${_CONF_BIN_PATH:=/usr/local/bin}
_CONF_DATA_PATH=$HOME/.data
_CONF_CACHE_PATH=$HOME/.cache
_CONF_CONFIG_PATH=$HOME/.config/walterjwhite/shell
_CONF_RUN_PATH=/tmp/$USER/walterjwhite/app
_CONF_DATA_ARTIFACTS_PATH=$_CONF_DATA_PATH/install-v2/artifacts
_CONF_DATA_REGISTRY_PATH=$_CONF_DATA_PATH/install-v2/registry
_CONF_APPLICATION_DATA_PATH=$_CONF_DATA_PATH/$_APPLICATION_NAME
_CONF_APPLICATION_CONFIG_PATH=$_CONF_CONFIG_PATH/$_APPLICATION_NAME
_CONF_APPLICATION_LIBRARY_PATH=$_CONF_LIBRARY_PATH/$_APPLICATION_NAME
: ${_CONF_NETWORK_TEST_TIMEOUT:=5}
: ${_CONF_NETWORK_TEST_TARGETS:="http://connectivity-check.ubuntu.com http://example.org http://www.google.com http://telehack.com http://lxer.com"}
: ${_CONF_INSTALL_NO_PAGER:=0}
: ${_CONF_INSTALL_STEP_TIMEOUT:=300}
: ${_CONF_INSTALL_IOSTAT_DURATION:=5}
: ${_CONF_INSTALL_SUDO_TIMEOUT:=270}
: ${_CONF_INSTALL_NETWORK_TEST_TARGET:=google.com}
: ${_CONF_INSTALL_NETWORK_TEST_TIMEOUT:=5}
: ${_CONF_INSTALL_TEAMS_MESSAGE_PARALLELIZATION:=5}
: ${_CONF_INSTALL_PARALLEL_BUILD:=8}
: ${_CONF_APP_REGISTRY_GIT_URL:=https://github.com/walterjwhite/app.registry.git}
: ${_CONF_INSTALL_AUTO_UPDATE_PACKAGES:=0}
: ${_CONF_CLEAN_APP_REGISTRY_WORKSPACE:=1}
: ${_CONF_INSTALL_RANDOM_DEFAULT_LENGTH:=8}
[ "$_CONF_INSTALL_NO_PAGER" = "1" ] && PAGER=cat
: ${_OPTN_INSTALL_BYPASS_UNINSTALL:=1}
which shfmt >/dev/null 2>&1 || _DISABLE_SHFMT=1
: ${_CONF_INSTALL_CHECKSUM_CMD:="sha256 -q"}
: ${REMOVE_UNUSED_FUNCTIONS:=y}
: ${_INSTALL_BUILD_PLATFORMS:=$_DETECTED_PLATFORM}
_SUDO_CMD="sudo"
_PLATFORM_PACKAGES="app-eselect/eselect-repository app-portage/mirrorselect app-portage/cpuid2cpuflags sys-apps/pciutils sys-fs/dosfstools dev-vcs/git dev-tcltk/expect net-misc/curl dev-util/sh app-admin/sudo sys-apps/usbutils"
_PLATFORM_PACKAGES_ACCEPT_KEYWORDS="dev-util/sh ~amd64"
NPM_PACKAGE="net-libs/nodejs"
RUST_PACKAGE="dev-lang/rust"
PYPI_PACKAGE="dev-lang/python"
GO_PACKAGE="dev-lang/go"
EXPECT_PACKAGE="dev-tcltk/expect"
PORTAGE_REFRESH_PERIOD=3600
: ${_EMERGE_FLAGS:="-q --quiet-build --quiet-fail"}
[ -n "$_ROOT" ] && [ "$_ROOT" != "/" ] && _EMERGE_OPTIONS="--root=$_ROOT"
_CONF_INSTALL_STAT_ARGUMENTS='-c %a'
_include cron
: ${_CONF_CRON_PROVIDER:=DEFAULT}
_include install
_is_backgrounded && _BACKGROUNDED=1
_init_logging
unset _DEFERS _EXIT
_APPLICATION_START_TIME=$(date +%s)
_APPLICATION_CMD=$(basename $0)
trap _on_hup 1
trap _on_int 2
trap _on_quit 3
trap _on_illegal 4
trap _on_abort 6
trap _on_alarm 14
trap _on_term 15
trap _success 0
for _ARG in "$@"; do
	case $_ARG in
	-h | --help)
		_print_help_and_exit
		;;
	-w=*)
		_WAITER_PID="${1#*=}"
		shift
		;;
	-w)
		_WAITEE=1
		shift
		;;
	-conf-* | -[a-z0-9][a-z0-9][a-z0-9]*)
		_configuration_name=${_ARG#*-}
		_configuration_name=${_configuration_name%%=*}
		if [ $(printf '%s' "$_configuration_name" | grep -c '_') -eq 0 ]; then
			if [ $(printf '%s' "$_configuration_name" | grep -c '^conf') -gt 0 ]; then
				_configuration_name=$(printf '%s' "$_configuration_name" | sed -e "s/-/-$_APPLICATION_NAME-/" -e 's/--/-/')
			else
				_configuration_name=$(printf '%s' "$_configuration_name" | sed -e "s/^/$_APPLICATION_NAME-/" -e 's/--/-/')
			fi
		fi
		_configuration_name=$(printf '%s' $_configuration_name | tr '-' '_' | tr '[:lower:]' '[:upper:]')
		if [ $(printf '%s' "$_ARG" | grep -c '=') -eq 0 ]; then
			_configuration_value=1
		else
			_configuration_value=${_ARG#*=}
		fi
		export _$_configuration_name="$_configuration_value"
		unset _configuration_name
		shift
		;;
	*)
		break
		;;
	esac
done
if [ -z "$_CONTEXT_VALIDATED" ]; then
	_context_id_is_valid "$_CONF_INSTALL_CONTEXT"
	_CONTEXT_VALIDATED=0
fi
_APPLICATION_CONTEXT_GROUP=$_CONF_RUN_PATH/$_CONF_INSTALL_CONTEXT
_APPLICATION_CMD_DIR=$_APPLICATION_CONTEXT_GROUP/$_APPLICATION_NAME/$_APPLICATION_CMD
_waitee_init
_waiter
_is_supported_platform
[ -z "$_DEPENDENCY" ] && _restrict_to_single_process
_APP_INSTALLATION=0
_APP_INSTALL_SELF=$(readlink -f $0)
_APPLICATION_INSTALL_DATE=$(date)
[ -z "$_INSTALL_BIN_PATH" ] && _settings_init
_bootstrap_install
if [ $# -gt 0 ]; then
	_TARGET_APPLICATION_NAMES="$@"
elif [ -e .app ]; then
	_TARGET_APPLICATION_NAMES=$(basename $PWD)
else
	_ERROR "Specify application to install or cd to app dir"
fi
_INFO "Installing $_TARGET_APPLICATION_NAMES"
for _TARGET_APPLICATION_NAME in $_TARGET_APPLICATION_NAMES; do
	_setup_project $_TARGET_APPLICATION_NAME
done
if [ $_CONF_INSTALL_AUTO_UPDATE_PACKAGES -gt 0 ]; then
	_PACKAGE_UPDATE
fi
