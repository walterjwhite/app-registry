#!/bin/sh
set -a
_APPLICATION_NAME=install
_beep() {
	[ $# -eq 0 ] && return 1
	if [ -n "$_BEEPING" ]; then
		debug "Another 'beep' is in progress"
		return 2
	fi
	_BEEPING=1
	_do_beep "$@" &
}
_do_beep() {
	powershell "[console]::beep($1)"
	unset _BEEPING
}
_context_id_is_valid() {
	printf '%s' "$1" | $_CONF_GNU_GREP -Pq '^[a-zA-Z0-9_+-]+$' || error "Context ID *MUST* only contain alphanumeric characters and +-: '^[a-zA-Z0-9_+-]+$' | ($1)"
}
_environment_filter() {
	$_CONF_GNU_GREP -P "(^_CONF_|^_OPTN_|^_INSTALL_|^${_TARGET_APPLICATION_NAME}_)"
}
_environment_dump() {
	[ -z "$_APPLICATION_PIPE_DIR" ] && return
	[ -z "$_ENVIRONMENT_FILE" ] && _ENVIRONMENT_FILE=$_APPLICATION_PIPE_DIR/environment
	mkdir -p $(dirname $_ENVIRONMENT_FILE)
	env | _environment_filter | sort -u | grep -v '^$' | sed -e 's/=/="/' -e 's/$/"/' >>$_ENVIRONMENT_FILE
}
_call() {
	local _function_name=$1
	type $_function_name >/dev/null 2>&1 || {
		debug "${_function_name} does not exist"
		return 255
	}
	[ $# -gt 1 ] && {
		shift
		$_function_name "$@"
		return $?
	}
	$_function_name
}
_() {
	if [ -n "$_EXEC_ATTEMPTS" ]; then
		local attempt=1
		while [ $attempt -le $_EXEC_ATTEMPTS ]; do
			_WARN_ON_ERROR=1 _do_exec "$@" && return
			attempt=$(($attempt + 1))
		done
		error "Failed after $attempt attempts: $*"
	fi
	_do_exec "$@"
}
_do_exec() {
	local _successfulExitStatus=0
	if [ -n "$_SUCCESSFUL_EXIT_STATUS" ]; then
		_successfulExitStatus=$_SUCCESSFUL_EXIT_STATUS
		unset _SUCCESSFUL_EXIT_STATUS
	fi
	info "## $*"
	if [ -z "$_DRY_RUN" ]; then
		if [ -n "$_CMD_LOGFILE" ]; then
			_exec_to_file "$_CMD_LOGFILE" "$@"
		else
			if [ -z "$_LOGFILE" ]; then
				"$@"
			else
				_exec_to_file "$_LOGFILE" "$@"
			fi
		fi
		local _exit_status=$?
		if [ $_exit_status -ne $_successfulExitStatus ]; then
			if [ -n "$_ON_FAILURE" ]; then
				$_ON_FAILURE
				return
			fi
			if [ -z "$_WARN_ON_ERROR" ]; then
				error "Previous cmd failed: $* - $_exit_status"
			else
				unset _WARN_ON_ERROR
				warn "Previous cmd failed: $* - $_exit_status"
				_ENVIRONMENT_FILE=$(_mktemp error) _environment_dump
				return $_exit_status
			fi
		fi
	fi
}
_exec_to_file() {
	local logfile=$1
	shift
	mkdir -p $(dirname $logfile)
	type $_function_name >/dev/null 2>&1 || {
		"$@" >>$logfile 2>>$logfile
		return $?
	}
	"$@"
}
error() {
	if [ $# -ge 2 ]; then
		_EXIT_STATUS=$2
	else
		_EXIT_STATUS=1
	fi
	_EXIT_LOG_LEVEL=4
	_EXIT_STATUS_CODE="ERR"
	_EXIT_COLOR_CODE="$_CONF_LOG_C_ERR"
	_EXIT_MESSAGE="$1 ($_EXIT_STATUS)"
	_EXIT_BEEP=$_CONF_LOG_BEEP_ERR
	_defer _environment_dump
	_defer _log_app_exit
	exit $_EXIT_STATUS
}
_success() {
	_EXIT_STATUS=0
	_EXIT_LOG_LEVEL=1
	_EXIT_STATUS_CODE="SCS"
	_EXIT_COLOR_CODE="$_CONF_LOG_C_SCS"
	_EXIT_MESSAGE="$1"
	_EXIT_BEEP=$_CONF_LOG_BEEP_SCS
	_defer _long_running_cmd
	_defer _log_app_exit
	[ -z "$_EXIT" ] && exit 0
}
_on_exit() {
	[ $_EXIT ] && return 1
	_EXIT=0
	[ -z "$_EXIT_STATUS" ] && _success "completed successfully"
	if [ -n "$_DEFERS" ]; then
		local defer
		for defer in $_DEFERS; do
			_call $defer
		done
		unset _DEFERS
	fi
	return $_EXIT
}
_defer() {
	if [ -n "$_DEFERS" ]; then
		local defer
		for defer in $_DEFERS; do
			[ "$defer" = "$1" ] && {
				debug "not deferring: $1 as it was already deferred"
				return
			}
		done
	fi
	debug "deferring: $1"
	_DEFERS="$1 $_DEFERS"
}
_log_app_exit() {
	[ "$_EXIT_MESSAGE" ] && {
		local current_time=$(date +%s)
		local timeout=$(($_APPLICATION_START_TIME + $_CONF_LOG_BEEP_TIMEOUT))
		[ $current_time -le $timeout ] && unset _EXIT_BEEP
		_print_log $_EXIT_LOG_LEVEL "$_EXIT_STATUS_CODE" "$_EXIT_COLOR_CODE" "$_EXIT_BEEP" "$_EXIT_MESSAGE"
	}
	_log_app exit
	[ -n "$_LOGFILE" ] && [ -n "$_OPTN_LOG_EXIT_CMD" ] && {
		$_OPTN_LOG_EXIT_CMD -file $_LOGFILE
	}
}
_print_help() {
	if [ -e $2 ]; then
		info "$1:"
		cat $2
		printf '\n'
	fi
}
_print_help_and_exit() {
	_print_help 'system-wide options' $_CONF_LIBRARY_PATH/install/help/default
	if [ "$_APPLICATION_NAME" != "install" ]; then
		_print_help $_APPLICATION_NAME $_CONF_LIBRARY_PATH/$_APPLICATION_NAME/help/default
		_print_help "$_APPLICATION_NAME/$_APPLICATION_CMD" $_CONF_LIBRARY_PATH/$_APPLICATION_NAME/help/$_APPLICATION_CMD
	fi
	exit 0
}
_include() {
	local include_file
	for include_file in "$@"; do
		[ -f $HOME/.config/walterjwhite/$include_file ] && . $HOME/.config/walterjwhite/$include_file
	done
}
_init_logging() {
	[ -n "$_LOGFILE" ] && _set_logfile "$_LOGFILE"
	case $_CONF_LOG_LEVEL in
	0)
		local logfile=$(_mktemp debug)
		warn "Writing debug contents to: $logfile"
		_set_logfile "$logfile"
		set -x
		;;
	esac
}
_set_logfile() {
	[ -z "$1" ] && return 1
	_LOGFILE=$1
	mkdir -p $(dirname $1)
	_reset_indent
	[ -n "$_CHILD_LOG" ] || exec 3>&1 4>&2
	exec >>$_LOGFILE 2>&1
	[ -z "$_PRESERVE_LOG" ] && [ -z "$_CHILD_LOG" ] && truncate -s 0 $1 >/dev/null 2>&1
}
warn() {
	_print_log 3 WRN "$_CONF_LOG_C_WRN" "$_CONF_LOG_BEEP_WRN" "$1"
}
info() {
	_print_log 2 INF "$_CONF_LOG_C_INFO" "$_CONF_LOG_BEEP_INFO" "$1"
}
detail() {
	_print_log 2 DTL "$_CONF_LOG_C_DETAIL" "$_CONF_LOG_BEEP_DETAIL" "$1"
}
debug() {
	_print_log 1 DBG "$_CONF_LOG_C_DEBUG" "$_CONF_LOG_BEEP_DEBUG" "($$) $1"
}
_log() {
	:
}
_sed_remove_nonprintable_characters() {
	sed -e 's/[^[:print:]]//g'
}
_print_log() {
	if [ -z "$5" ]; then
		if test ! -t 0; then
			local _line
			cat - | _sed_remove_nonprintable_characters |
				while read _line; do
					_print_log $1 $2 $3 $4 "$_line"
				done
			return
		fi
		return
	fi
	local message="$5"
	[ $1 -lt $_CONF_LOG_LEVEL ] && return
	[ -n "$_LOGGING_CONTEXT" ] && message="$_LOGGING_CONTEXT - $message"
	local _message_date_time=$(date +"$_CONF_LOG_DATE_FORMAT")
	if [ $_BACKGROUNDED ] && [ $_OPTN_INSTALL_BACKGROUND_NOTIFICATION_METHOD ]; then
		$_OPTN_INSTALL_BACKGROUND_NOTIFICATION_METHOD "$2" "$_message" &
	fi
	[ -n "$4" ] && _beep "$4"
	_log_to_file "$2" "$_message_date_time" "${_LOG_INDENT}$message"
	_log_to_console "$3" "$2" "$_message_date_time" "${_LOG_INDENT}$message"
	[ -z "$INTERACTIVE" ] && _syslog "$message"
	return 0
}
_increase_indent() {
	_LOG_INDENT="$_LOG_INDENT${_CONF_LOG_INDENT}"
}
_reset_indent() {
	unset _LOG_INDENT
}
_log_to_file() {
	[ -z "$_LOGFILE" ] && return
	if [ $_CONF_LOG_AUDIT -gt 0 ]; then
		printf '%s %s %s\n' "$1" "$2" "$3" >>$_LOGFILE
		return
	fi
	printf '%s\n' "$3" >>$_LOGFILE
}
_log_to_console() {
	local stderr=2
	[ ! -t $stderr ] && stderr=4
	[ ! -t $stderr ] && return
	if [ $_CONF_LOG_AUDIT -gt 0 ]; then
		printf >&$stderr '\033[%s%s \033[0m%s %s\n' "$1" "$2" "$3" "$4"
		return
	fi
	printf >&$stderr '\033[%s%s \033[0m\n' "$1" "$4"
}
_log_app() {
	debug "$_APPLICATION_NAME:$_APPLICATION_CMD - $1 ($$)"
}
_mktemp() {
	local suffix=$1
	[ -n "$suffix" ] && suffix=".$suffix"
	mktemp -${_MKTEMP_OPTIONS}t ${_APPLICATION_NAME}.${_APPLICATION_CMD}${suffix}.XXXXXXXX
}
_setup_app_pipe() {
	_APPLICATION_PIPE=$_APPLICATION_CMD_DIR/$$
	_APPLICATION_PIPE_DIR=$(dirname $_APPLICATION_PIPE)
	mkdir -p $_APPLICATION_PIPE_DIR
	mkfifo $_APPLICATION_PIPE
	_defer _cleanup_app_pipe
}
_cleanup_app_pipe() {
	rm -f $_APPLICATION_PIPE
}
_kill_all() {
	_do_kill_all $_APPLICATION_PIPE_DIR
}
_kill_all_group() {
	_do_kill_all $_APPLICATION_CONTEXT_GROUP
}
_do_kill_all() {
	for _EXISTING_APPLICATION_PIPE in $(find $1 -type p -not -name $$); do
		_kill $(basename $_EXISTING_APPLICATION_PIPE)
	done
}
_kill() {
	warn "Killing $1"
	kill -TERM $1
}
_list() {
	_list_pidinfos $_APPLICATION_PIPE_DIR
}
_list_group() {
	_list_pidinfos $_APPLICATION_CONTEXT_GROUP
}
_list_pidinfos() {
	info "Running processes:"
	_EXECUTABLE_NAME_SED_SAFE=$(_sed_safe $0)
	for _EXISTING_APPLICATION_PIPE in $(find $1 -type p -not -name $$); do
		_list_pidinfo
	done
}
_parent_processes_pgrep() {
	pgrep -P $1
}
_is_backgrounded() {
	return 1
}
_list_pidinfo() {
	_TARGET_PID=$(basename $_EXISTING_APPLICATION_PIPE)
	_TARGET_PS_DTL=$(ps -p $_TARGET_PID | sed 1d | awk {'print$8'} | sed -e "s/^.*$_EXECUTABLE_NAME_SED_SAFE/$_EXECUTABLE_NAME_SED_SAFE/")
	info " $_TARGET_PID - $_TARGET_PS_DTL"
}
_syslog() {
	:
}
_waitee_init() {
	[ -z "$_WAITEE" ] && return
	_setup_app_pipe
	warn "($_APPLICATION_CMD) Please use -w=$$"
	_defer _waitee_done
}
_waitee_done() {
	if [ -n "$_WAITEE" ] && [ -e $_APPLICATION_PIPE ]; then
		info "$0 process completed, notifying ($_EXIT_STATUS)"
		printf '%s\n' "$_EXIT_STATUS" >$_APPLICATION_PIPE
		info "$0 downstream process picked up"
	fi
}
_waiter() {
	[ -z "$_WAITER_PID" ] && return
	_UPSTREAM_APPLICATION_PIPE=$(find $_APPLICATION_CONTEXT_GROUP -type p -name $_WAITER_PID 2>/dev/null | head -1)
	[ -z "$_UPSTREAM_APPLICATION_PIPE" ] && error "$_WAITER_PID not found"
	[ ! -e $_UPSTREAM_APPLICATION_PIPE ] && {
		warn "$_UPSTREAM_APPLICATION_PIPE does not exist, did upstream start?"
		return
	}
	info "Waiting for upstream to complete: $_WAITER_PID"
	while [ 1 ]; do
		if [ ! -e $_UPSTREAM_APPLICATION_PIPE ]; then
			error "Upstream pipe no longer exists"
		fi
		_UPSTREAM_APPLICATION_STATUS=$(_timeout $_CONF_WAIT_INTERVAL "_waiter:upstream" cat $_UPSTREAM_APPLICATION_PIPE 2>/dev/null)
		local _UPSTREAM_STATUS=$?
		if [ $_UPSTREAM_STATUS -eq 0 ]; then
			if [ -z "$_UPSTREAM_APPLICATION_STATUS" ] || [ $_UPSTREAM_APPLICATION_STATUS -gt 0 ]; then
				error "Upstream exited with error ($_UPSTREAM_APPLICATION_STATUS)"
			fi
			warn "Upstream finished: $_UPSTREAM_APPLICATION_PIPE ($_UPSTREAM_STATUS)"
			break
		fi
		detail " Upstream is still running: $_UPSTREAM_APPLICATION_PIPE ($_UPSTREAM_STATUS)"
		sleep 1
	done
}
_require() {
	local level=error
	if [ -z "$1" ]; then
		[ -n "$_WARN" ] && level=warn
		$level "$2 required $_REQUIRE_DETAILED_MESSAGE" $3
		return 1
	fi
	unset _REQUIRE_DETAILED_MESSAGE
}
_mail() {
	if [ $# -lt 3 ]; then
		warn "recipients[0], subject[1], message[2] is required - $# arguments provided"
		return 1
	fi
	local recipients=$(printf '%s' "$1" | tr '|' ' ')
	shift
	local subject="$1"
	shift
	local message="$1"
	shift
	printf "$message" | mail -s "$subject" $recipients
}
_alert() {
	_print_log 5 ALRT "$_CONF_LOG_C_ALRT" "$_CONF_LOG_BEEP_ALRT" "$1"
	local recipients="$_OPTN_LOG_ALERT_RECIPIENTS"
	local subject="Alert: $0 - $1"
	if [ -z "$recipients" ]; then
		warn "recipients is empty, aborting"
		return 1
	fi
	_mail "$recipients" "$subject" "$2"
}
_long_running_cmd() {
	[ -n "$_OPTN_DISABLE_LONG_RUNNING_CMD_NOTIFICATION" ] && return
	_APPLICATION_END_TIME=$(date +%s)
	_APPLICATION_RUNTIME=$(($_APPLICATION_END_TIME - $_APPLICATION_START_TIME))
	[ $_APPLICATION_RUNTIME -lt $_CONF_LOG_LONG_RUNNING_CMD ] && return
	local subject="[$_APPLICATION_NAME] - $_EXIT_MESSAGE - ($_EXIT_STATUS)"
	local message=""
	if [ -n "$_LOGFILE" ]; then
		message=$(tail -$_CONF_LOG_LONG_RUNNING_CMD_LINES $_LOGFILE)
	fi
	_alert "$subject" "$message"
}
_do_clone() {
	if [ -n "$1" ] && [ -e $1 ]; then
		if [ -z "$clean_workspace" ] || [ $clean_workspace -eq 0 ]; then
			local opwd=$PWD
			cd $1
			git pull || error "Unable to update : $1"
			cd $opwd
			return
		fi
		cd
		rm -rf $1
	fi
	if [ -n "$project_name" ]; then
		git clone $project_name $1 >/dev/null 2>&1 && return
	fi
	local repository_url
	for repository_url in $git_mirrors; do
		local project_url=$repository_url
		if [ -n "$project_name" ]; then
			project_url=$project_url/$project_name
		fi
		git clone $project_url $1 >/dev/null 2>&1 && {
			detail "Using $project_url -> $1"
			return
		}
	done
	return 1
}
_app_build() {
	_PROJECT_ROOT=$(git rev-parse --show-toplevel)
	if [ ! -e .app ]; then
		_app_build_recursive
		return
	fi
	_app_build_instance
}
_app_build_recursive() {
	local app
	for app in $(find . -maxdepth 2 -type f -name .app | sed -e 's/\.app$//' | sort -u); do
		cd $app
		_app_build_instance
		cd ..
	done
}
_app_build_instance() {
	_TARGET_APPLICATION_NAME=$(basename $PWD)
	info "Building $_TARGET_APPLICATION_NAME"
	SED_SAFE_PWD=$(_sed_safe $PWD)
	rm -rf $_CONF_DATA_ARTIFACTS_PATH/$_TARGET_APPLICATION_NAME && mkdir -p $_CONF_DATA_ARTIFACTS_PATH/$_TARGET_APPLICATION_NAME
	date >>$_CONF_DATA_ARTIFACTS_PATH/$_TARGET_APPLICATION_NAME/.build-date
	_app_build_platforms
}
_app_build_platforms() {
	local build_platforms="$BUILD_PLATFORMS"
	[ -e supported-platforms ] && {
		build_platforms=$(cat supported-platforms)
	}
	for _TARGET_PLATFORM in $build_platforms; do
		_app_build_platform_name
		printf '\n'
		info "Building for $_TARGET_PLATFORM"
		_increase_indent
		_app_build_package_files
		_reset_indent
	done
}
_app_build_platform_name() {
	case $_TARGET_PLATFORM in
	*/*)
		_TARGET_SUB_PLATFORM=${_TARGET_PLATFORM#*/}
		_TARGET_PLATFORM=${_TARGET_PLATFORM%%/*}
		;;
	*) ;;
	esac
}
_app_build_package_files() {
	for f in $(_app_build_find_files); do
		_app_build_package_file $f
	done
}
_app_build_find_files() {
	find ./bin ./cfg ./files ./help ./post-setup ./setup ./feature -type f -and \( ! -path '*.secret/*' ! -path '*.secret' ! -path '*.archived/*' ! -path '*.archived' \) -and \( \
		\( -path '*/bin/all/*' -or -path "*/cfg/all*" -or -path '*/files/all/*' -or -path '*/help/all/*' -or -path "*/post-setup/all/*" -or -path '*/setup/all/*' \) -or \
		\( -path "*/bin/$_TARGET_PLATFORM/*" -or -path "*/cfg/$_TARGET_PLATFORM/*" -or -path "*/files/$_TARGET_PLATFORM/*" -or -path "*/help/$_TARGET_PLATFORM/*" -or -path "*/post-setup/$_TARGET_PLATFORM/*" -or -path "*/setup/$_TARGET_PLATFORM/*" \) \) 2>/dev/null |
		sort -r
}
_app_build_package_file() {
	detail "$1"
	_app_build_package_file_supports_platform $1 || {
		warn "Not building $1 as it does not support $_TARGET_PLATFORM"
		return 1
	}
	file_relative=$(printf '%s\n' "$1" | sed -e "s/\/$_TARGET_PLATFORM\//\//" -e 's/\/all\//\//' -e 's/.none$//' -e 's/.lite$//')
	APP_BUILD_OUTPUT_FILE=$_CONF_DATA_ARTIFACTS_PATH/$_TARGET_APPLICATION_NAME/$_TARGET_PLATFORM/$file_relative
	mkdir -p $(dirname $APP_BUILD_OUTPUT_FILE)
	case $1 in
	*run | */bin/*)
		_app_build_profile $1
		;;
	*/files/*.sh)
		APP_BUILD_PROFILE=lite
		;;
	*)
		APP_BUILD_PROFILE=none
		;;
	esac
	inject_$APP_BUILD_PROFILE $1
	_build_has_invalid_function_name
	[ -n "$REMOVE_UNUSED_FUNCTIONS" ] && {
		_remove_unused_functions
		_remove_unused_defaults
	}
	_update_remove_commented_code $APP_BUILD_OUTPUT_FILE
	_update_constants $APP_BUILD_OUTPUT_FILE
	_app_build_correct_permissions $1
	debug "Built $1 -> [$_TARGET_PLATFORM] [$_PLATFORM]"
}
_app_build_package_file_supports_platform() {
	case "$1" in
	*/feature/*.feature/*) ;;
	*)
		return 0
		;;
	esac
	_app_build_check_supported_platforms $(dirname "$1" | $_CONF_GNU_GREP -Po '.*feature/.*\.feature')
}
_app_build_check_supported_platforms() {
	local feature_dir="$1"
	while [ -n "$feature_dir" ]; do
		_app_build_check_platform_support "$feature_dir"
		case $? in
		0)
			return 0
			;;
		1)
			return 1
			;;
		esac
		feature_dir=$(dirname "$feature_dir" | $_CONF_GNU_GREP -Po '.*feature/.*\.feature')
	done
	printf '%s\n' $SUPPORTED_PLATFORMS | $_CONF_GNU_GREP -cqm1 "$_TARGET_PLATFORM"
}
_app_build_check_platform_support() {
	[ ! -e "$1/supported-platforms" ] && return 2
	grep -cqm1 "$_TARGET_PLATFORM" "$1/supported-platforms" 2>/dev/null
}
_app_build_correct_permissions() {
	local permissions=$(stat $_CONF_INSTALL_STAT_ARGUMENTS $1)
	chmod $permissions $APP_BUILD_OUTPUT_FILE $1
}
_app_build_profile() {
	APP_BUILD_PROFILE=$(basename $1 | sed -e 's/^.*\.//')
	case $APP_BUILD_PROFILE in
	full | lite | none) ;;
	*)
		debug "Unknown Profile: $APP_BUILD_PROFILE, defaulting to full"
		APP_BUILD_PROFILE=full
		;;
	esac
	debug "Profile: $APP_BUILD_PROFILE"
}
_build_format_shell_scripts() {
	[ -n "$_DISABLE_SHFMT" ] && return 1
	_is_shell_script $APP_BUILD_OUTPUT_FILE && shfmt -w $APP_BUILD_OUTPUT_FILE
}
_build_has_invalid_function_name() {
	local invalid_functions=$($_CONF_GNU_GREP -Ph '^_[a-z0-9_]{3,}\(\) {$' $APP_BUILD_OUTPUT_FILE |
		sed -e 's/().*//' -e 's/ //g' | sort -u | $_CONF_GNU_GREP -P '\$')
	[ -n "$invalid_functions" ] && {
		error "$APP_BUILD_OUTPUT_FILE has invalid function names: $invalid_functions"
	}
}
_setup_git_import() {
	local import_git_arg="${1#*git:}"
	GIT_IMPORT_PROJECT="${import_git_arg%%/*}"
	GIT_IMPORT_TARGET_FILE="${import_git_arg#*/}"
	GIT_IMPORT_PATH=$_CONF_DATA_PATH/install/imports/$GIT_IMPORT_PROJECT
	if [ ! -e $GIT_IMPORT_PATH ]; then
		git_mirrors=$_CONF_INSTALL_MIRROR_URLS project_name=$GIT_IMPORT_PROJECT _do_clone $GIT_IMPORT_PATH || error "Unable to clone git repository:$GIT_IMPORT_PROJECT -> $GIT_IMPORT_PATH"
	else
		_setup_git_import_update $GIT_IMPORT_PATH
	fi
}
_setup_git_import_update() {
	_git_import_already_updated $1 && return 1
	debug "Updating import: $PWD"
	local opwd=$PWD
	cd $1
	git pull >/dev/null
	cd $opwd
	_GIT_IMPORTS="$_GIT_IMPORTS $1"
}
_git_import_already_updated() {
	local git_import
	for git_import in $_GIT_IMPORTS; do
		[ "$git_import" == "$1" ] && return 0
	done
	return 1
}
_imports_import() {
	_imports_get $1 $2
	_imports $1 $APP_BUILD_OUTPUT_FILE
}
_imports_get() {
	_RAW_IMPORTS=$($_CONF_GNU_GREP -P "^$1 " "$2" | sed -e "s/$1 //" | sort -u)
}
_imports() {
	[ -z "$_RAW_IMPORTS" ] && return 1
	_call $before_function
	local raw_import
	for raw_import in $_RAW_IMPORTS; do
		_import "$1" "$2" "$3$raw_import"
	done
	_imports_get $1 $2
	$_CONF_GNU_SED -i "/^$1 .*/d" $2
	_imports "$@"
}
_import() {
	local import_type=$1
	shift
	local import_ref="$2"
	case $import_ref in
	git:*)
		_setup_git_import "$import_ref"
		case $GIT_IMPORT_TARGET_FILE in
		*.feature/*)
			local feature_patha=$(printf '%s\n' $GIT_IMPORT_TARGET_FILE | $_CONF_GNU_GREP -Po '^feature/.*\.feature')
			local feature_pathb=$(printf '%s\n' $GIT_IMPORT_TARGET_FILE | sed -e 's/^.*\.feature//')
			import_type=$import_type git_import_path=$GIT_IMPORT_PROJECT _import_file_contents $1 $GIT_IMPORT_PATH/$feature_patha/$import_type/%s/$feature_pathb
			;;
		*)
			import_type=$import_type git_import_path=$GIT_IMPORT_PROJECT _import_file_contents $1 $GIT_IMPORT_PATH/$import_type/%s/$GIT_IMPORT_TARGET_FILE
			;;
		esac
		;;
	feature:*)
		local feature_path=$(printf '%s' $1 | $_CONF_GNU_GREP -Po 'feature.*\.feature')
		local feature_arg="${import_ref#*feature:}"
		_import_file_contents $1 $feature_path/$import_type/%s/$feature_arg
		;;
	*.feature/*)
		local feature_patha=$(printf '%s\n' $import_ref | $_CONF_GNU_GREP -Po '^feature/.*\.feature')
		local feature_pathb=$(printf '%s\n' $import_ref | sed -e 's/^.*\.feature//')
		_import_file_contents $1 $feature_patha/$import_type/%s/$feature_pathb
		;;
	.*)
		_import_file_contents $1 $import_type/%s/$import_ref
		;;
	*)
		_import_file_contents $1 $_PROJECT_ROOT/$import_type/%s/$import_ref
		;;
	esac
}
_import_file_contents() {
	local file=$1
	shift
	local platform_path=$(printf "$1" $_TARGET_PLATFORM)
	local all_path=$(printf "$1" all)
	_require_file "$file" "_import_file_contents"
	_import_has_matching_files $platform_path $all_path
	local file_to_import
	for file_to_import in $(find $platform_path $all_path \( -type f -or -type l \) -and ! -name '*.test' 2>/dev/null | sort -u); do
		printf '%s\n' "$IMPORTED" | $_CONF_GNU_GREP -Pcqm1 $file_to_import && {
			debug "$file_to_import was already imported"
			continue
		}
		IMPORTED="$file_to_import\n$IMPORTED"
		if [ -e ${file_to_import}.test ]; then
			${file_to_import}.test $APP_BUILD_OUTPUT_FILE
			if [ "$?" -eq "0" ]; then
				cat $file_to_import >>$file
			else
				debug "$file_to_import failed test"
			fi
		else
			cat $file_to_import >>$file
		fi
	done
}
_import_has_matching_files() {
	[ -n "$_OPTIONAL" ] && return
	find $1 $2 -type f -or -type l 2>/dev/null | grep -q . || error "_import_file_contents - no matching files found: $1 $2"
}
_import_filter_imports() {
	[ -z "$import_type" ] || [ -z "$git_import_path" ] && {
		cat -
		return
	}
	sed "/git:/! s/^$import_type /$import_type git:$git_import_path\//"
}
_inject_header() {
	printf '#!/bin/sh\n\n' >$APP_BUILD_OUTPUT_FILE
	printf 'set -a\n' >>$APP_BUILD_OUTPUT_FILE
	printf '_APPLICATION_NAME=%s\n' $_TARGET_APPLICATION_NAME >>$APP_BUILD_OUTPUT_FILE
}
inject_full() {
	_inject_header
	_required_arguments $1
	_inject_lib $1
	_inject_cfg $1
	_required_cfg
	_inject_init $1
	chmod +x $APP_BUILD_OUTPUT_FILE $1
	_build_format_shell_scripts
	$_CONF_GNU_GREP -Pvh '^(#|lib |cfg |init |_REQUIRED_ARGUMENTS)' $1 >>$APP_BUILD_OUTPUT_FILE
}
_inject_lib() {
	_RAW_IMPORTS="$LIB" _imports lib $APP_BUILD_OUTPUT_FILE
	_imports_import lib $1
	unset IMPORTED
}
_inject_cfg() {
	_OPTIONAL=1 _RAW_IMPORTS="$CFG . $_TARGET_APPLICATION_NAME" before_function=_inject_cfg_before _imports cfg $APP_BUILD_OUTPUT_FILE
	before_function=_inject_cfg_before _imports_import cfg $1
	unset IMPORTED
}
_inject_cfg_before() {
	local imports=$(printf '%s\n' "$_RAW_IMPORTS" | tr -d '.' | sort -u)
	printf '_include %s %s\n' "$imports" >>$APP_BUILD_OUTPUT_FILE
}
_inject_init() {
	_OPTIONAL=1 _import init $APP_BUILD_OUTPUT_FILE platform
	_import init $APP_BUILD_OUTPUT_FILE full
	_imports_import init $1
	unset IMPORTED
}
inject_lite() {
	$_CONF_GNU_GREP -Pcq '^(init |_REQUIRED_ARGUMENTS )' $1 && error "Files may not contain init or _REQUIRED_ARGUMENTS"
	_inject_header
	_inject_lib $1
	_inject_cfg $1
	_build_format_shell_scripts
	$_CONF_GNU_GREP -Pvh '^(#|lib |cfg |init |_REQUIRED_ARGUMENTS)' $1 >>$APP_BUILD_OUTPUT_FILE
}
inject_none() {
	cp $1 $APP_BUILD_OUTPUT_FILE
}
_required_arguments() {
	_REQUIRED_ARGUMENTS=$($_CONF_GNU_GREP -P "^_REQUIRED_ARGUMENTS=" "$1")
	[ -z "$_REQUIRED_ARGUMENTS" ] && return 1
	printf '%s\n' "$_REQUIRED_ARGUMENTS" >>$APP_BUILD_OUTPUT_FILE
}
_required_cfg() {
	local required_cfg=$($_CONF_GNU_GREP -Pvh '#.*$' $APP_BUILD_OUTPUT_FILE |
		$_CONF_GNU_GREP -Poh '\$_CONF_[\w_]{3,}' | sed -e 's/^\$//' | sort -u)
	local defaults=$($_CONF_GNU_GREP -Poh '_CONF_[\w_]{3,}:?=' $APP_BUILD_OUTPUT_FILE | sed -e 's/^\$//' -e 's/:=$//' -e 's/=$//' | sort -u | tr '\n' '|' | sed -e 's/|$//' -e 's/^/(/' -e 's/$/)/')
	local missing_required_cfg=$(printf '%s\n' "$required_cfg" | $_CONF_GNU_GREP -Pv "$defaults" | tr '\n' ' ' | sed -e 's/ $//')
	[ -n "$missing_required_cfg" ] && printf '_REQUIRED_APP_CONF="%s"\n' "$missing_required_cfg" >>$APP_BUILD_OUTPUT_FILE
}
_unused_defaults() {
	local used_defaults=$(_used_defaults $APP_BUILD_OUTPUT_FILE | tr '\n' '|' | sed -e 's/^/(/' -e 's/|$//' -e 's/$/)/')
	_list_defaults $APP_BUILD_OUTPUT_FILE | $_CONF_GNU_GREP -Pv "^${used_defaults}$"
}
_list_defaults() {
	$_CONF_GNU_GREP -Ph '^: \${_CONF_[\w_]+:=.*' $1 | $_CONF_GNU_GREP -Po '_CONF_[\w_]+' | sort -u
}
_used_defaults() {
	$_CONF_GNU_GREP -Ph '(\${|\$)_CONF_[\w_]+' $1 | $_CONF_GNU_GREP -Po '_CONF_[\w_]+' | sort -u
}
_remove_unused_defaults() {
	local i=0
	while [ 1 ]; do
		local unused_defaults=$(_unused_defaults)
		[ -z "$unused_defaults" ] && break
		debug "remove cfg:$i:$unused_defaults"
		local unused_default
		for unused_default in $unused_defaults; do
			_remove_unused_default $unused_default $APP_BUILD_OUTPUT_FILE
		done
		i=$(($i + 1))
	done
}
_remove_unused_default() {
	debug "Unused default: $1"
	$_CONF_GNU_SED -i "/^: \${$1:=.*}$/d" $2
}
_unused_functions() {
	local called_functions=$(_called_functions | tr '\n' '|' | sed -e 's/^/(/' -e 's/|$//' -e 's/$/)/')
	_list_functions | $_CONF_GNU_GREP -Pv "^${called_functions}$"
}
_list_functions() {
	$_CONF_GNU_GREP -Ph '^_[a-z0-9_]{3,}\(\) {$' $APP_BUILD_OUTPUT_FILE | sed -e 's/().*//' -e 's/ //g' | sort -u
}
_called_functions() {
	$_CONF_GNU_GREP -Pho '_[a-z0-9_]{3,}( |$|\))' $APP_BUILD_OUTPUT_FILE | sed -e 's/ $//' -e 's/)//' | tr ' ' '\n' | sort -u
}
_invalid_functions() {
	sed -e 's/^[ \t]*//' $APP_BUILD_OUTPUT_FILE | $_CONF_GNU_GREP -Pv '(^#)' |
		$_CONF_GNU_GREP -P '(^| |_call )_[a-z0-9_\$\{\}]{3,}' | sed -e 's/_call //' | $_CONF_GNU_GREP -P '^_\$'
}
_build_has_invalid_function_name() {
	local invalid_functions=$(_invalid_functions)
	[ -n "$invalid_functions" ] && {
		error "$APP_BUILD_OUTPUT_FILE has invalid function names: $invalid_functions"
	}
}
_remove_unused_functions() {
	local i=0
	while [ 1 ]; do
		local unused_functions=$(_unused_functions)
		[ -z "$unused_functions" ] && break
		debug "remove function:$i:$unused_functions"
		local unused_function
		for unused_function in $unused_functions; do
			_remove_unused_function $unused_function $APP_BUILD_OUTPUT_FILE
		done
		i=$(($i + 1))
	done
}
_remove_unused_function() {
	local function_start=$(_function_start $1 $2)
	local function_end=$(_function_end $2 $function_start)
	_WARN=1 _require "$function_start" function_start || return 1
	_WARN=1 _require "$function_end" function_end || return 1
	$_CONF_GNU_SED -i "$function_start,$function_end d" $2
}
_function_start() {
	$_CONF_GNU_GREP -Pnh "^$1\(\) {$" $2 | head -1 | cut -f1 -d:
}
_function_end() {
	local line_number
	for line_number in $($_CONF_GNU_GREP -Pnh '^}$' $1 | cut -f1 -d:); do
		[ $line_number -gt $2 ] && {
			printf '%s\n' $line_number
			return
		}
	done
	error "Unable to find end of function: $1 | $2"
}
_update_remove_commented_code() {
	$_CONF_GNU_SED -i '/^[[:space:]]*#[^!]*$/d' $1
	$_CONF_GNU_SED -i '/^[[:space:]]*$/d' $1
}
_update_constants() {
	case $1 in
	*/artifacts/install/*)
		debug "Bypassing update"
		return 1
		;;
	*)
		debug "Updating constants: $1"
		;;
	esac
	$_CONF_GNU_SED -i "s/__LIBRARY_APPLICATION_PATH__/$_SED_LIBRARY_PATH\/$_TARGET_APPLICATION_NAME/g" $1
	$_CONF_GNU_SED -i "s/__LIBRARY_PATH__/$_SED_LIBRARY_PATH/g" $1
	$_CONF_GNU_SED -i "s/__APPLICATION_NAME__/$_TARGET_APPLICATION_NAME/g" $1
	$_CONF_GNU_SED -i "s/__APPLICATION_VERSION__/$_TARGET_APPLICATION_VERSION/g" $1
	$_CONF_GNU_SED -i "s/__PLATFORM__/$_PLATFORM/g" $1
}
_require_file() {
	_require "$1" filename _require_file
	local level=error
	[ -n "$_WARN" ] && level=warn
	if [ ! -e $1 ]; then
		$level "File: $1 does not exist | $2"
		return 1
	fi
}
_sed_safe() {
	printf '%s' $1 | sed -e "s/\//\\\\\//g"
}
_is_shell_script() {
	case $1 in
	*.sh)
		return 0
		;;
	esac
	head -1 $1 | $_CONF_GNU_GREP -Pcq 'sh$'
}
_include logging platform context wait beep paths net install
: ${_CONF_LOG_HEADER:="##################################################"}
: ${_CONF_LOG_C_ALRT:="1;31m"}
: ${_CONF_LOG_C_ERR:="1;31m"}
: ${_CONF_LOG_C_SCS:="1;32m"}
: ${_CONF_LOG_C_WRN:="1;33m"}
: ${_CONF_LOG_C_INFO:="1;36m"}
: ${_CONF_LOG_C_DETAIL:="1;0;36m"}
: ${_CONF_LOG_C_DEBUG:="1;35m"}
: ${_CONF_LOG_C_STDIN:="1;34m"}
: ${_CONF_LOG_DATE_FORMAT:="%Y/%m/%d|%H:%M:%S"}
: ${_CONF_LOG_DATE_TIME_FORMAT:="%Y/%m/%d %H:%M:%S"}
: ${_CONF_LOG_AUDIT:=0}
: ${_CONF_LOG_LEVEL:=2}
: ${_CONF_LOG_INDENT:="  "}
: ${_CONF_LOG_CONF_VALIDATION_FUNCTION:=warn}
: ${_CONF_LOG_WAITER_LEVEL:=debug}
: ${_CONF_LOG_FEATURE_TIMEOUT_ERROR_LEVEL:=warn}
: ${_CONF_LOG_LONG_RUNNING_CMD:=30}
: ${_CONF_LOG_LONG_RUNNING_CMD_LINES:=1000}
[ -t 0 ] && INTERACTIVE=1
: ${LIB:="beep.sh context.sh environment.sh exec.sh exit.sh help.sh include.sh logging.sh mktemp.sh platform.sh processes.sh stdin.sh syslog.sh sudo.sh wait.sh validation.sh net/mail.sh alert.sh"}
: ${CFG:="logging platform context wait beep paths net"}
: ${SUPPORTED_PLATFORMS:="Apple FreeBSD Linux Windows"}
: ${BUILD_PLATFORMS:="FreeBSD Linux Apple Windows"}
which pgrep >/dev/null 2>&1 && _PARENT_PROCESSES_FUNCTION=_parent_processes_pgrep
_DETECTED_PLATFORM=$(uname)
case $_DETECTED_PLATFORM in
Darwin)
	_DETECTED_PLATFORM=Apple
	;;
MINGW64_NT-*)
	_DETECTED_PLATFORM=Windows
	;;
esac
: ${_CONF_INSTALL_CONTEXT:=$_CONSOLE_CONTEXT_ID}
: ${_CONF_INSTALL_CONTEXT:=default}
: ${_CONF_WAIT_INTERVAL:=30}
: ${RSRC_BEEP:=/tmp/beep}
_CONF_LOG_BEEP_TIMEOUT=5
[ "$HOME" = "/" ] && HOME=/root
: ${_CONF_LIBRARY_PATH:=/usr/local/walterjwhite}
: ${_CONF_BIN_PATH:=/usr/local/bin}
_CONF_DATA_PATH=$HOME/.data
_CONF_CACHE_PATH=$_CONF_DATA_PATH/.cache
_CONF_CONFIG_PATH=$HOME/.config/walterjwhite
_CONF_RUN_PATH=/tmp/$USER/walterjwhite/app
_CONF_DATA_ARTIFACTS_PATH=$_CONF_DATA_PATH/install-v2/artifacts
_CONF_DATA_REGISTRY_PATH=$_CONF_DATA_PATH/install-v2/registry
_CONF_APPLICATION_DATA_PATH=$_CONF_DATA_PATH/$_APPLICATION_NAME
_CONF_APPLICATION_CONFIG_PATH=$_CONF_CONFIG_PATH/$_APPLICATION_NAME
_CONF_APPLICATION_LIBRARY_PATH=$_CONF_LIBRARY_PATH/$_APPLICATION_NAME
: ${_CONF_NETWORK_TEST_TIMEOUT:=5}
: ${_CONF_NETWORK_TEST_TARGETS:="http://connectivity-check.ubuntu.com http://example.org http://www.google.com http://telehack.com http://lxer.com"}
: ${_CONF_INSTALL_NO_PAGER:=0}
: ${_CONF_INSTALL_STEP_TIMEOUT:=300}
: ${_CONF_INSTALL_IOSTAT_DURATION:=5}
: ${_CONF_INSTALL_REPOSITORY_URL:=https://github.com/walterjwhite}
: ${_CONF_INSTALL_MIRROR_URLS:=https://github.com/walterjwhite}
: ${_CONF_INSTALL_SUDO_TIMEOUT:=270}
: ${_CONF_INSTALL_NETWORK_TEST_TARGET:=google.com}
: ${_CONF_INSTALL_NETWORK_TEST_TIMEOUT:=5}
: ${_CONF_INSTALL_TEAMS_MESSAGE_PARALLELIZATION:=5}
: ${_CONF_INSTALL_PARALLEL_BUILD:=8}
: ${_CONF_APP_REGISTRY_GIT_URL:=https://github.com/walterjwhite/app.registry.git}
: ${_CONF_INSTALL_AUTO_UPDATE_PACKAGES:=0}
: ${_CONF_CLEAN_APP_REGISTRY_WORKSPACE:=1}
: ${_CONF_INSTALL_RANDOM_DEFAULT_LENGTH:=8}
[ "$_CONF_INSTALL_NO_PAGER" = "1" ] && PAGER=cat
: ${_OPTN_INSTALL_BYPASS_UNINSTALL:=1}
which shfmt >/dev/null 2>&1 || _DISABLE_SHFMT=1
: ${_CONF_INSTALL_CHECKSUM_CMD:="sha256 -q"}
: ${REMOVE_UNUSED_FUNCTIONS:=y}
_REQUIRED_APP_CONF="_CONF_GNU_GREP _CONF_GNU_SED _CONF_INSTALL_STAT_ARGUMENTS _CONF_LOG_BEEP_ALRT _CONF_LOG_BEEP_DEBUG _CONF_LOG_BEEP_DETAIL _CONF_LOG_BEEP_ERR _CONF_LOG_BEEP_INFO _CONF_LOG_BEEP_SCS _CONF_LOG_BEEP_STDIN _CONF_LOG_BEEP_WRN"
_is_backgrounded && _BACKGROUNDED=1
_init_logging
unset _DEFERS _EXIT
_APPLICATION_START_TIME=$(date +%s)
_APPLICATION_CMD=$(basename $0)
trap _on_exit INT 0 1 2 3 4 6 15
for _ARG in "$@"; do
	case $_ARG in
	-conf-* | -[a-z0-9][a-z0-9][a-z0-9]*)
		_configuration_name=${_ARG#*-}
		_configuration_name=${_configuration_name%%=*}
		if [ $(printf '%s' "$_configuration_name" | grep -c '_') -eq 0 ]; then
			if [ $(printf '%s' "$_configuration_name" | grep -c '^conf') -gt 0 ]; then
				_configuration_name=$(printf '%s' "$_configuration_name" | sed -e "s/-/-$_APPLICATION_NAME-/")
			else
				_configuration_name=$(printf '%s' "$_configuration_name" | sed -e "s/^/$_APPLICATION_NAME-/")
			fi
		fi
		_configuration_name=$(printf '%s' $_configuration_name | tr '-' '_' | tr '[:lower:]' '[:upper:]')
		if [ $(printf '%s' "$_ARG" | grep -c '=') -eq 0 ]; then
			_configuration_value=1
		else
			_configuration_value=${_ARG#*=}
		fi
		export _$_configuration_name="$_configuration_value"
		unset _configuration_name
		shift
		;;
	-h | --help)
		_print_help_and_exit
		;;
	-w=*)
		_WAITER_PID="${1#*=}"
		shift
		;;
	-w)
		_WAITEE=1
		shift
		;;
	*)
		break
		;;
	esac
done
if [ -z "$_CONTEXT_VALIDATED" ]; then
	_context_id_is_valid "$_CONF_INSTALL_CONTEXT"
	_CONTEXT_VALIDATED=0
fi
_APPLICATION_CONTEXT_GROUP=$_CONF_RUN_PATH/$_CONF_INSTALL_CONTEXT
_APPLICATION_CMD_DIR=$_APPLICATION_CONTEXT_GROUP/$_APPLICATION_NAME/$_APPLICATION_CMD
_waitee_init
_waiter
_SED_LIBRARY_PATH=$(_sed_safe $_CONF_LIBRARY_PATH)
_app_build
