#!/bin/sh
set -a
_APPLICATION_NAME=gentoo-installer
_beep() {
  [ ! -e /dev/speaker ] && return 1
  flock -n -w 0 $RSRC_BEEP printf '%s' "$1" >/dev/speaker || {
    debug "Another 'beep' is in progress"
    return 2
  }
}
_sudo_precmd() {
  _beep $_CONF_LOG_SUDO_BEEP_TONE
}
_context_id_is_valid() {
  printf '%s' "$1" | $_CONF_GNU_GREP -Pq '^[a-zA-Z0-9_+-]+$' || error "Context ID *MUST* only contain alphanumeric characters and +-: '^[a-zA-Z0-9_+-]+$' | ($1)"
}
_variable_is_set() {
  env | grep -cq "^$1=.*$"
}
_environment_filter() {
  $_CONF_GNU_GREP -P "(^_CONF_|^_OPTN_|^_INSTALL_|^${_TARGET_APPLICATION_NAME}_)"
}
_environment_dump() {
  [ -z "$_APPLICATION_PIPE_DIR" ] && return
  [ -z "$_ENVIRONMENT_FILE" ] && _ENVIRONMENT_FILE=$_APPLICATION_PIPE_DIR/environment
  mkdir -p $(dirname $_ENVIRONMENT_FILE)
  env | _environment_filter | sort -u | grep -v '^$' | sed -e 's/=/="/' -e 's/$/"/' >>$_ENVIRONMENT_FILE
}
_call() {
  local _function_name=$1
  type $_function_name >/dev/null 2>&1 || {
    debug "${_function_name} does not exist"
    return 255
  }
  [ $# -gt 1 ] && {
    shift
    $_function_name "$@"
    return $?
  }
  $_function_name
}
_() {
  if [ -n "$_EXEC_ATTEMPTS" ]; then
    local attempt=1
    while [ $attempt -le $_EXEC_ATTEMPTS ]; do
      _WARN_ON_ERROR=1 _do_exec "$@" && return
      attempt=$(($attempt + 1))
    done
    error "Failed after $attempt attempts: $*"
  fi
  _do_exec "$@"
}
_do_exec() {
  local _successfulExitStatus=0
  if [ -n "$_SUCCESSFUL_EXIT_STATUS" ]; then
    _successfulExitStatus=$_SUCCESSFUL_EXIT_STATUS
    unset _SUCCESSFUL_EXIT_STATUS
  fi
  info "## $*"
  if [ -z "$_DRY_RUN" ]; then
    if [ -n "$_CMD_LOGFILE" ]; then
      _exec_to_file "$_CMD_LOGFILE" "$@"
    else
      if [ -z "$_LOGFILE" ]; then
        "$@"
      else
        _exec_to_file "$_LOGFILE" "$@"
      fi
    fi
    local _exit_status=$?
    if [ $_exit_status -ne $_successfulExitStatus ]; then
      if [ -n "$_ON_FAILURE" ]; then
        $_ON_FAILURE
        return
      fi
      if [ -z "$_WARN_ON_ERROR" ]; then
        error "Previous cmd failed: $* - $_exit_status"
      else
        unset _WARN_ON_ERROR
        warn "Previous cmd failed: $* - $_exit_status"
        _ENVIRONMENT_FILE=$(_mktemp error) _environment_dump
        return $_exit_status
      fi
    fi
  fi
}
_exec_to_file() {
  local logfile=$1
  shift
  mkdir -p $(dirname $logfile)
  type $_function_name >/dev/null 2>&1 || {
    "$@" >>$logfile 2>>$logfile
    return $?
  }
  "$@"
}
error() {
  if [ $# -ge 2 ]; then
    _EXIT_STATUS=$2
  else
    _EXIT_STATUS=1
  fi
  _EXIT_LOG_LEVEL=4
  _EXIT_STATUS_CODE="ERR"
  _EXIT_COLOR_CODE="$_CONF_LOG_C_ERR"
  _EXIT_MESSAGE="$1 ($_EXIT_STATUS)"
  _EXIT_BEEP=$_CONF_LOG_BEEP_ERR
  _defer _environment_dump
  _defer _log_app_exit
  exit $_EXIT_STATUS
}
_success() {
  _EXIT_STATUS=0
  _EXIT_LOG_LEVEL=1
  _EXIT_STATUS_CODE="SCS"
  _EXIT_COLOR_CODE="$_CONF_LOG_C_SCS"
  _EXIT_MESSAGE="$1"
  _EXIT_BEEP=$_CONF_LOG_BEEP_SCS
  _defer _long_running_cmd
  _defer _log_app_exit
  [ -z "$_EXIT" ] && exit 0
}
_on_exit() {
  [ $_EXIT ] && return 1
  _EXIT=0
  [ -z "$_EXIT_STATUS" ] && _success "completed successfully"
  if [ -n "$_DEFERS" ]; then
    local defer
    for defer in $_DEFERS; do
      _call $defer
    done
    unset _DEFERS
  fi
  return $_EXIT
}
_defer() {
  if [ -n "$_DEFERS" ]; then
    local defer
    for defer in $_DEFERS; do
      [ "$defer" = "$1" ] && {
        debug "not deferring: $1 as it was already deferred"
        return
      }
    done
  fi
  debug "deferring: $1"
  _DEFERS="$1 $_DEFERS"
}
_log_app_exit() {
  [ "$_EXIT_MESSAGE" ] && {
    local current_time=$(date +%s)
    local timeout=$(($_APPLICATION_START_TIME + $_CONF_LOG_BEEP_TIMEOUT))
    [ $current_time -le $timeout ] && unset _EXIT_BEEP
    _print_log $_EXIT_LOG_LEVEL "$_EXIT_STATUS_CODE" "$_EXIT_COLOR_CODE" "$_EXIT_BEEP" "$_EXIT_MESSAGE"
  }
  _log_app exit
  [ -n "$_LOGFILE" ] && [ -n "$_OPTN_LOG_EXIT_CMD" ] && {
    $_OPTN_LOG_EXIT_CMD -file $_LOGFILE
  }
}
_print_help() {
  if [ -e $2 ]; then
    info "$1:"
    cat $2
    printf '\n'
  fi
}
_print_help_and_exit() {
  _print_help 'system-wide options' $_CONF_LIBRARY_PATH/install/help/default
  if [ "$_APPLICATION_NAME" != "install" ]; then
    _print_help $_APPLICATION_NAME $_CONF_LIBRARY_PATH/$_APPLICATION_NAME/help/default
    _print_help "$_APPLICATION_NAME/$_APPLICATION_CMD" $_CONF_LIBRARY_PATH/$_APPLICATION_NAME/help/$_APPLICATION_CMD
  fi
  exit 0
}
_include() {
  local include_file
  for include_file in "$@"; do
    [ -f $HOME/.config/walterjwhite/$include_file ] && . $HOME/.config/walterjwhite/$include_file
  done
}
_init_logging() {
  [ -n "$_LOGFILE" ] && _set_logfile "$_LOGFILE"
  case $_CONF_LOG_LEVEL in
  0)
    local logfile=$(_mktemp debug)
    warn "Writing debug contents to: $logfile"
    _set_logfile "$logfile"
    set -x
    ;;
  esac
}
_set_logfile() {
  [ -z "$1" ] && return 1
  _LOGFILE=$1
  mkdir -p $(dirname $1)
  _reset_indent
  [ -n "$_CHILD_LOG" ] || exec 3>&1 4>&2
  exec >>$_LOGFILE 2>&1
  [ -z "$_PRESERVE_LOG" ] && [ -z "$_CHILD_LOG" ] && truncate -s 0 $1 >/dev/null 2>&1
}
warn() {
  _print_log 3 WRN "$_CONF_LOG_C_WRN" "$_CONF_LOG_BEEP_WRN" "$1"
}
info() {
  _print_log 2 INF "$_CONF_LOG_C_INFO" "$_CONF_LOG_BEEP_INFO" "$1"
}
detail() {
  _print_log 2 DTL "$_CONF_LOG_C_DETAIL" "$_CONF_LOG_BEEP_DETAIL" "$1"
}
debug() {
  _print_log 1 DBG "$_CONF_LOG_C_DEBUG" "$_CONF_LOG_BEEP_DEBUG" "($$) $1"
}
_log() {
  :
}
_sed_remove_nonprintable_characters() {
  sed -e 's/[^[:print:]]//g'
}
_print_log() {
  if [ -z "$5" ]; then
    if test ! -t 0; then
      local _line
      cat - | _sed_remove_nonprintable_characters |
        while read _line; do
          _print_log $1 $2 $3 $4 "$_line"
        done
      return
    fi
    return
  fi
  local message="$5"
  [ $1 -lt $_CONF_LOG_LEVEL ] && return
  [ -n "$_LOGGING_CONTEXT" ] && message="$_LOGGING_CONTEXT - $message"
  local _message_date_time=$(date +"$_CONF_LOG_DATE_FORMAT")
  if [ $_BACKGROUNDED ] && [ $_OPTN_INSTALL_BACKGROUND_NOTIFICATION_METHOD ]; then
    $_OPTN_INSTALL_BACKGROUND_NOTIFICATION_METHOD "$2" "$_message" &
  fi
  [ -n "$4" ] && _beep "$4"
  _log_to_file "$2" "$_message_date_time" "${_LOG_INDENT}$message"
  _log_to_console "$3" "$2" "$_message_date_time" "${_LOG_INDENT}$message"
  [ -z "$INTERACTIVE" ] && _syslog "$message"
  return 0
}
_reset_indent() {
  unset _LOG_INDENT
}
_log_to_file() {
  [ -z "$_LOGFILE" ] && return
  if [ $_CONF_LOG_AUDIT -gt 0 ]; then
    printf '%s %s %s\n' "$1" "$2" "$3" >>$_LOGFILE
    return
  fi
  printf '%s\n' "$3" >>$_LOGFILE
}
_log_to_console() {
  local stderr=2
  [ ! -t $stderr ] && stderr=4
  [ ! -t $stderr ] && return
  if [ $_CONF_LOG_AUDIT -gt 0 ]; then
    printf >&$stderr '\033[%s%s \033[0m%s %s\n' "$1" "$2" "$3" "$4"
    return
  fi
  printf >&$stderr '\033[%s%s \033[0m\n' "$1" "$4"
}
_log_app() {
  debug "$_APPLICATION_NAME:$_APPLICATION_CMD - $1 ($$)"
}
_mktemp() {
  local suffix=$1
  [ -n "$suffix" ] && suffix=".$suffix"
  local sudo_prefix
  [ -n "$_SUDO_USER" ] && sudo_prefix=_sudo
  $sudo_prefix mktemp -${_MKTEMP_OPTIONS}t ${_APPLICATION_NAME}.${_APPLICATION_CMD}${suffix}.XXXXXXXX
}
_sub_platform() {
  which lsb_release >/dev/null 2>&1 && {
    _SUB_PLATFORM=$(lsb_release -a | grep ID | cut -f2 -d: | tr -d '\t')
    return
  }
  [ -e $_ROOT/etc/os-release ] && {
    _SUB_PLATFORM=$(grep ^NAME= $_ROOT/etc/os-release | cut -f2 -d= | sed -e 's/"//g' -e 's/ Linux//')
  }
  [ -e $_ROOT/etc/gentoo-release ] && _SUB_PLATFORM=Gentoo
}
_setup_app_pipe() {
  _APPLICATION_PIPE=$_APPLICATION_CMD_DIR/$$
  _APPLICATION_PIPE_DIR=$(dirname $_APPLICATION_PIPE)
  mkdir -p $_APPLICATION_PIPE_DIR
  mkfifo $_APPLICATION_PIPE
  _defer _cleanup_app_pipe
}
_cleanup_app_pipe() {
  rm -f $_APPLICATION_PIPE
}
_kill_all() {
  _do_kill_all $_APPLICATION_PIPE_DIR
}
_kill_all_group() {
  _do_kill_all $_APPLICATION_CONTEXT_GROUP
}
_do_kill_all() {
  for _EXISTING_APPLICATION_PIPE in $(find $1 -type p -not -name $$); do
    _kill $(basename $_EXISTING_APPLICATION_PIPE)
  done
}
_kill() {
  warn "Killing $1"
  kill -TERM $1
}
_list() {
  _list_pidinfos $_APPLICATION_PIPE_DIR
}
_list_group() {
  _list_pidinfos $_APPLICATION_CONTEXT_GROUP
}
_list_pidinfos() {
  info "Running processes:"
  _EXECUTABLE_NAME_SED_SAFE=$(_sed_safe $0)
  for _EXISTING_APPLICATION_PIPE in $(find $1 -type p -not -name $$); do
    _list_pidinfo
  done
}
_parent_processes_pgrep() {
  pgrep -P $1
}
_is_backgrounded() {
  case $(ps -o stat= -p $$) in
  *+*)
    return 1
    ;;
  esac
  return 0
}
_list_pidinfo() {
  _TARGET_PID=$(basename $_EXISTING_APPLICATION_PIPE)
  _TARGET_PS_DTL=$(ps -o command -p $_TARGET_PID | sed 1d | sed -e "s/^.*$_EXECUTABLE_NAME_SED_SAFE/$_EXECUTABLE_NAME_SED_SAFE/")
  info " $_TARGET_PID - $_TARGET_PS_DTL"
}
_interactive_alert_if() {
  _is_interactive_alert_enabled && _interactive_alert "$@"
}
_is_interactive_alert_enabled() {
  grep -cq '^_OPTN_INSTALL_INTERACTIVE_ALERT=1$' $_CONF_APPLICATION_CONFIG_PATH 2>/dev/null
}
_continue_if() {
  _read_if "$1" _PROCEED "$2"
  local proceed="$_PROCEED"
  unset _PROCEED
  if [ -z "$proceed" ]; then
    _DEFAULT=$(printf '%s' $2 | awk -F'/' {'print$1'})
    proceed=$_DEFAULT
  fi
  local proceed=$(printf '%s' "$proceed" | tr '[:lower:]' '[:upper:]')
  if [ $proceed = "N" ]; then
    return 1
  fi
  return 0
}
_read_if() {
  if [ $(env | grep -c "^$2=.*") -eq 1 ]; then
    debug "$2 is already set"
    return 1
  fi
  [ -z "$INTERACTIVE" ] && error "Running in non-interactive mode and user input was requested: $@" 10
  _print_log 9 STDI "$_CONF_LOG_C_STDIN" "$_CONF_LOG_BEEP_STDIN" "$1 $3"
  _interactive_alert_if $1 $3
  read -r $2
}
_syslog() {
  logger -i -t "$_APPLICATION_NAME.$_APPLICATION_CMD" "$1"
}
_sudo() {
  [ $# -eq 0 ] && error 'No arguments were provided to _sudo'
  _require "$_SUDO_CMD" _SUDO_CMD
  _sudo_is_required || {
    "$@"
    return
  }
  [ -n "$INTERACTIVE" ] && {
    $_SUDO_CMD -n ls >/dev/null 2>&1 || _sudo_precmd "$@"
  }
  $_SUDO_CMD $sudo_options "$@"
  unset sudo_options
}
_sudo_is_required() {
  [ -n "$_SUDO_USER" ] && {
    [ "$_SUDO_USER" = "$USER" ] && return 1
    sudo_options="$sudo_options -u $_SUDO_USER"
    return 0
  }
  [ "$USER" = "root" ] && return 1
  return 0
}
_waitee_init() {
  [ -z "$_WAITEE" ] && return
  _setup_app_pipe
  warn "($_APPLICATION_CMD) Please use -w=$$"
  _defer _waitee_done
}
_waitee_done() {
  if [ -n "$_WAITEE" ] && [ -e $_APPLICATION_PIPE ]; then
    info "$0 process completed, notifying ($_EXIT_STATUS)"
    printf '%s\n' "$_EXIT_STATUS" >$_APPLICATION_PIPE
    info "$0 downstream process picked up"
  fi
}
_waiter() {
  [ -z "$_WAITER_PID" ] && return
  _UPSTREAM_APPLICATION_PIPE=$(find $_APPLICATION_CONTEXT_GROUP -type p -name $_WAITER_PID 2>/dev/null | head -1)
  [ -z "$_UPSTREAM_APPLICATION_PIPE" ] && error "$_WAITER_PID not found"
  [ ! -e $_UPSTREAM_APPLICATION_PIPE ] && {
    warn "$_UPSTREAM_APPLICATION_PIPE does not exist, did upstream start?"
    return
  }
  info "Waiting for upstream to complete: $_WAITER_PID"
  while [ 1 ]; do
    if [ ! -e $_UPSTREAM_APPLICATION_PIPE ]; then
      error "Upstream pipe no longer exists"
    fi
    _UPSTREAM_APPLICATION_STATUS=$(_timeout $_CONF_WAIT_INTERVAL "_waiter:upstream" cat $_UPSTREAM_APPLICATION_PIPE 2>/dev/null)
    local _UPSTREAM_STATUS=$?
    if [ $_UPSTREAM_STATUS -eq 0 ]; then
      if [ -z "$_UPSTREAM_APPLICATION_STATUS" ] || [ $_UPSTREAM_APPLICATION_STATUS -gt 0 ]; then
        error "Upstream exited with error ($_UPSTREAM_APPLICATION_STATUS)"
      fi
      warn "Upstream finished: $_UPSTREAM_APPLICATION_PIPE ($_UPSTREAM_STATUS)"
      break
    fi
    detail " Upstream is still running: $_UPSTREAM_APPLICATION_PIPE ($_UPSTREAM_STATUS)"
    sleep 1
  done
}
_require() {
  local level=error
  if [ -z "$1" ]; then
    [ -n "$_WARN" ] && level=warn
    $level "$2 required $_REQUIRE_DETAILED_MESSAGE" $3
    return 1
  fi
  unset _REQUIRE_DETAILED_MESSAGE
}
_mail() {
  if [ $# -lt 3 ]; then
    warn "recipients[0], subject[1], message[2] is required - $# arguments provided"
    return 1
  fi
  local recipients=$(printf '%s' "$1" | tr '|' ' ')
  shift
  local subject="$1"
  shift
  local message="$1"
  shift
  printf "$message" | mail -s "$subject" $recipients
}
_alert() {
  _print_log 5 ALRT "$_CONF_LOG_C_ALRT" "$_CONF_LOG_BEEP_ALRT" "$1"
  local recipients="$_OPTN_LOG_ALERT_RECIPIENTS"
  local subject="Alert: $0 - $1"
  if [ -z "$recipients" ]; then
    warn "recipients is empty, aborting"
    return 1
  fi
  _mail "$recipients" "$subject" "$2"
}
_long_running_cmd() {
  [ -n "$_OPTN_DISABLE_LONG_RUNNING_CMD_NOTIFICATION" ] && return
  _APPLICATION_END_TIME=$(date +%s)
  _APPLICATION_RUNTIME=$(($_APPLICATION_END_TIME - $_APPLICATION_START_TIME))
  [ $_APPLICATION_RUNTIME -lt $_CONF_LOG_LONG_RUNNING_CMD ] && return
  local subject="[$_APPLICATION_NAME] - $_EXIT_MESSAGE - ($_EXIT_STATUS)"
  local message=""
  if [ -n "$_LOGFILE" ]; then
    message=$(tail -$_CONF_LOG_LONG_RUNNING_CMD_LINES $_LOGFILE)
  fi
  _alert "$subject" "$message"
}
_file() {
  [ ! -e $1/file ] && {
    warn 'No files to extract'
    return
  }
  tar cp -C $1/file | tar xp -C /
}
_gpg_verify() {
  _require "$1" "File to verify with GPG"
  local gpg_output=$(gpg --verify "$1" 2>&1)
  local gpg_status=$?
  [ $gpg_status -gt 0 ] && {
    error "$gpg_output" $gpg_status
  }
  detail "GPG verification completed"
}
_ZFS_RCLONE_PACKAGE=rclone
_zfs_rclone() {
  local rclone_patch_path=patches/zfs-rclone.patch/rclone.post-run
  mkdir -p $(dirname $rclone_patch_path)
  if [ -n "$_ZFS_RCLONE_TARGET" ]; then
    info "Configuring ZFS rclone target: $_ZFS_RCLONE_TARGET on $_ZFS_VOLUME"
    [ ! -e $rclone_patch_path ] && printf 'pkg install -yq %s\n' $_ZFS_RCLONE_PACKAGE >>$rclone_patch_path
    zfs set rclone:target=$_ZFS_RCLONE_TARGET $_ZFS_VOLUME
  fi
  [ -n "$_ZFS_RCLONE_PATH" ] && zfs set rclone:path=$_ZFS_RCLONE_PATH $_ZFS_VOLUME
  unset _ZFS_RCLONE_PATH _ZFS_RCLONE_TARGET
}
_ZFS_ZAP_PACKAGE=zap
_zfs_zap() {
  local zap_patch_path=patches/zfs-zap.patch/zap.post-run
  mkdir -p $(dirname $zap_patch_path)
  if [ -n "$_ZFS_ZAP_SNAP" ]; then
    warn "Detected ZFS ZAP, setting up zap"
    [ ! -e $zap_patch_path ] && printf 'pkg install -yq %s\n' $_ZFS_ZAP_PACKAGE >>$zap_patch_path
    printf 'zfs allow -u zap bookmark,diff,hold,send,snapshot %s\n' $_ZFS_VOLUME >>$zap_patch_path
    zfs set zap:snap=on $_ZFS_VOLUME
  fi
  [ -n "$_ZFS_ZAP_TTL" ] && zfs set zap:ttl=$_ZFS_ZAP_TTL $_ZFS_VOLUME
  [ -n "$_ZFS_ZAP_BACKUP" ] && zfs set zap:backup=$_ZFS_ZAP_BACKUP $_ZFS_VOLUME
  unset _ZFS_ZAP_TTL _ZFS_ZAP_BACKUP _ZFS_ZAP_SNAP
}
_prepare_chroot() {
  cp -R /tmp/gentoo $_CONF_GENTOO_INSTALL_PATH/tmp
  rm -rf $_CONF_GENTOO_INSTALL_PATH/root/.config && mkdir -p $_CONF_GENTOO_INSTALL_PATH/root/.config
  cp -R /root/.config/walterjwhite $_CONF_GENTOO_INSTALL_PATH/root/.config
  mkdir -p $_CONF_GENTOO_INSTALL_PATH/root/.ssh
  cp /root/.ssh/id* \
    /root/.ssh/authorized_keys \
    /root/.ssh/known_hosts \
    $_CONF_GENTOO_INSTALL_PATH/root/.ssh
  cp -R /root/.ssh $_CONF_GENTOO_INSTALL_PATH/tmp/HOST-SSH
  cp -R /root/.config/walterjwhite $_CONF_GENTOO_INSTALL_PATH/tmp/CONFIG-WALTERJWHITE
  mkdir -p $_CONF_GENTOO_INSTALL_PATH/root/.ssh/socket
  mkdir -p $_CONF_GENTOO_INSTALL_PATH/$_CONF_BIN_PATH
  cp $_CONF_BIN_PATH/* $_CONF_GENTOO_INSTALL_PATH/$_CONF_BIN_PATH
  [ "$_APPLICATION_CMD" = "gentoo-incus" ] && return 0
  info "$_APPLICATION_CMD - preparing chroot"
  cp /etc/resolv.conf $_CONF_GENTOO_INSTALL_PATH/etc
  [ -e /etc/hostid ] && cp /etc/hostid $_CONF_GENTOO_INSTALL_PATH/etc
  return 0
}
_portage_write_package_license() {
  mkdir -p $_CONF_GENTOO_INSTALL_PATH/etc/portage/package.license
  printf '\n\nACCEPT_LICENSE="-* %s"\n' "$GENTOO_SOFTWARE_LICENSE" >>$_CONF_GENTOO_INSTALL_PATH/etc/portage/make.conf
}
_portage_system_use_flags() {
  printf '# system use flags\n' >>$_CONF_GENTOO_INSTALL_PATH/etc/portage/make.conf
  find . -type f -path '*/system/use' -exec $_CONF_GNU_GREP -Pvh '(^$|^#)' {} + |
    tr '\n' ' ' |
    sed -e 's/^/USE="$USE /' -e 's/$/"\n\n/' >>$_CONF_GENTOO_INSTALL_PATH/etc/portage/make.conf
}
_configure() {
  _configure_system .
  _configure_patches
}
_configure_system() {
  [ -e $1/system/conf ] && . $1/system/conf
  [ -n "$GENTOO_SYSTEM_IMPORTS" ] && {
    local system_import
    for system_import in $GENTOO_SYSTEM_IMPORTS; do
      [ -e $system_import/system/conf ] && . $system_import/system/conf
    done
  }
}
_configure_patches() {
  local configuration_script patch_path
  for configuration_script in $(find . -type f -path '*/.patch/configure'); do
    patch_path=$(dirname $configuration_script)
    $configuration_script || {
      warn "$configuration_script [$?], disabling patch"
      rm -rf $patch_path
      continue
    }
    detail "Keeping $patch_path"
  done
}
_setup_git() {
  rm -rf $GENTOO_REPOSITORY_PREFIX/tmp/gentoo
  _setup_git_clone $GENTOO_SYSTEM_NAME $GENTOO_REPOSITORY_PREFIX/tmp/gentoo
  cd $GENTOO_REPOSITORY_PREFIX/tmp/gentoo
}
_setup_git_clone() {
  mkdir -p $2
  git archive --remote $_CONF_GENTOO_INSTALLER_GIT_URL $1 | tar xp -C $2 || {
    ping -c1 git >/dev/null 2>&1 || warn "Unable to ping git"
    ping -c1 google.com >/dev/null 2>&1 || warn "Unable to ping google"
    error "Error setting up git $_CONF_GENTOO_INSTALLER_GIT_URL [$*]"
  }
  cd $2
  [ -e .import ] || {
    detail "No imports detected - $2"
    return
  }
  detail "Setting up import"
  local git_import_contents=$(head -1 .import)
  GENTOO_SYSTEM_IMPORTS="$GENTOO_SYSTEM_IMPORTS imports/$git_import_contents"
  _setup_git_clone $git_import_contents $GENTOO_REPOSITORY_PREFIX/tmp/gentoo/imports/$git_import_contents
}
_hardware() {
  _write_cpu_flags
  [ -z "$GENTOO_VIDEO_CARDS" ] && _get_video_cards
  _write_video_cards
  _makeopts
}
_makeopts() {
  local system_memory=$(free -g | awk '/^Mem:/{print $2}')
  local allowed_jobs=$(($system_memory / 2))
  local load_average=$(($allowed_jobs + 1))
  printf '# @see: https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Stage#MAKEOPTS\n' >>$_CONF_GENTOO_INSTALL_PATH/etc/portage/make.conf
  printf 'MAKEOPTS="-j%s -l%s"\n' $allowed_jobs $load_average >>$_CONF_GENTOO_INSTALL_PATH/etc/portage/make.conf
}
_get_video_cards() {
  oIFS="$IFS"
  IFS=$'\n'
  local lspci_line
  local video_api="vulkan"
  for lspci_line in $(lspci | $_CONF_GNU_GREP -Pi '(VGA compatible controller|Display controller)'); do
    case $lspci_line in
    *AMD/ATI*)
      GENTOO_VIDEO_CARDS="$GENTOO_VIDEO_CARDS radeon radeonsi"
      mkdir -p $_CONF_GENTOO_INSTALL_PATH/etc/portage/package.use
      printf 'x11-libs/libdrm video_cards_amdgpu\n' >>$_CONF_GENTOO_INSTALL_PATH/etc/portage/package.use/amdgpu
      ;;
    *Intel\ Corporation*)
      GENTOO_VIDEO_CARDS="$GENTOO_VIDEO_CARDS intel"
      ;;
    *Intel\ Corporation*)
      GENTOO_VIDEO_CARDS="$GENTOO_VIDEO_CARDS intel"
      ;;
    *NVIDIA\ Corporation*)
      case $lspci_line in
      *K3100M*)
        GENTOO_VIDEO_CARDS="$GENTOO_VIDEO_CARDS nouveau"
        video_api="$video_api vaapi"
        ;;
      *)
        if [ -n "$GENTOO_PROPRIETARY_NVIDIA" ]; then
          GENTOO_VIDEO_CARDS="$GENTOO_VIDEO_CARDS nvidia"
        else
          GENTOO_VIDEO_CARDS="$GENTOO_VIDEO_CARDS nouveau"
          video_api="$video_api vaapi"
        fi
        ;;
      esac
      video_api="$video_api cuda vdpau nvenc"
      ;;
    *)
      printf 'Other: %s\n' "$lspci_line"
      ;;
    esac
  done
  printf '# video cards\nUSE="$USE %s"\n\n' "$video_api" >>$_CONF_GENTOO_INSTALL_PATH/etc/portage/make.conf
  IFS="$oIFS"
}
_write_cpu_flags() {
  mkdir -p $_CONF_GENTOO_INSTALL_PATH/etc/portage/package.use
  printf '*/* %s\n' "$(cpuid2cpuflags)" >$_CONF_GENTOO_INSTALL_PATH/etc/portage/package.use/00cpu-flags
}
_write_video_cards() {
  printf '*/* VIDEO_CARDS: -* %s\n' "$GENTOO_VIDEO_CARDS" >$_CONF_GENTOO_INSTALL_PATH/etc/portage/package.use/00video
}
_pre_chroot() {
  warn "Executing pre_chroot"
  find . -type f -path '*/system/pre_chroot' -type f -exec {} \;
}
_stage3() {
  _stage3_fetch || {
    [ -n "$stage3_retry" ] && error "Stage3 failed: already retried"
    warn "File failed verification, discarding: $_DOWNLOADED_FILE"
    rm -f $STAGE3_VERSION_FILE $STAGE3_FILE $STAGE3_SIGNATURE_FILE
    stage3_retry=1 _stage3
  }
  _stage3_extract $STAGE3_FILE
}
_stage3_fetch() {
  LATEST_STAGE3_NAME=$(_stage3_latest_version)
  _require "$LATEST_STAGE3_NAME" LATEST_STAGE3_NAME
  _download https://distfiles.gentoo.org/releases/$GENTOO_CPU_ARCHITECTURE/autobuilds/current-stage3-$GENTOO_CPU_ARCHITECTURE-$GENTOO_STAGE3_TYPE/stage3-$GENTOO_CPU_ARCHITECTURE-$GENTOO_STAGE3_TYPE-$LATEST_STAGE3_NAME.tar.xz
  STAGE3_FILE=$_DOWNLOADED_FILE
  _download https://distfiles.gentoo.org/releases/$GENTOO_CPU_ARCHITECTURE/autobuilds/current-stage3-$GENTOO_CPU_ARCHITECTURE-$GENTOO_STAGE3_TYPE/stage3-$GENTOO_CPU_ARCHITECTURE-$GENTOO_STAGE3_TYPE-$LATEST_STAGE3_NAME.tar.xz.asc
  STAGE3_SIGNATURE_FILE=$_DOWNLOADED_FILE
  _gpg_verify $STAGE3_SIGNATURE_FILE
}
_stage3_latest_version() {
  _download https://distfiles.gentoo.org/releases/$GENTOO_CPU_ARCHITECTURE/autobuilds/current-stage3-$GENTOO_CPU_ARCHITECTURE-$GENTOO_STAGE3_TYPE/latest-stage3-$GENTOO_CPU_ARCHITECTURE-$GENTOO_STAGE3_TYPE.txt
  STAGE3_VERSION_FILE=$_DOWNLOADED_FILE
  _gpg_verify $STAGE3_VERSION_FILE
  grep "$GENTOO_STAGE3_TYPE" $STAGE3_VERSION_FILE | sed -e 's/\.tar\.xz.*$//' -e 's/^.*\-//'
}
_stage3_extract() {
  tar ${_CONF_GENTOO_VERBOSE_TAR}xpf $1 --xattrs-include='*.*' --numeric-owner -C $_CONF_GENTOO_INSTALL_PATH
}
_write_system() {
  local gentoo_system_id_file=$_CONF_GENTOO_INSTALL_PATH/$_CONF_GENTOO_INSTALLER_SYSTEM_IDENTIFICATION
  mkdir -p $(dirname $gentoo_system_id_file)
  printf '%s\n' $GENTOO_SYSTEM_NAME >$gentoo_system_id_file
  printf '%s\n' $GENTOO_SYSTEM_BRANCH >>$gentoo_system_id_file
  printf '%s\n' $_CONF_GENTOO_INSTALLER_GIT_URL >>$gentoo_system_id_file
  git ls-remote $_CONF_GENTOO_INSTALLER_GIT_URL -b $GENTOO_SYSTEM_NAME | awk {'print$1'} >>$gentoo_system_id_file
  printf 'Provision Date: %s\n' "$(date)" >>$gentoo_system_id_file
}
_configure_patches() {
  local configure_script configure_script_path configure_script_status
  for configure_script in $(find /tmp/gentoo/ -type f -name configure); do
    configure_script_path=$(dirname $configure_script)
    $configure_script
    configure_script_status=$?
    if [ $configure_script_status -eq 0 ]; then
      detail "Keeping - $configure_script_path"
    else
      _configure_remove_patch $configure_script_status $configure_script_path
    fi
  done
}
_configure_remove_patch() {
  warn "Disabling - $2 ($1)"
  rm -rf $2
}
_app_is_file=1
app() {
  local app
  for app in $@; do
    _PRESERVE_LOG=1 app-install $app
  done
}
chmod() {
  local chmod_file
  for chmod_file in $@; do
    . $chmod_file
    chmod $options $mode $path
    unset mode path options
  done
}
chown() {
  local chown_file
  for chown_file in $@; do
    . $chown_file
    chown $options $owner:$group $path
    unset owner group path options
  done
}
_crontab_type=d
crontab() {
  local crontabs_temp_path=$(_MKTEMP_OPTIONS=d _mktemp)
  local crontab_file
  local crontab_user_file
  local crontab_user
  local crontabs_directory
  for crontabs_directory in $@; do
    crontab_user=$(basename $crontabs_directory)
    crontab_user_file=$crontabs_temp_path/$crontab_user
    local crontab_path
    for crontab_path in $(find $crontabs_directory -type f | sort -u); do
      printf '# %s\n' "$crontab_path" >>$crontab_user_file
      cat $crontab_path >>$crontab_user_file
    done
  done
  for crontab_user_file in $(find $crontabs_temp_path -type f | sort -u); do
    crontab_user=$(basename $crontab_user_file)
    [ $crontab_user != "root" ] && {
      _SUDO_USER=$crontab_user _sudo chown $crontab_user $crontab_user_file
    }
    info "Updating $crontab_user crontab"
    _crontab_append $crontab_user $crontab_user_file
    rm -f $crontab_user_file
  done
  unset user
}
_CUPS_PATH=/etc/cups
cups_printer() {
  local cups_printer_conf
  for cups_printer_conf in $@; do
    _cups_printer_add $cups_printer_conf
  done
}
_cups_printer_add() {
  _cups_printer_exists $1 || {
    info "Adding $1"
    cat $1 >>$_CUPS_PATH/printers.conf
  }
}
_cups_printer_exists() {
  [ ! -e $_CUPS_PATH/printers.conf ] && return 1
  local printer_uuid=$(grep ^UUID $1 | sed -e 's/UUID urn:uuid://')
  [ $(grep -c $printer_uuid $_CUPS_PATH/printers.conf) -eq 0 ] && return 1
  warn "Printer ($printer_uuid) already exists"
  return 0
}
_file_type=d
_file_path='file'
_file_exec="rsync -lmrt {}/ / ;"
fstab() {
  local fstab
  local patch_name
  for fstab in $@; do
    patch_name=$(_module_get_patch_name $fstab)
    printf '# %s\n' "$patch_name" >>/etc/fstab
    cat $fstab >>/etc/fstab
    printf '\n' >>/etc/fstab
  done
}
_go_is_file=1
go() {
  _go_bootstrap
  _go_install "$@"
}
group() {
  local group_conf
  for group_conf in $@; do
    _group_add $group_conf
  done
}
_group_add() {
  . $1
  detail " add group: $1 $groupName $gid"
  groupadd -g $gid $groupName
  unset groupName gid
}
_incus_options='-name *.incus'
incus_pre() {
  package_install app-containers/incus
  rc-update add incus && rc-update add incus-user
  grep -qm1 'root:1000000' $_CONF_GENTOO_INSTALL_PATH/etc/subuid || {
    detail "Configuring users and groups for incus"
    printf 'root:1000000:1000000000\n' | tee -a /etc/subuid /etc/subgid >/dev/null
  }
  [ -n "$GENTOO_INSTALLER_CHROOT" ] && {
    warn "The remaining init operations are currently performed after rebooting into the live system"
    return
  }
  _CONF_GENTOO_INSTALL_PATH=/ _ _incus_live_pre
}
incus() {
  [ -n "$GENTOO_INSTALLER_CHROOT" ] && {
    warn "The remaining init operations are currently performed after rebooting into the live system"
    return
  }
  _INCUS_CONFIGURATION_FILE=$1
  _ _incus_live "$_INCUS_CONFIGURATION_FILE"
}
link() {
  local link_conf
  for link_conf in $@; do
    _link_do $link_conf
  done
}
_link_do() {
  . $1
  for _TARGET in $targets; do
    detail "ln -sf $path -> $_TARGET"
    local parent=$(dirname $_TARGET)
    if [ ! -e $path ]; then
      warn "$path does NOT exist"
      continue
    elif [ ! -e $parent ]; then
      mkdir -p $parent
    fi
    ln -sf $path $_TARGET
  done
  unset _TARGET path targets
}
lxd() {
  warn "Not implemented - lxd"
}
_npm_is_file=1
npm() {
  _npm_install $@
}
_package_is_file=1
package() {
  [ $# -eq 0 ] && error 'No packages'
  local package
  for package in "$@"; do
    package_install $package
  done
}
_use_is_file=1
post_run() {
  _run
}
post_run_post() {
  _post_run_restore_ssh
}
_post_run_restore_ssh() {
  detail "Restoring SSH configuration (if applicable)"
  [ -e /root/.ssh.restore ] && _post_run_restore_ssh_do /root
  for s in $(find /home -mindepth 2 -maxdepth 2 -name '.ssh.restore' -type d); do
    _post_run_restore_ssh_do $(dirname $s)
  done
}
_post_run_restore_ssh_do() {
  warn "Removing setup .ssh with .ssh.restore [$1]"
  rm -rf $1/.ssh
  mv $1/.ssh.restore $1/.ssh
}
_pypi_is_file=1
pypi() {
  _pypi_install "$@"
}
run() {
  local run_conf
  for run_conf in $@; do
    cd /tmp/gentoo
    . $run_conf || warn "Error running $GENTOO_SYSTEM_NAME $run_conf"
  done
}
_rust_is_file=1
rust() {
  _rust_install "$@"
}
service() {
  local service_line
  $_CONF_GNU_GREP -Pvh '^($|#)' "$@" | while read service_line; do
    [ -z "$service_line" ] && {
      warn "service_line was empty"
      continue
    }
    rc-update add $service_line
  done
}
_module_get_patch_name() {
  _module_get_patch_path "$1" |
    sed -e "s/^\.\///" -e "s/\.patch$//" -e "s/^patches\///"
}
_module_get_patch_path() {
  printf '%s' "$1" | $_CONF_GNU_GREP -Po '^.*.\.patch'
}
_sysctl_exec="$_CONF_APPLICATION_LIBRARY_PATH/bin/_key_value /etc/sysctl.conf {} sysctl ;"
user() {
  _user_bootstrap
  local user_conf
  for user_conf in $@; do
    _PRESERVE_LOG=1 _users_add $user_conf
    unset _CONFIGURATION_INSTALLED
  done
}
_zfs_supports_jails=1
zfs() {
  [ -n "$container" ] && _kernel_zfs_support
  local zfs_volume_configuration
  for zfs_volume_configuration in $@; do
    if [ -n "$_IN_JAIL" ]; then
      mkdir -p /tmp/jail/zfs
      cp $zfs_volume_configuration /tmp/jail/zfs
      local zfs_volume_configuration_name=$(basename $zfs_volume_configuration)
      printf '_ZFS_JAILED=1\n' >>/tmp/jail/zfs/$zfs_volume_configuration_name
      printf '_ZFS_JAIL=%s\n' $_JAIL_NAME >>/tmp/jail/zfs/$zfs_volume_configuration_name
      printf '_ZFS_VOLUME_NAME=jails/%s/$_ZFS_VOLUME_NAME\n' $_JAIL_NAME >>/tmp/jail/zfs/$zfs_volume_configuration_name
    else
      _zfs_restore $zfs_volume_configuration
      unset _ZFS_DEV_NAME _ZFS_SOURCE_HOST _ZFS_VOLUME_NAME _ZFS_VOLUME_ABORT_CREATE _ZFS_ZAP_SNAP _ZFS_ZAP_TTL _ZFS_ZAP_BACKUP _ZFS_MOUNT_POINT _ZFS_VOLUME
    fi
  done
}
_zfs_restore() {
  info "_zfs_restore: $1"
  mkdir -p ~/.ssh/socket
  chmod 700 ~/.ssh/socket
  . $1
  [ -z "$_ZFS_DEV_NAME" ] && {
    warn "_ZFS_DEV_NAME is empty"
    return
  }
  [ -z "$_ZFS_SOURCE_HOST" ] && {
    warn "_ZFS_SOURCE_HOST is empty"
    return
  }
  [ -z "$_ZFS_VOLUME_NAME" ] && {
    warn "_ZFS_VOLUME_NAME is empty"
    return
  }
  _ZFS_VOLUME=${_ZFS_DEV_NAME}/$_ZFS_VOLUME_NAME
  _ZFS_SOURCE_SNAPSHOT=$(ssh $_ZFS_SOURCE_HOST zfs list -H -t snapshot | grep $_ZFS_VOLUME_NAME@ | grep -v backups | tail -1 | awk {'print$1'})
  [ -z "$_ZFS_SOURCE_SNAPSHOT" ] && {
    warn "No snapshots available, unable to setup clone: $_ZFS_VOLUME"
    return
  }
  _zfs_has_sufficient_space || {
    warn "Insufficient space to restore volume"
    return
  }
  info "zfs create $_ZFS_VOLUME"
  zfs create -p $_ZFS_VOLUME
  [ -n "$_ZFS_MOUNT_POINT" ] && zfs set mountpoint=$_ZFS_MOUNT_POINT $_ZFS_VOLUME
  [ -n "$_ZFS_JAILED" ] && zfs set jailed=on $_ZFS_VOLUME
  zfs set readonly=on $_ZFS_VOLUME
  ssh $_ZFS_SOURCE_HOST zfs send -v $_ZFS_SOURCE_SNAPSHOT | zfs receive -F $_ZFS_VOLUME
  zfs allow -g wheel bookmark,diff,hold,send,snapshot $_ZFS_VOLUME
  if [ -n "$_ZFS_SNAPSHOT_USER" ]; then
    mkdir -p /tmp/gentoo/$GENTOO_SYSTEM_NAME/patches/any/zfs-snapshot-user.patch/run/
    printf 'zfs allow -u %s bookmark,diff,hold,send,snapshot %s' $_ZFS_SNAPSHOT_USER $_ZFS_VOLUME \
      >>/tmp/gentoo/$GENTOO_SYSTEM_NAME/patches/any/zfs-snapshot-user.patch/run/allow-zfs-snapshot-user
    chmod +x /tmp/gentoo/$GENTOO_SYSTEM_NAME/patches/any/zfs-snapshot-user.patch/run/allow-zfs-snapshot-user
  fi
  _zfs_zap
  _zfs_rclone
  info "zfs create $_ZFS_VOLUME - done"
}
_zfs_has_sufficient_space() {
  _ZFS_SNAPSHOT_SPACE=$(ssh $_ZFS_SOURCE_HOST zfs list -t snapshot $_ZFS_SOURCE_SNAPSHOT | awk '{print$4}' | grep "G$" | sed -e "s/G$//")
  _ZFS_SNAPSHOT_REQUIRED_SPACE=$(printf '2 * %s\n' "$_ZFS_SNAPSHOT_SPACE" | bc)
  _ZPOOL_FREE_SPACE=$(zpool list -H $_ZFS_DEV_NAME | awk '{print$4}' | grep "G$" | sed -e "s/G$//")
  if [ $(printf '%s < %s\n' "$_ZFS_SNAPSHOT_REQUIRED_SPACE" "$_ZPOOL_FREE_SPACE" | bc) -eq 0 ]; then
    warn "Insufficient free space: $_ZFS_VOLUME_NAME - $_ZFS_SNAPSHOT_SPACE $_ZFS_SNAPSHOT_REQUIRED_SPACE $_ZPOOL_FREE_SPACE"
    return
  fi
  info "Setting up $_ZFS_VOLUME_NAME - $_ZFS_SNAPSHOT_SPACE $_ZFS_SNAPSHOT_REQUIRED_SPACE $_ZPOOL_FREE_SPACE"
}
_boot_loader_grub_BIOS() {
  grub-probe /boot
}
_boot_loader_grub_UEFI() {
  package_install sys-boot/shim sys-boot/mokutil sys-boot/efibootmgr
  grub-probe /boot/efi
  cp /usr/share/shim/BOOTX64.EFI /efi/EFI/Gentoo/shimx64.efi
  cp /usr/share/shim/mmx64.efi /efi/EFI/Gentoo/mmx64.efi
  cp /usr/lib/grub/grub-x86_64.efi.signed /efi/EFI/Gentoo/grubx64.efi
  grub-install --efi-directory=/efi
  mkdir -p /etc/env.d
  printf 'GRUB_CFG=/efi/EFI/Gentoo/grub.cfg\n' >>/etc/env.d/99grub
}
_kernel_zfs_support() {
  [ -n "$GENTOO_ZFS_POOL_NAME" ] && {
    [ -n "$GENTOO_DIST_KERNEL" ] && {
      [ -z "$container" ] && {
        printf 'sys-fs/zfs dist-kernel-cap\n' >>/etc/portage/package.use/zfs
      }
    }
    package_install sys-fs/zfs-kmod
    package_install sys-fs/zfs
    rc-update add zfs-import boot
    rc-update add zfs-mount boot
    rc-update add zfs-zed boot
  }
}
_incus_live_pre() {
  incus profile show default >/dev/null 2>&1 || _ incus admin init --auto
  incus profile show default | grep -A3 root | grep -A2 -B1 'path: /' | grep -A2 -B1 'pool: default' | grep -qm1 'type: disk' || {
    warn "Adding disk to default profile"
    _ incus profile device add default root disk pool=default path=/
    return
  }
  warn "Default profile already contains disk device"
}
_incus_live() {
  [ "$_APPLICATION_CMD" = "_gentoo-install-chroot" ] && {
    warn "Due to current limitations, this step *MUST* be performed on the live system"
    return
  }
  cd /tmp
  . $_INCUS_CONFIGURATION_FILE
  _INCUS_CONFIGURATION_FILE_PATH=$(dirname $_INCUS_CONFIGURATION_FILE)
  _CONTAINER_NAME=$(basename $_INCUS_CONFIGURATION_FILE_PATH | $_CONF_GNU_SED -e 's/\.incus//' -e 's/^[[:digit:]]\+\.//')
  _CONTAINER_PATH=/var/lib/incus/storage-pools/default/containers/$_CONTAINER_NAME/rootfs
  GENTOO_SYSTEM_NAME=$_CONTAINER_NAME
  incus config show $_CONTAINER_NAME >/dev/null 2>&1
  if [ $? -gt 0 ]; then
    detail "Creating new instance [$_CONTAINER_NAME]"
    _ incus launch images:$GENTOO_CONTAINER_IMAGE $_CONTAINER_NAME
  else
    warn "Using existing instance [$_CONTAINER_NAME]"
  fi
  mkdir -p $_CONTAINER_PATH/tmp
  cp -R /root/.ssh $_CONTAINER_PATH/tmp/HOST-SSH
  _incus_live_install_app install
  _NO_COPY_CONF=1 _incus_live_install_app gentoo-installer
  local o_CONF_GENTOO_INSTALL_PATH=$_CONF_GENTOO_INSTALL_PATH
  _CONF_GENTOO_INSTALL_PATH=$_CONTAINER_PATH
  _ _prepare_chroot
  GENTOO_REPOSITORY_PREFIX=$_CONTAINER_PATH _ _setup_git
  _ _configure
  _ _write_system
  _ _portage_write_package_license
  _ _portage_system_use_flags
  _ _hardware
  _ _pre_chroot
  _incus_mount_kernel_src
  incus exec \
    --env container=lxc $_CONTAINER_NAME \
    _gentoo-install-chroot
  if [ -e $_INCUS_CONFIGURATION_FILE_PATH/post-setup ]; then
    info "running post-setup scripts for $_CONTAINER_NAME"
    local post_setup_script
    for post_setup_script in $(find $_INCUS_CONFIGURATION_FILE_PATH/post-setup -type f | sort); do
      info "Running $post_setup_script"
      . $post_setup_script
    done
  fi
  _CONF_GENTOO_INSTALL_PATH=$o_CONF_GENTOO_INSTALL_PATH
}
_incus_mount_kernel_src() {
  [ -e /usr/src ] && {
    mkdir -p $_CONTAINER_PATH/usr/src
    mount --bind /usr/src $_CONTAINER_PATH/usr/src
    _defer _incus_umount_kernel_src
  }
}
_incus_umount_kernel_src() {
  umount $_CONTAINER_PATH/usr/src
}
_incus_live_install_app() {
  info "Installing $1 in container"
  mkdir -p $_CONTAINER_PATH/root/.config/walterjwhite
  [ -z "$_NO_COPY_CONF" ] &&
    cp ~/.config/walterjwhite/$1 $_CONTAINER_PATH/root/.config/walterjwhite
  _PRESERVE_LOG=1 _ROOT=$_CONTAINER_PATH app-install $1
}
_incus_live_start() {
  rc-service incus status | grep -cqm1 started && return
  rc-service incus start && sleep 1
  _defer _incus_live_stop
}
_incus_live_stop() {
  rc-service incus stop
}
_features() {
  cd $PWD
  if [ ! -e $1 ]; then
    if [ -z "$_WARN" ]; then
      warn "No features to install: $PWD $1"
    fi
    return 1
  fi
  info "Installing ${_FEATURE_MESSAGE}features"
  local feature
  for feature in $(_features_find $1 | sort -u); do
    _FEATURE_NAME=$(printf '%s' $feature | sed -e 's/\.feature/\.feature\n/g' | $_CONF_GNU_GREP -Po '/[a-zA-Z0-9-_]*.feature$' | sed -e 's/^\///' -e 's/\.feature$//' | tr '\n' '_' | sed -e 's/_$//')
    _application_defaults $feature
    _is_feature_enabled $_FEATURE_NAME || {
      _FEATURE_DISABLED=1 _disable_feature $_FEATURE_NAME
      _features_unset
      continue
    }
    _feature $feature || {
      _disable_feature $_FEATURE_NAME
      _features_unset
      continue
      featureerror=1
    }
    _FEATURE_MESSAGE="children " _WARN=0 _features $feature/feature
    _features_unset
  done
}
_features_unset() {
  unset _FEATURE_NAME _FEATURE_DISABLED
}
_features_find() {
  if [ -z "$_FEATURE_MESSAGE" ]; then
    find $1 -type d \( -name '*.feature' -and ! -path '*/*.feature/*' \)
  else
    find $1 -type d -name '*.feature' -and ! -path "$1"
  fi
}
_feature() {
  detail $_FEATURE_NAME
  _install $1 || return $?
  _feature_setup $1 || return $?
}
_feature_setup() {
  local setup_script
  for setup_script in $(find $1 -type f \( -path "$1/setup/*" \) | sort -u); do
    _setup_run_script $setup_script || return 1
  done
}
_install() {
  _sudo mkdir -p $_INSTALL_BIN_PATH
  _install_help $1
  local installed_files=$(_mktemp)
  _install_cmds $1 $installed_files
  _install_uninstall $1
  _install_files_files $1 $installed_files
  _install_update_files $installed_files
  if [ -e $1/.metadata ]; then
    cat $1/.metadata | _write "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.metadata"
  fi
}
_install_files() {
  if [ -e $1 ] && [ $(find $1 -type f | wc -l) -gt 0 ]; then
    if [ -n "$3" ]; then
      local files_sed_safe=$(_sed_safe $1)
      local target_sed_safe=$(_sed_safe $2)
      find $1 -type f | sed -e "s/^$files_sed_safe/$target_sed_safe/" >>$3
    fi
    _sudo mkdir -p $2
    tar -c $_TAR_ARGS -C $1 . | _sudo tar -xop $_TAR_ARGS -C $2
  fi
}
_install_help() {
  _install_files $1/help $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/help
}
_install_cmds() {
  if [ "$_TARGET_APPLICATION_NAME" = "$_APPLICATION_NAME" ]; then
    printf '%s\n' "$_INSTALL_BIN_PATH/$(basename $0)" >>$2
  fi
  _install_files $1/bin $_INSTALL_BIN_PATH $2
}
_install_uninstall() {
  _install_files $1/uninstall $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/uninstall
}
_install_files_files() {
  _install_files $1/files/_ROOT_ $_ROOT $2
  _install_files $1/files/_APPLICATION_ROOT_ "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME" $2
}
_install_update_files() {
  if [ -n "$_ROOT" ] && [ "$_ROOT" != "/" ]; then
    local root_sed_safe=$(_sed_safe $_ROOT)
    $_CONF_GNU_SED -i "s/^$root_sed_safe//" $1
  fi
  _INSTALLED_FILES="$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.files"
  cat $1 | _write "$_INSTALLED_FILES"
  rm -f $1
  _sudo chmod 444 $_INSTALLED_FILES
}
_install_metadata_write() {
  _write $_APPLICATION_METADATA_PATH
}
_metadata_write_platform() {
  env | grep '^_BOOTSTRAP_' | _install_metadata_write
}
app_bootstrap() {
  :
}
app_install() {
  _DEPENDENCY=1 app-install $1
}
app_uninstall() {
  app-uninstall $1
}
app_is_installed() {
  [ -e $_CONF_LIBRARY_PATH/$1/.metadata ] && return 0
  return 1
}
app_is_file() {
  return 1
}
crontab_bootstrap() {
  :
}
crontab_install() {
  local oSUDO_USER=$_SUDO_USER
  _SUDO_USER=root
  crontab_uninstall
  local temp_crontab=$(_mktemp)
  _sudo cp $1 $temp_crontab
  _sudo $_CONF_GNU_SED -i "s/$/ # app.$_TARGET_APPLICATION_NAME/" $temp_crontab
  printf '\n' | _sudo tee -a $temp_crontab >/dev/null 2>&1
  _sudo $_CONF_GNU_SED -i "1i # app.$_TARGET_APPLICATION_NAME" $temp_crontab
  _sudo $_CONF_GNU_SED -i "1i \\" $temp_crontab
  crontab_append $_SUDO_USER $temp_crontab
  _sudo rm -f $temp_crontab
  _SUDO_USER=$oSUDO_USER
}
crontab_uninstall() {
  local oSUDO_USER=$_SUDO_USER
  _SUDO_USER=root
  local temp_crontab=$(_mktemp)
  crontab_remove $temp_crontab
  crontab_write $_SUDO_USER $temp_crontab
  _sudo rm -f $temp_crontab
  _SUDO_USER=$oSUDO_USER
}
crontab_remove() {
  crontab_get $_SUDO_USER $1
  _sudo $_CONF_GNU_SED -i '/^$/d' $1
  _sudo $_CONF_GNU_SED -i "/# app.$_TARGET_APPLICATION_NAME/d" $1
}
crontab_is_installed() {
  local oSUDO_USER=$_SUDO_USER
  _SUDO_USER=root
  local temp_crontab=$(_mktemp)
  crontab_get $_SUDO_USER $temp_crontab
  _sudo grep -qm1 "# app.$_TARGET_APPLICATION_NAME" $temp_crontab
  _sudo rm -f $temp_crontab
  _SUDO_USER=$oSUDO_USER
}
crontab_enabled() {
  return 0
}
crontab_is_file() {
  return 0
}
expect_install() {
  $1 >/dev/null 2>&1
}
expect_uninstall() {
  warn "expect uninstall - Not implemented"
}
expect_is_installed() {
  return 1
}
expect_is_file() {
  return 0
}
go_bootstrap() {
  go_bootstrap_is_go_available || {
    package_install $go_PACKAGE
    go_bootstrap_is_go_available || go_DISABLED=1
  }
}
go_bootstrap_is_go_available() {
  which go >/dev/null 2>&1
}
go_install() {
  GO111MODULE=on GOPATH=$go_INSTALL_PATH sudo_options="--preserve-env=GO111MODULE,GOPATH" _sudo go install $go_OPTIONS "$@" || {
    warn "go install failed: $go_OPTIONS $@"
    warn "  http_proxy: $http_proxy"
    warn "  git  proxy: $(git config --global http.proxy)"
  }
}
go_update() {
  :
}
go_uninstall() {
  _sudo go uninstall "$@"
}
go_is_installed() {
  return 1
}
go_is_file() {
  return 1
}
npm_bootstrap() {
  npm_bootstrap_is_npm_available || {
    package_install $npm_PACKAGE
    npm_bootstrap_is_npm_available || npm_DISABLED=1
  }
  npm_setup_proxy
}
npm_bootstrap_is_npm_available() {
  which npm >/dev/null 2>&1
}
npm_install() {
  local npm_package
  for npm_package in "$@"; do
    npm_is_installed $npm_package || _sudo npm install -s -g "$npm_package"
  done
}
npm_uninstall() {
  _sudo npm uninstall -s -g "$@"
}
npm_is_installed() {
  npm list -g $1 >/dev/null
}
npm_is_file() {
  return 1
}
npm_setup_proxy() {
  if [ -n "$http_proxy" ]; then
    warn "Configuring NPM to use an HTTP proxy: $http_proxy"
    npm config set proxy $http_proxy
    npm config set https-proxy $https_proxy
    _defer npm_clear_proxy
  fi
}
npm_clear_proxy() {
  warn "Reverting NPM HTTP proxy: $http_proxy"
  npm config rm proxy
  npm config rm https-proxy
}
package_bootstrap() {
  :
}
package_install() {
  local packages
  local package
  for package in "$@"; do
    package_is_installed $package || {
      if [ -n "$packages" ]; then
        packages="$packages $package"
      else
        packages="$package"
      fi
    }
  done
  if [ -n "$packages" ]; then
    package_install_do "$packages"
  else
    warn "Packages [$*] are already installed, skipping"
    return 0
  fi
}
package_is_file() {
  return 1
}
package_enabled() {
  return 0
}
pypi_bootstrap() {
  pypi_bootstrap_is_pypi_available || {
    package_install $pypi_PACKAGE
    pypi_bootstrap_is_pypi_available || pypi_DISABLED=1
  }
}
pypi_bootstrap_is_pypi_available() {
  which pip >/dev/null 2>&1
}
pypi_install() {
  _sudo pip install -U --no-input "$@" >/dev/null
}
pypi_uninstall() {
  _sudo pip uninstall -y "$@" >/dev/null
}
pypi_is_installed() {
  error "PIP - is installed - NOT IMPLEMENTED"
}
pypi_is_file() {
  return 1
}
run_bootstrap() {
  :
}
run_install() {
  sh $1
}
run_uninstall() {
  warn "run uninstall - Not implemented"
}
run_is_installed() {
  return 1
}
run_is_file() {
  return 0
}
rust_bootstrap() {
  rust_bootstrap_is_rust_available || {
    package_install $rust_PACKAGE
    rust_bootstrap_is_rust_available || rust_DISABLED=1
  }
}
rust_bootstrap_is_rust_available() {
  which cargo >/dev/null 2>&1
}
rust_install() {
  _sudo cargo install "$@"
}
rust_update() {
  _sudo cargo update "$@"
}
rust_uninstall() {
  _sudo cargo uninstall "$@"
}
rust_is_installed() {
  error "RUST - is installed - NOT IMPLEMENTED"
}
rust_is_file() {
  return 1
}
user_is_file() {
  return 0
}
_bootstrap() {
  [ "$_APPLICATION_NAME" = "$_TARGET_APPLICATION_NAME" ] && _metadata_write_platform
  [ -z "$_PLATFORM_PACKAGES" ] && return 1
  [ -n "$_BOOTSTRAP_PLATFORM_PACKAGES_INSTALLED" ] && return 2
  info "Installing pre-requisites"
  _setup_run_do_bootstrap package
  package_install $_PLATFORM_PACKAGES
  _BOOTSTRAP_PLATFORM_PACKAGES_INSTALLED=1
  _metadata_write_platform
}
_application_defaults() {
  local default_file
  for default_file in $(find $1/cfg -type f 2>/dev/null); do
    _include $default_file
  done
}
_setup_run_script() {
  local setup_type_name=$(basename $1)
  _setup_contains_subtype $setup_type_name && {
    _setup_sub_platform_matches $setup_type_name || {
      warn "Ignoring $1, does not target this sub-platform"
      return
    }
  }
  case $setup_type_name in
  *.*)
    setup_type_name=$(printf '%s' $setup_type_name | sed -e "s/^.*\.//")
    ;;
  esac
  setup_type_name=${setup_type_name%_*}
  type ${setup_type_name}_bootstrap >/dev/null 2>&1 || {
    warn "Unknown type: $setup_type_name"
    return
  }
  if [ ! -e $1 ]; then
    warn "$1 no longer exists, ignoring"
    return 0
  fi
  _variable_is_set ${setup_type_name}_disabled && return
  _sudo mkdir -p "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type"
  _setup_run_do_bootstrap $setup_type_name
  ${setup_type_name}_is_file
  if [ $? -eq 0 ]; then
    _WARN=$_CONF_LOG_FEATURE_TIMEOUT_ERROR_LEVEL ${setup_type_name}_install $1 || {
      local error=$?
      warn "Error installing: $setup_type_name: $1"
      return $error
    }
    _call ${setup_type_name}_get_data $1 | _write "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type/.${setup_type_name}"
  else
    local packages=$($_CONF_GNU_GREP -Pv '(^$|^#)' $1 | tr '\n' ' ')
    _WARN=$_CONF_LOG_FEATURE_TIMEOUT_ERROR_LEVEL ${setup_type_name}_install $packages || {
      local error=$?
      warn "Error installing $packages"
      return $error
    }
    printf "$packages" | tr ' ' '\n' | _write "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type/.${setup_type_name}"
  fi
  _call ${setup_type_name}_cleanup
  return 0
}
_setup_contains_subtype() {
  [ -z "$_SUB_PLATFORM" ] && return 1
  case $1 in
  *_*)
    return 0
    ;;
  esac
  return 1
}
_setup_sub_platform_matches() {
  local setup_type_sub_platform=${1##*_}
  setup_type_sub_platform=${setup_type_sub_platform%%.*}
  [ -z "$setup_type_sub_platform" ] && return 0
  [ "$setup_type_sub_platform" = "$_SUB_PLATFORM" ] && return 0
  return 1
}
_setup_run_do_bootstrap() {
  _setup_type_bootstrapped $1 || {
    _call ${1}_bootstrap
    _call ${1}_bootstrap_post
    export _BOOTSTRAP_${1}=1
    printf '_BOOTSTRAP_%s=1\n' "$1" | _install_metadata_write
  }
}
_setup_type_bootstrapped() {
  _variable_is_set _BOOTSTRAP_${1}
}
package_install_do() {
  _package_sync
  _sudo emerge $_EMERGE_OPTIONS $@
}
package_is_installed() {
  [ -f $_ROOT/var/lib/portage/world ] && {
    $_CONF_GNU_GREP -Pqm1 "^${1}$" $_ROOT/var/lib/portage/world && {
      return 0
    }
  }
  local package_group=$(printf '%s' $1 | cut -f1 -d/)
  local package_name=$(printf '%s' $1 | cut -f2 -d/)
  if [ -e $_ROOT/var/db/pkg/$package_group ]; then
    find $_ROOT/var/db/pkg/$package_group -type f | $_CONF_GNU_GREP -Pqm1 "/$package_name-[\d_\-\.]_.ebuild" && {
      return 0
    }
  fi
  return 1
}
_package_sync() {
  _EMERGE_SYNC_FILE=$_CONF_APPLICATION_DATA_PATH/emerge.sync.time
  _package_synced && {
    debug "portage was already synced today"
    return
  }
  _sudo mkdir -p $(dirname $_EMERGE_SYNC_FILE)
  info "syncing portage"
  _sudo emerge $_EMERGE_OPTIONS --sync && date +%s >$_EMERGE_SYNC_FILE
  info "synced portage"
}
_package_synced() {
  [ ! -e $_EMERGE_SYNC_FILE ] && return 1
  local last_synced=$(head -1 $_EMERGE_SYNC_FILE)
  local current_time=$(date +%s)
  [ $(($current_time - $last_synced)) -gt 86400 ] && return 1
  return 0
}
00_accept_keywords_bootstrap() {
  :
}
00_accept_keywords_install() {
  _gentoo_portage_install_file package.accept_keywords $1
}
00_accept_keywords_uninstall() {
  _gentoo_portage_uninstall_file package.accept_keywords $1
}
00_accept_keywords_is_installed() {
  _gentoo_portage_is_installed package.accept_keywords $1
}
00_accept_keywords_enabled() {
  return 0
}
00_accept_keywords_is_file() {
  return 0
}
00_license_bootstrap() {
  :
}
00_license_install() {
  _gentoo_portage_install_file package.license $1
}
00_license_uninstall() {
  _gentoo_portage_uninstall_file package.license $1
}
00_license_is_installed() {
  _gentoo_portage_is_installed package.license $1
}
00_license_enabled() {
  return 0
}
00_license_is_file() {
  return 0
}
00_mask_bootstrap() {
  :
}
00_mask_install() {
  _gentoo_portage_install_file package.mask $1
}
00_mask_uninstall() {
  _gentoo_portage_uninstall_file package.mask $1
}
00_mask_is_installed() {
  _gentoo_portage_is_installed package.mask $1
}
00_mask_enabled() {
  return 0
}
00_mask_is_file() {
  return 0
}
00_package_use_bootstrap() {
  :
}
00_package_use_install() {
  _gentoo_portage_install_file package.use $1
}
00_package_use_uninstall() {
  _gentoo_portage_uninstall_file package.use $1
}
00_package_use_is_installed() {
  _gentoo_portage_is_installed package.use $1
}
00_package_use_enabled() {
  return 0
}
00_package_use_is_file() {
  return 0
}
00_use_bootstrap() {
  :
}
00_use_install() {
  local name_suffix=$(_get_feature_name $1)
  printf '# app.%s%s\n' $_TARGET_APPLICATION_NAME "$name_suffix" | _sudo tee -a /etc/portage/make.conf >/dev/null 2>&1
  printf 'USE="$USE %s" # app.%s%s\n' "$(cat $1)" $_TARGET_APPLICATION_NAME "$name_suffix" | _sudo tee -a /etc/portage/make.conf >/dev/null 2>&1
}
00_use_uninstall() {
  local name_suffix=$(_get_feature_name $1)
  _sudo $_CONF_GNU_SED -i "s/ app.$_TARGET_APPLICATION_NAME${name_suffix}/ /" /etc/portage/make.conf
}
00_use_is_installed() {
  local name_suffix=$(_get_feature_name $1)
  grep -qm1 " # app.$_TARGET_APPLICATION_NAME${name_suffix}" /etc/portage/make.conf
}
00_use_enabled() {
  return 0
}
00_use_is_file() {
  return 0
}
_user_bootstrap() {
  _sudo mkdir -p /root/.ssh/socket
  _sudo chmod -R 700 /root/.ssh/socket
  app-install configuration
}
user_uninstall() {
  . "$1"
  _require "$username" "username"
  userdel $username
}
_users_add_argument() {
  if [ -n "$2" ]; then
    user_options="$user_options $1 $2"
  fi
}
_users_add() {
  . $1
  if [ "root" != "$username" ]; then
    _sudo pw user show $username >/dev/null 2>&1 || {
      info "### Add User: $1: $username"
      user_options="-m"
      _users_add_argument "-g" "$gid"
      _users_add_argument "-G" "$grouplist"
      _users_add_argument "-s" "$shell"
      _users_add_argument "-u" "$uid"
      _users_add_argument "-p" "$password"
      _sudo useradd $user_options $username
    }
  else
    info "# Setting shell to $shell for root"
    _sudo chsh -s "$shell"
    if [ -n "$password" ]; then
      info "# Setting root password"
      _sudo usermod -p "$password" $username
    fi
  fi
  _users_configure
  _users_cleanup
}
_users_cleanup() {
  unset user_options username gid grouplist shell uid password system
}
_users_configure() {
  local user_home=$(grep "^$username:" /etc/passwd | cut -f6 -d':')
  _prepare_ssh_conf $user_home $username
  local original_pwd=$PWD
  cd /tmp
  if [ -n "$system" ]; then
    warn "$username is a system user, bypassing configuration"
  else
    _WARN=1 _SUDO_USER=$username \
      sudo_options="--preserve-env=_CONF_GIT_MIRROR,_WARN,_LOG_TARGET,http_proxy,https_proxy,_PRESERVE_LOG -H" \
      _ _sudo conf restore || _user_configuredebug
  fi
  [ "root" != "$username" ] && {
    _sudo chown -R $username:$username $user_home
  }
  cd $original_pwd
}
_user_configuredebug() {
  warn "Error restoring configuration for $username"
  cat $user_home/.ssh/id_*.pub
  cat $user_home/.ssh/authorized_keys
  cat $user_home/.ssh/config
}
_get_feature_name() {
  case $1 in
  *feature*)
    printf '%s' "$1" | sed \
      -e 's/^.*\/feature\///' \
      -e 's/.feature\/.*//' \
      -e 's/^/./' \
      -e 's/\//./g'
    ;;
  *)
    printf ''
    ;;
  esac
}
_gentoo_portage_install_file() {
  _sudo mkdir -p /etc/portage/$1
  _sudo cp $2 /etc/portage/$1/app.$_TARGET_APPLICATION_NAME$(_get_feature_name $2)
}
_gentoo_portage_uninstall_file() {
  _sudo rm -f /etc/portage/$1/app.$_TARGET_APPLICATION_NAME$(_get_feature_name $2)
}
_gentoo_portage_is_installed() {
  [ -e /etc/portage/$1/app.$_TARGET_APPLICATION_NAME$(_get_feature_name $2) ]
}
_write() {
  _sudo tee -a "$1" >/dev/null
}
_crontab_get() {
  _require "$1" "Crontab User"
  _require "$2" "Crontab Filename to write to"
  _crontab_${_CONF_CRON_PROVIDER}_get "$@"
}
_crontab_write() {
  _require "$1" "Crontab User"
  _require_file "$2" "Crontab File"
  _crontab_${_CONF_CRON_PROVIDER}_write "$@"
}
_crontab_append() {
  _require "$1" "Crontab User"
  _require_file "$2" "Crontab File"
  _has_contents $2 || return 1
  local current_crontab=$(_SUDO_USER=$1 _mktemp)
  _crontab_get $1 $current_crontab
  _sudo cat $2 | _sudo tee -a $current_crontab >/dev/null 2>&1
  _crontab_${_CONF_CRON_PROVIDER}_write $1 $current_crontab
  _sudo rm -f $current_crontab
}
_require_file() {
  _require "$1" filename _require_file
  local level=error
  [ -n "$_WARN" ] && level=warn
  if [ ! -e $1 ]; then
    $level "File: $1 does not exist | $2"
    return 1
  fi
}
_has_contents() {
  _require_file "$1" "_has_contents:$1"
  [ $(_sudo wc -l < $1) -gt 0 ] && return 0
  return 1
}
_download() {
  mkdir -p $_CONF_CACHE_PATH
  local _cached_filename
  if [ $# -gt 1 ]; then
    _cached_filename="$2"
  else
    _cached_filename=$(basename $1 | sed -e 's/?.*$//')
  fi
  _DOWNLOADED_FILE=$_CONF_CACHE_PATH/$_cached_filename
  if [ -e $_DOWNLOADED_FILE ]; then
    detail "$1 already downloaded to: $_DOWNLOADED_FILE"
    return
  fi
  if [ -z "$_DOWNLOAD_DISABLED" ]; then
    info "Downloading $1 -> $_DOWNLOADED_FILE"
    curl $_CURL_OPTIONS -o $_DOWNLOADED_FILE -s -L "$1"
  else
    _continue_if "Please manually download: $1 and place it in $_DOWNLOADED_FILE" "Y/n"
  fi
}
_download_install_file() {
  _require "$1" "1 (_download_install_file) target filename"
  info "Installing $_DOWNLOADED_FILE -> $1"
  _sudo mkdir -p $(dirname $1)
  _sudo cp $_DOWNLOADED_FILE $1
  _sudo chmod 444 $1
  unset _DOWNLOADED_FILE
  [ ! -e $1 ] && return 1
  return 0
}
_prepare_ssh_conf() {
  _sudo mkdir -p $1/.ssh/socket
  _sudo chmod 700 $1/.ssh/socket
  printf 'StrictHostKeyChecking no\n' | _sudo tee -a $1/.ssh/config >/dev/null
  [ -n "$_HOST_IP" ] && _ssh_init_bastion_host $1
  if [ -e /tmp/HOST-SSH ]; then
    info "Copying host ssh -> $1/.ssh"
    _sudo cp /tmp/HOST-SSH/id* $1/.ssh
  fi
  if [ -e /tmp/CONFIG-WALTERJWHITE ]; then
    info "Copying walterjwhite conf -> $1/.config/walterjwhite"
    _sudo mkdir -p $1/.config
    _sudo cp -r /tmp/CONFIG-WALTERJWHITE $1/.config/walterjwhite
  fi
  [ "$2" != "root" ] && _sudo chown -R $2:$2 $1
}
_ssh_init_bastion_host() {
  info "Setting up SSH Bastion host: $1"
  printf 'Host host-proxy\n' | _sudo tee -a $1/.ssh/config >/dev/null
  printf ' Hostname %s\n' "$_HOST_IP" | _sudo tee -a $1/.ssh/config >/dev/null
  printf ' User root\n' | _sudo tee -a $1/.ssh/config >/dev/null
  printf 'Host git\n' | _sudo tee -a $1/.ssh/config >/dev/null
  printf ' ProxyJump host-proxy:%s\n' $_SSH_HOST_PORT | _sudo tee -a $1/.ssh/config >/dev/null
  printf ' User root\n' | _sudo tee -a $1/.ssh/config >/dev/null
  printf 'Host freebsd-package-cache\n' | _sudo tee -a $1/.ssh/config >/dev/null
  printf ' ProxyJump host-proxy:%s\n' $_SSH_HOST_PORT | _sudo tee -a $1/.ssh/config >/dev/null
  printf ' User root\n' | _sudo tee -a $1/.ssh/config >/dev/null
  printf 'Host %s\n' "$_PACKAGE_CACHE" | _sudo tee -a $1/.ssh/config >/dev/null
  printf ' ProxyJump host-proxy:%s\n' $_SSH_HOST_PORT | _sudo tee -a $1/.ssh/config >/dev/null
  printf ' User root\n' | _sudo tee -a $1/.ssh/config >/dev/null
  if [ "$_PACKAGE_CACHE" != "$_GIT_MIRROR" ]; then
    printf 'Host %s\n' "$_GIT_MIRROR" | _sudo tee -a $1/.ssh/config >/dev/null
    printf ' ProxyJump host-proxy\n' | _sudo tee -a $1/.ssh/config >/dev/null
    printf ' User root\n' | _sudo tee -a $1/.ssh/config >/dev/null
  fi
  _sudo chmod 600 $1/.ssh/config
}
_include beep context gentoo-installer logging net paths platform wait  
: ${_CONF_LOG_HEADER:="##################################################"}
: ${_CONF_LOG_C_ALRT:="1;31m"}
: ${_CONF_LOG_C_ERR:="1;31m"}
: ${_CONF_LOG_C_SCS:="1;32m"}
: ${_CONF_LOG_C_WRN:="1;33m"}
: ${_CONF_LOG_C_INFO:="1;36m"}
: ${_CONF_LOG_C_DETAIL:="1;0;36m"}
: ${_CONF_LOG_C_DEBUG:="1;35m"}
: ${_CONF_LOG_C_STDIN:="1;34m"}
: ${_CONF_LOG_DATE_FORMAT:="%Y/%m/%d|%H:%M:%S"}
: ${_CONF_LOG_DATE_TIME_FORMAT:="%Y/%m/%d %H:%M:%S"}
: ${_CONF_LOG_AUDIT:=0}
: ${_CONF_LOG_LEVEL:=2}
: ${_CONF_LOG_INDENT:="  "}
: ${_CONF_LOG_CONF_VALIDATION_FUNCTION:=warn}
: ${_CONF_LOG_WAITER_LEVEL:=debug}
: ${_CONF_LOG_FEATURE_TIMEOUT_ERROR_LEVEL:=warn}
: ${_CONF_LOG_LONG_RUNNING_CMD:=30}
: ${_CONF_LOG_LONG_RUNNING_CMD_LINES:=1000}
[ -t 0 ] && INTERACTIVE=1
: ${LIB:="beep.sh context.sh environment.sh exec.sh exit.sh help.sh include.sh logging.sh mktemp.sh platform.sh processes.sh stdin.sh syslog.sh sudo.sh wait.sh validation.sh net/mail.sh alert.sh"}
: ${CFG:="logging platform context wait beep paths net"}
: ${SUPPORTED_PLATFORMS:="Apple FreeBSD Linux Windows"}
: ${BUILD_PLATFORMS:="FreeBSD Linux Apple Windows"}
which pgrep >/dev/null 2>&1 && _PARENT_PROCESSES_FUNCTION=_parent_processes_pgrep
_DETECTED_PLATFORM=$(uname)
case $_DETECTED_PLATFORM in
	Darwin)
		_DETECTED_PLATFORM=Apple
		;;
	MINGW64_NT-*)
		_DETECTED_PLATFORM=Windows
		;;
esac
: ${_CONF_INSTALL_CONTEXT:=$_CONSOLE_CONTEXT_ID}
: ${_CONF_INSTALL_CONTEXT:=default}
: ${_CONF_WAIT_INTERVAL:=30}
: ${RSRC_BEEP:=/tmp/beep}
: ${_CONF_LOG_BEEP_TIMEOUT:=5}
: ${_CONF_LOG_BEEP_ERR:='L32c'}
: ${_CONF_LOG_BEEP_ALRT:='L32f'}
: ${_CONF_LOG_BEEP_SCS:='L32a'}
: ${_CONF_LOG_BEEP_WRN:=''}
: ${_CONF_LOG_BEEP_INFO:=''}
: ${_CONF_LOG_BEEP_DETAIL:=''}
: ${_CONF_LOG_BEEP_DEBUG:=''}
: ${_CONF_LOG_BEEP_STDIN:='L32ab'}
[ "$HOME" = "/" ] && HOME=/root
: ${_CONF_LIBRARY_PATH:=/usr/local/walterjwhite}
: ${_CONF_BIN_PATH:=/usr/local/bin}
_CONF_DATA_PATH=$HOME/.data
_CONF_CACHE_PATH=$_CONF_DATA_PATH/.cache
_CONF_CONFIG_PATH=$HOME/.config/walterjwhite
_CONF_RUN_PATH=/tmp/$USER/walterjwhite/app
_CONF_DATA_ARTIFACTS_PATH=$_CONF_DATA_PATH/install-v2/artifacts
_CONF_DATA_REGISTRY_PATH=$_CONF_DATA_PATH/install-v2/registry
_CONF_APPLICATION_DATA_PATH=$_CONF_DATA_PATH/$_APPLICATION_NAME
_CONF_APPLICATION_CONFIG_PATH=$_CONF_CONFIG_PATH/$_APPLICATION_NAME
_CONF_APPLICATION_LIBRARY_PATH=$_CONF_LIBRARY_PATH/$_APPLICATION_NAME
: ${_CONF_NETWORK_TEST_TIMEOUT:=5}
: ${_CONF_NETWORK_TEST_TARGETS:="http://connectivity-check.ubuntu.com http://example.org http://www.google.com http://telehack.com http://lxer.com"}
_REQUIRED_APP_CONF="_CONF_APP_REGISTRY_GIT_URL _CONF_CLEAN_APP_REGISTRY_WORKSPACE _CONF_GENTOO_INSTALLER_GIT_LUKS_URL _CONF_GENTOO_INSTALLER_GIT_URL _CONF_GENTOO_INSTALLER_SYSTEM_IDENTIFICATION _CONF_GNU_GREP _CONF_GNU_SED _CONF_INSTALL_CHECKSUM_CMD _CONF_LOG_SUDO_BEEP_TONE"
_sub_platform
case $_SUB_PLATFORM in
Alpine)
  _INSTALL_INSTALLER=apk
  _CONF_INSTALL_STAT_ARGUMENTS='-c %a'
  _CONF_GNU_GREP=ugrep
  _CONF_GNU_SED=sed
  _is_backgrounded() {
    :
  }
  REMOVE_UNUSED_FUNCTIONS=''
  ;;
Debian | Ubuntu)
  _INSTALL_INSTALLER=apt
  _CONF_GNU_GREP=grep
  _CONF_GNU_SED=sed
  ;;
Gentoo)
  _CONF_GNU_GREP=grep
  _CONF_GNU_SED=sed
  _PLATFORM_PACKAGES="app-eselect/eselect-repository app-portage/mirrorselect app-portage/cpuid2cpuflags sys-apps/pciutils sys-fs/dosfstools dev-vcs/git dev-tcltk/expect net-misc/curl dev-util/sh app-admin/sudo sys-apps/usbutils"
  _PLATFORM_PACKAGES_ACCEPT_KEYWORDS="dev-util/sh ~amd64"
  _NPM_PACKAGE="net-libs/nodejs"
  _RUST_PACKAGE="dev-lang/rust"
  _PYPI_PACKAGE="dev-lang/python"
  _GO_PACKAGE="dev-lang/go"
  _INSTALL_INSTALLER=emerge
  _CONF_INSTALL_STAT_ARGUMENTS='-c %a'
  ASSUME_ALWAYS_YES=yes
  : ${_EMERGE_OPTIONS:="-q --quiet-build --quiet-fail"}
  [ -n "$_ROOT" ] && [ "$_ROOT" != "/" ] && _EMERGE_OPTIONS="$_EMERGE_OPTIONS --root=$_ROOT"
  ;;
CentOS | RedHat)
  _CONF_GNU_GREP=grep
  _CONF_GNU_SED=sed
  _INSTALL_INSTALLER=yum
  ;;
*)
  error "Unknown Linux Distribution: $_SUB_PLATFORM"
  ;;
esac
_is_backgrounded && _BACKGROUNDED=1
_init_logging
unset _DEFERS _EXIT
_APPLICATION_START_TIME=$(date +%s)
_APPLICATION_CMD=$(basename $0)
trap _on_exit INT 0 1 2 3 4 6 15
for _ARG in "$@"; do
  case $_ARG in
  -conf-* | -[a-z0-9][a-z0-9][a-z0-9]*)
    _configuration_name=${_ARG#*-}
    _configuration_name=${_configuration_name%%=*}
    if [ $(printf '%s' "$_configuration_name" | grep -c '_') -eq 0 ]; then
      if [ $(printf '%s' "$_configuration_name" | grep -c '^conf') -gt 0 ]; then
        _configuration_name=$(printf '%s' "$_configuration_name" | sed -e "s/-/-$_APPLICATION_NAME-/")
      else
        _configuration_name=$(printf '%s' "$_configuration_name" | sed -e "s/^/$_APPLICATION_NAME-/")
      fi
    fi
    _configuration_name=$(printf '%s' $_configuration_name | tr '-' '_' | tr '[:lower:]' '[:upper:]')
    if [ $(printf '%s' "$_ARG" | grep -c '=') -eq 0 ]; then
      _configuration_value=1
    else
      _configuration_value=${_ARG#*=}
    fi
    export _$_configuration_name="$_configuration_value"
    unset _configuration_name
    shift
    ;;
  -h | --help)
    _print_help_and_exit
    ;;
  -w=*)
    _WAITER_PID="${1#*=}"
    shift
    ;;
  -w)
    _WAITEE=1
    shift
    ;;
  *)
    break
    ;;
  esac
done
for _REQUIRED_APP_CONF_ITEM in $_REQUIRED_APP_CONF; do
  _variable_is_set $_REQUIRED_APP_CONF_ITEM || {
    warn "$_REQUIRED_APP_CONF_ITEM is unset"
    _MISSING_REQUIRED_CONF=1
  }
done
[ -n "$_MISSING_REQUIRED_CONF" ] && error "Required configuration is missing, please refer to above error(s)"
if [ -z "$_CONTEXT_VALIDATED" ]; then
  _context_id_is_valid "$_CONF_INSTALL_CONTEXT"
  _CONTEXT_VALIDATED=0
fi
_APPLICATION_CONTEXT_GROUP=$_CONF_RUN_PATH/$_CONF_INSTALL_CONTEXT
_APPLICATION_CMD_DIR=$_APPLICATION_CONTEXT_GROUP/$_APPLICATION_NAME/$_APPLICATION_CMD
_waitee_init
_waiter
grep -qm1 container /proc/1/environ && error 'Detected container environment, will not provision a container within a container'
_set_logfile /var/log/gentoo-install-incus.log
GENTOO_SYSTEM_NAME=$(head -1 /usr/local/etc/walterjwhite/system)
_ _setup_git
_ _configure
_ _incus_live_start
_CONF_GENTOO_INSTALL_PATH=/ _incus_live_pre
for _INCUS_CONFIGURATION_FILE in $(find /tmp/gentoo -type f -name .incus | sort); do
  info "provisioning incus container: $_INCUS_CONFIGURATION_FILE"
  _incus_live "$_INCUS_CONFIGURATION_FILE"
done
