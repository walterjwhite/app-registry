#!/bin/sh
set -a
_APPLICATION_NAME=gentoo-installer
_beep() {
	[ ! -e /dev/speaker ] && return 1
	flock -n -w 0 $RSRC_BEEP printf '%s' "$1" >/dev/speaker || {
		debug "Another 'beep' is in progress"
		return 2
	}
}
_sudo_precmd() {
	_beep $_CONF_LOG_SUDO_BEEP_TONE
}
_context_id_is_valid() {
	printf '%s' "$1" | $_CONF_GNU_GREP -Pq '^[a-zA-Z0-9_+-]+$' || error "Context ID *MUST* only contain alphanumeric characters and +-: '^[a-zA-Z0-9_+-]+$' | ($1)"
}
_variable_is_set() {
	env | grep -cq "^$1=.*$"
}
_environment_filter() {
	$_CONF_GNU_GREP -P "(^_CONF_|^_OPTN_|^_INSTALL_|^${_TARGET_APPLICATION_NAME}_)"
}
_environment_dump() {
	[ -z "$_APPLICATION_PIPE_DIR" ] && return
	[ -z "$_ENVIRONMENT_FILE" ] && _ENVIRONMENT_FILE=$_APPLICATION_PIPE_DIR/environment
	mkdir -p $(dirname $_ENVIRONMENT_FILE)
	env | _environment_filter | sort -u | grep -v '^$' | sed -e 's/=/="/' -e 's/$/"/' >>$_ENVIRONMENT_FILE
}
_call() {
	local _function_name=$1
	type $_function_name >/dev/null 2>&1 || {
		debug "${_function_name} does not exist"
		return 255
	}
	[ $# -gt 1 ] && {
		shift
		$_function_name "$@"
		return $?
	}
	$_function_name
}
_() {
	if [ -n "$_EXEC_ATTEMPTS" ]; then
		local attempt=1
		while [ $attempt -le $_EXEC_ATTEMPTS ]; do
			_WARN_ON_ERROR=1 _do_exec "$@" && return
			attempt=$(($attempt + 1))
		done
		error "Failed after $attempt attempts: $*"
	fi
	_do_exec "$@"
}
_do_exec() {
	local _successfulExitStatus=0
	if [ -n "$_SUCCESSFUL_EXIT_STATUS" ]; then
		_successfulExitStatus=$_SUCCESSFUL_EXIT_STATUS
		unset _SUCCESSFUL_EXIT_STATUS
	fi
	info "## $*"
	if [ -z "$_DRY_RUN" ]; then
		if [ -n "$_CMD_LOGFILE" ]; then
			_exec_to_file "$_CMD_LOGFILE" "$@"
		else
			if [ -z "$_LOGFILE" ]; then
				"$@"
			else
				_exec_to_file "$_LOGFILE" "$@"
			fi
		fi
		local _exit_status=$?
		if [ $_exit_status -ne $_successfulExitStatus ]; then
			if [ -n "$_ON_FAILURE" ]; then
				$_ON_FAILURE
				return
			fi
			if [ -z "$_WARN_ON_ERROR" ]; then
				error "Previous cmd failed: $* - $_exit_status"
			else
				unset _WARN_ON_ERROR
				warn "Previous cmd failed: $* - $_exit_status"
				_ENVIRONMENT_FILE=$(_mktemp error) _environment_dump
				return $_exit_status
			fi
		fi
	fi
}
_exec_to_file() {
	local logfile=$1
	shift
	mkdir -p $(dirname $logfile)
	type $_function_name >/dev/null 2>&1 || {
		"$@" >>$logfile 2>>$logfile
		return $?
	}
	"$@"
}
error() {
	if [ $# -ge 2 ]; then
		_EXIT_STATUS=$2
	else
		_EXIT_STATUS=1
	fi
	_EXIT_LOG_LEVEL=4
	_EXIT_STATUS_CODE="ERR"
	_EXIT_COLOR_CODE="$_CONF_LOG_C_ERR"
	_EXIT_MESSAGE="$1 ($_EXIT_STATUS)"
	_EXIT_BEEP=$_CONF_LOG_BEEP_ERR
	_defer _environment_dump
	_defer _log_app_exit
	exit $_EXIT_STATUS
}
_success() {
	_EXIT_STATUS=0
	_EXIT_LOG_LEVEL=1
	_EXIT_STATUS_CODE="SCS"
	_EXIT_COLOR_CODE="$_CONF_LOG_C_SCS"
	_EXIT_MESSAGE="$1"
	_EXIT_BEEP=$_CONF_LOG_BEEP_SCS
	_defer _long_running_cmd
	_defer _log_app_exit
	[ -z "$_EXIT" ] && exit 0
}
_on_exit() {
	[ $_EXIT ] && return 1
	_EXIT=0
	[ -z "$_EXIT_STATUS" ] && _success "completed successfully"
	if [ -n "$_DEFERS" ]; then
		local defer
		for defer in $_DEFERS; do
			_call $defer
		done
		unset _DEFERS
	fi
	return $_EXIT
}
_defer() {
	if [ -n "$_DEFERS" ]; then
		local defer
		for defer in $_DEFERS; do
			[ "$defer" = "$1" ] && {
				debug "not deferring: $1 as it was already deferred"
				return
			}
		done
	fi
	debug "deferring: $1"
	_DEFERS="$1 $_DEFERS"
}
_log_app_exit() {
	[ "$_EXIT_MESSAGE" ] && {
		local current_time=$(date +%s)
		local timeout=$(($_APPLICATION_START_TIME + $_CONF_LOG_BEEP_TIMEOUT))
		[ $current_time -le $timeout ] && unset _EXIT_BEEP
		_print_log $_EXIT_LOG_LEVEL "$_EXIT_STATUS_CODE" "$_EXIT_COLOR_CODE" "$_EXIT_BEEP" "$_EXIT_MESSAGE"
	}
	_log_app exit
	[ -n "$_LOGFILE" ] && [ -n "$_OPTN_LOG_EXIT_CMD" ] && {
		$_OPTN_LOG_EXIT_CMD -file $_LOGFILE
	}
}
_print_help() {
	if [ -e $2 ]; then
		info "$1:"
		cat $2
		printf '\n'
	fi
}
_print_help_and_exit() {
	_print_help 'system-wide options' $_CONF_LIBRARY_PATH/install/help/default
	if [ "$_APPLICATION_NAME" != "install" ]; then
		_print_help $_APPLICATION_NAME $_CONF_LIBRARY_PATH/$_APPLICATION_NAME/help/default
		_print_help "$_APPLICATION_NAME/$_APPLICATION_CMD" $_CONF_LIBRARY_PATH/$_APPLICATION_NAME/help/$_APPLICATION_CMD
	fi
	exit 0
}
_include() {
	local include_file
	for include_file in "$@"; do
		[ -f $HOME/.config/walterjwhite/$include_file ] && . $HOME/.config/walterjwhite/$include_file
	done
}
_init_logging() {
	[ -n "$_LOGFILE" ] && _set_logfile "$_LOGFILE"
	case $_CONF_LOG_LEVEL in
	0)
		local logfile=$(_mktemp debug)
		warn "Writing debug contents to: $logfile"
		_set_logfile "$logfile"
		set -x
		;;
	esac
}
_set_logfile() {
	[ -z "$1" ] && return 1
	_LOGFILE=$1
	mkdir -p $(dirname $1)
	_reset_indent
	[ -n "$_CHILD_LOG" ] || exec 3>&1 4>&2
	exec >>$_LOGFILE 2>&1
	[ -z "$_PRESERVE_LOG" ] && [ -z "$_CHILD_LOG" ] && truncate -s 0 $1 >/dev/null 2>&1
}
warn() {
	_print_log 3 WRN "$_CONF_LOG_C_WRN" "$_CONF_LOG_BEEP_WRN" "$1"
}
info() {
	_print_log 2 INF "$_CONF_LOG_C_INFO" "$_CONF_LOG_BEEP_INFO" "$1"
}
detail() {
	_print_log 2 DTL "$_CONF_LOG_C_DETAIL" "$_CONF_LOG_BEEP_DETAIL" "$1"
}
debug() {
	_print_log 1 DBG "$_CONF_LOG_C_DEBUG" "$_CONF_LOG_BEEP_DEBUG" "($$) $1"
}
_log() {
	:
}
_sed_remove_nonprintable_characters() {
	sed -e 's/[^[:print:]]//g'
}
_print_log() {
	if [ -z "$5" ]; then
		if test ! -t 0; then
			local _line
			cat - | _sed_remove_nonprintable_characters |
				while read _line; do
					_print_log $1 $2 $3 $4 "$_line"
				done
			return
		fi
		return
	fi
	local message="$5"
	[ $1 -lt $_CONF_LOG_LEVEL ] && return
	[ -n "$_LOGGING_CONTEXT" ] && message="$_LOGGING_CONTEXT - $message"
	local _message_date_time=$(date +"$_CONF_LOG_DATE_FORMAT")
	if [ $_BACKGROUNDED ] && [ $_OPTN_INSTALL_BACKGROUND_NOTIFICATION_METHOD ]; then
		$_OPTN_INSTALL_BACKGROUND_NOTIFICATION_METHOD "$2" "$_message" &
	fi
	[ -n "$4" ] && _beep "$4"
	_log_to_file "$2" "$_message_date_time" "${_LOG_INDENT}$message"
	_log_to_console "$3" "$2" "$_message_date_time" "${_LOG_INDENT}$message"
	[ -z "$INTERACTIVE" ] && _syslog "$message"
	return 0
}
_reset_indent() {
	unset _LOG_INDENT
}
_log_to_file() {
	[ -z "$_LOGFILE" ] && return
	if [ $_CONF_LOG_AUDIT -gt 0 ]; then
		printf '%s %s %s\n' "$1" "$2" "$3" >>$_LOGFILE
		return
	fi
	printf '%s\n' "$3" >>$_LOGFILE
}
_log_to_console() {
	local stderr=2
	[ ! -t $stderr ] && stderr=4
	[ ! -t $stderr ] && return
	if [ $_CONF_LOG_AUDIT -gt 0 ]; then
		printf >&$stderr '\033[%s%s \033[0m%s %s\n' "$1" "$2" "$3" "$4"
		return
	fi
	printf >&$stderr '\033[%s%s \033[0m\n' "$1" "$4"
}
_log_app() {
	debug "$_APPLICATION_NAME:$_APPLICATION_CMD - $1 ($$)"
}
_mktemp() {
	local suffix=$1
	[ -n "$suffix" ] && suffix=".$suffix"
	local sudo_prefix
	[ -n "$_SUDO_USER" ] && sudo_prefix=_sudo
	$sudo_prefix mktemp -${_MKTEMP_OPTIONS}t ${_APPLICATION_NAME}.${_APPLICATION_CMD}${suffix}.XXXXXXXX
}
_sub_platform() {
	which lsb_release >/dev/null 2>&1 && {
		_SUB_PLATFORM=$(lsb_release -a | grep ID | cut -f2 -d: | tr -d '\t')
		return
	}
	[ -e $_ROOT/etc/os-release ] && {
		_SUB_PLATFORM=$(grep ^NAME= $_ROOT/etc/os-release | cut -f2 -d= | sed -e 's/"//g' -e 's/ Linux//')
	}
	[ -e $_ROOT/etc/gentoo-release ] && _SUB_PLATFORM=Gentoo
}
_setup_app_pipe() {
	_APPLICATION_PIPE=$_APPLICATION_CMD_DIR/$$
	_APPLICATION_PIPE_DIR=$(dirname $_APPLICATION_PIPE)
	mkdir -p $_APPLICATION_PIPE_DIR
	mkfifo $_APPLICATION_PIPE
	_defer _cleanup_app_pipe
}
_cleanup_app_pipe() {
	rm -f $_APPLICATION_PIPE
}
_kill_all() {
	_do_kill_all $_APPLICATION_PIPE_DIR
}
_kill_all_group() {
	_do_kill_all $_APPLICATION_CONTEXT_GROUP
}
_do_kill_all() {
	for _EXISTING_APPLICATION_PIPE in $(find $1 -type p -not -name $$); do
		_kill $(basename $_EXISTING_APPLICATION_PIPE)
	done
}
_kill() {
	warn "Killing $1"
	kill -TERM $1
}
_list() {
	_list_pidinfos $_APPLICATION_PIPE_DIR
}
_list_group() {
	_list_pidinfos $_APPLICATION_CONTEXT_GROUP
}
_list_pidinfos() {
	info "Running processes:"
	_EXECUTABLE_NAME_SED_SAFE=$(_sed_safe $0)
	for _EXISTING_APPLICATION_PIPE in $(find $1 -type p -not -name $$); do
		_list_pidinfo
	done
}
_parent_processes_pgrep() {
	pgrep -P $1
}
_is_backgrounded() {
	case $(ps -o stat= -p $$) in
	*+*)
		return 1
		;;
	esac
	return 0
}
_list_pidinfo() {
	_TARGET_PID=$(basename $_EXISTING_APPLICATION_PIPE)
	_TARGET_PS_DTL=$(ps -o command -p $_TARGET_PID | sed 1d | sed -e "s/^.*$_EXECUTABLE_NAME_SED_SAFE/$_EXECUTABLE_NAME_SED_SAFE/")
	info " $_TARGET_PID - $_TARGET_PS_DTL"
}
_interactive_alert_if() {
	_is_interactive_alert_enabled && _interactive_alert "$@"
}
_is_interactive_alert_enabled() {
	grep -cq '^_OPTN_INSTALL_INTERACTIVE_ALERT=1$' $_CONF_APPLICATION_CONFIG_PATH 2>/dev/null
}
_continue_if() {
	_read_if "$1" _PROCEED "$2"
	local proceed="$_PROCEED"
	unset _PROCEED
	if [ -z "$proceed" ]; then
		_DEFAULT=$(printf '%s' $2 | awk -F'/' {'print$1'})
		proceed=$_DEFAULT
	fi
	local proceed=$(printf '%s' "$proceed" | tr '[:lower:]' '[:upper:]')
	if [ $proceed = "N" ]; then
		return 1
	fi
	return 0
}
_read_if() {
	if [ $(env | grep -c "^$2=.*") -eq 1 ]; then
		debug "$2 is already set"
		return 1
	fi
	[ -z "$INTERACTIVE" ] && error "Running in non-interactive mode and user input was requested: $@" 10
	_print_log 9 STDI "$_CONF_LOG_C_STDIN" "$_CONF_LOG_BEEP_STDIN" "$1 $3"
	_interactive_alert_if $1 $3
	read -r $2
}
_syslog() {
	logger -i -t "$_APPLICATION_NAME.$_APPLICATION_CMD" "$1"
}
_sudo() {
	[ $# -eq 0 ] && error 'No arguments were provided to _sudo'
	_require "$_SUDO_CMD" _SUDO_CMD
	_sudo_is_required || {
		"$@"
		return
	}
	[ -n "$INTERACTIVE" ] && {
		$_SUDO_CMD -n ls >/dev/null 2>&1 || _sudo_precmd "$@"
	}
	$_SUDO_CMD $sudo_options "$@"
	unset sudo_options
}
_sudo_is_required() {
	[ -n "$_SUDO_USER" ] && {
		[ "$_SUDO_USER" = "$USER" ] && return 1
		sudo_options="$sudo_options -u $_SUDO_USER"
		return 0
	}
	[ "$USER" = "root" ] && return 1
	return 0
}
_is_root() {
	[ "$EUID" -ne 0 ] && return 1
	return 0
}
_waitee_init() {
	[ -z "$_WAITEE" ] && return
	_setup_app_pipe
	warn "($_APPLICATION_CMD) Please use -w=$$"
	_defer _waitee_done
}
_waitee_done() {
	if [ -n "$_WAITEE" ] && [ -e $_APPLICATION_PIPE ]; then
		info "$0 process completed, notifying ($_EXIT_STATUS)"
		printf '%s\n' "$_EXIT_STATUS" >$_APPLICATION_PIPE
		info "$0 downstream process picked up"
	fi
}
_waiter() {
	[ -z "$_WAITER_PID" ] && return
	_UPSTREAM_APPLICATION_PIPE=$(find $_APPLICATION_CONTEXT_GROUP -type p -name $_WAITER_PID 2>/dev/null | head -1)
	[ -z "$_UPSTREAM_APPLICATION_PIPE" ] && error "$_WAITER_PID not found"
	[ ! -e $_UPSTREAM_APPLICATION_PIPE ] && {
		warn "$_UPSTREAM_APPLICATION_PIPE does not exist, did upstream start?"
		return
	}
	info "Waiting for upstream to complete: $_WAITER_PID"
	while [ 1 ]; do
		if [ ! -e $_UPSTREAM_APPLICATION_PIPE ]; then
			error "Upstream pipe no longer exists"
		fi
		_UPSTREAM_APPLICATION_STATUS=$(_timeout $_CONF_WAIT_INTERVAL "_waiter:upstream" cat $_UPSTREAM_APPLICATION_PIPE 2>/dev/null)
		local _UPSTREAM_STATUS=$?
		if [ $_UPSTREAM_STATUS -eq 0 ]; then
			if [ -z "$_UPSTREAM_APPLICATION_STATUS" ] || [ $_UPSTREAM_APPLICATION_STATUS -gt 0 ]; then
				error "Upstream exited with error ($_UPSTREAM_APPLICATION_STATUS)"
			fi
			warn "Upstream finished: $_UPSTREAM_APPLICATION_PIPE ($_UPSTREAM_STATUS)"
			break
		fi
		detail " Upstream is still running: $_UPSTREAM_APPLICATION_PIPE ($_UPSTREAM_STATUS)"
		sleep 1
	done
}
_require() {
	local level=error
	if [ -z "$1" ]; then
		[ -n "$_WARN" ] && level=warn
		$level "$2 required $_REQUIRE_DETAILED_MESSAGE" $3
		return 1
	fi
	unset _REQUIRE_DETAILED_MESSAGE
}
_value_in() {
	local level=error
	[ -n "$_WARN" ] && level=warn
	printf '%s\n' "$1" | $_CONF_GNU_GREP -Pcq "^($2)$" || $level "$1 is not in ^($2)$"
}
_mail() {
	if [ $# -lt 3 ]; then
		warn "recipients[0], subject[1], message[2] is required - $# arguments provided"
		return 1
	fi
	local recipients=$(printf '%s' "$1" | tr '|' ' ')
	shift
	local subject="$1"
	shift
	local message="$1"
	shift
	printf "$message" | mail -s "$subject" $recipients
}
_alert() {
	_print_log 5 ALRT "$_CONF_LOG_C_ALRT" "$_CONF_LOG_BEEP_ALRT" "$1"
	local recipients="$_OPTN_LOG_ALERT_RECIPIENTS"
	local subject="Alert: $0 - $1"
	if [ -z "$recipients" ]; then
		warn "recipients is empty, aborting"
		return 1
	fi
	_mail "$recipients" "$subject" "$2"
}
_long_running_cmd() {
	[ -n "$_OPTN_DISABLE_LONG_RUNNING_CMD_NOTIFICATION" ] && return
	_APPLICATION_END_TIME=$(date +%s)
	_APPLICATION_RUNTIME=$(($_APPLICATION_END_TIME - $_APPLICATION_START_TIME))
	[ $_APPLICATION_RUNTIME -lt $_CONF_LOG_LONG_RUNNING_CMD ] && return
	local subject="[$_APPLICATION_NAME] - $_EXIT_MESSAGE - ($_EXIT_STATUS)"
	local message=""
	if [ -n "$_LOGFILE" ]; then
		message=$(tail -$_CONF_LOG_LONG_RUNNING_CMD_LINES $_LOGFILE)
	fi
	_alert "$subject" "$message"
}
_file() {
	[ ! -e $1/file ] && {
		warn 'No files to extract'
		return
	}
	tar cp -C $1/file | tar xp -C /
}
_import_gentoo_gpg_keys() {
	gpg --import /usr/share/openpgp-keys/gentoo-release.asc
	_defer _gpg_kill
}
_gpg_verify() {
	_require "$1" "File to verify with GPG"
	local gpg_output=$(gpg --verify "$1" 2>&1)
	local gpg_status=$?
	[ $gpg_status -gt 0 ] && {
		error "$gpg_output" $gpg_status
	}
	detail "GPG verification completed"
}
_gpg_kill() {
	killall gpg-agent
	killall keyboxd
}
_ZFS_RCLONE_PACKAGE=rclone
_ZFS_ZAP_PACKAGE=zap
_prepare_chroot() {
	cp -R /tmp/gentoo $_CONF_GENTOO_INSTALL_PATH/tmp
	rm -rf $_CONF_GENTOO_INSTALL_PATH/root/.config && mkdir -p $_CONF_GENTOO_INSTALL_PATH/root/.config
	cp -R /root/.config/walterjwhite $_CONF_GENTOO_INSTALL_PATH/root/.config
	mkdir -p $_CONF_GENTOO_INSTALL_PATH/root/.ssh
	cp /root/.ssh/id* \
		/root/.ssh/authorized_keys \
		/root/.ssh/known_hosts \
		$_CONF_GENTOO_INSTALL_PATH/root/.ssh
	cp -R /root/.ssh $_CONF_GENTOO_INSTALL_PATH/tmp/HOST-SSH
	cp -R /root/.config/walterjwhite $_CONF_GENTOO_INSTALL_PATH/tmp/CONFIG-WALTERJWHITE
	mkdir -p $_CONF_GENTOO_INSTALL_PATH/root/.ssh/socket
	mkdir -p $_CONF_GENTOO_INSTALL_PATH/$_CONF_BIN_PATH
	cp $_CONF_BIN_PATH/* $_CONF_GENTOO_INSTALL_PATH/$_CONF_BIN_PATH
	[ "$_APPLICATION_CMD" = "gentoo-incus" ] && return 0
	info "$_APPLICATION_CMD - preparing chroot"
	cp /etc/resolv.conf $_CONF_GENTOO_INSTALL_PATH/etc
	[ -e /etc/hostid ] && cp /etc/hostid $_CONF_GENTOO_INSTALL_PATH/etc
	return 0
}
_portage_write_package_license() {
	mkdir -p $_CONF_GENTOO_INSTALL_PATH/etc/portage/package.license
	printf '\n\nACCEPT_LICENSE="-* %s"\n' "$GENTOO_SOFTWARE_LICENSE" >>$_CONF_GENTOO_INSTALL_PATH/etc/portage/make.conf
}
_portage_system_use_flags() {
	printf '# system use flags\n' >>$_CONF_GENTOO_INSTALL_PATH/etc/portage/make.conf
	find . -type f -path '*/system/use' -exec $_CONF_GNU_GREP -Pvh '(^$|^#)' {} + |
		tr '\n' ' ' |
		sed -e 's/^/USE="$USE /' -e 's/$/"\n\n/' >>$_CONF_GENTOO_INSTALL_PATH/etc/portage/make.conf
}
_gentoo_cleanup_install() {
	warn "Attempting to cleanup previous installs ..."
	_WARN_ON_ERROR=1 _ _gpg_kill
	_ _gentoo_cleanup_tail
	_ _gentoo_cleanup_mounts
	_ _gentoo_export_zfs_pools
	_ _gentoo_cleanup_luks
}
_gentoo_cleanup_tail() {
	ps aux | grep tail | grep -qm1 $_CONF_GENTOO_INSTALL_PATH || return 0
	kill -9 $(ps aux | grep tail | grep $_CONF_GENTOO_INSTALL_PATH | awk {'print$2'})
	return 0
}
_gentoo_cleanup_mounts() {
	mount | grep -qm1 " on $_CONF_GENTOO_INSTALL_PATH" || return 0
	umount -fl $(mount | grep " on $_CONF_GENTOO_INSTALL_PATH" | awk {'print$3'} | sort -r)
	mount | grep -qm1 $_CONF_GENTOO_INSTALL_PATH && error "Unable to unmount all volumes, please check"
	return 0
}
_gentoo_export_zfs_pools() {
	local zpool=$(zfs list -H | grep ${_CONF_GENTOO_INSTALL_PATH}$ | awk {'print$1'} | sed -e 's/\/.*$//')
	[ -z "$zpool" ] && {
		detail "No ZFS pools to export"
		return 0
	}
	zpool export -f $zpool
}
_gentoo_cleanup_luks() {
	[ -e /dev/mapper/gentoo ] && {
		cryptsetup luksClose gentoo
		return
	}
	return 0
}
_configure() {
	_configure_system .
	_configure_patches
}
_configure_system() {
	[ -e $1/system/conf ] && . $1/system/conf
	[ -n "$GENTOO_SYSTEM_IMPORTS" ] && {
		local system_import
		for system_import in $GENTOO_SYSTEM_IMPORTS; do
			[ -e $system_import/system/conf ] && . $system_import/system/conf
		done
	}
}
_configure_patches() {
	local configuration_script patch_path
	for configuration_script in $(find . -type f -path '*/.patch/configure'); do
		patch_path=$(dirname $configuration_script)
		$configuration_script || {
			warn "$configuration_script [$?], disabling patch"
			rm -rf $patch_path
			continue
		}
		detail "Keeping $patch_path"
	done
}
_setup_disks() {
	_setup_disks_get_id
	sgdisk -Z ${GENTOO_DISK_DEVICE}
	sgdisk -g ${GENTOO_DISK_DEVICE}
	sgdisk -n 1:0:+1G -t 1:ef00 ${GENTOO_DISK_DEVICE}
	sgdisk -n 2:+1G:0 -t 1:8300 ${GENTOO_DISK_DEVICE}
	sgdisk -b /tmp/disk.sgdisk ${GENTOO_DISK_DEVICE}
	partprobe
	_setup_disks_efi
	mkfs.vfat -F 32 ${GENTOO_DISK_DEVICE_EFI_PARTITION}
	_setup_disks_luks
	_setup_disks_zfs
}
_setup_disks_efi() {
	GENTOO_DISK_DEVICE_BOOT_PARTITION_ID=1
	GENTOO_DISK_DEVICE_EFI_PARTITION=${GENTOO_DISK_DEVICE}${GENTOO_DISK_DEVICE_PARTITION_PREFIX}$GENTOO_DISK_DEVICE_BOOT_PARTITION_ID
}
_setup_disks_get_id() {
	case $GENTOO_DISK_DEVICE in
	/dev/nvme*)
		warn "NVMe drive detected, prefixing partitions with 'p'"
		GENTOO_DISK_DEVICE_PARTITION_PREFIX=p
		;;
	esac
	GENTOO_DISK_ID=$(smartctl -i $GENTOO_DISK_DEVICE | grep 'Serial Number' | awk {'print$3'})
	GENTOO_DISK_LABEL=$(printf '%s\n' $GENTOO_DISK_MAP | tr ' ' '\n' | grep "$GENTOO_DISK_ID" | cut -f2 -d:)
	[ -z "$GENTOO_DISK_LABEL" ] && error "No matching disk found"
}
_setup_disks_luks() {
	[ -z "$GENTOO_LUKS_PASSPHRASE" ] && {
		warn "GENTOO_LUKS_PASSPHRASE is unset, unable to setup LUKS"
		return
	}
	[ -e /dev/mapper/gentoo ] && error '/dev/mapper/gentoo already exists'
	_setup_disks_luks_get_device
	printf '%s\n' "$GENTOO_LUKS_PASSPHRASE" | cryptsetup luksFormat --batch-mode -c $GENTOO_LUKS_CIPHER -s $GENTOO_LUKS_KEY_SIZE --hash $GENTOO_LUKS_HASH $GENTOO_DISK_DEVICE_LUKS
	_setup_disks_luks_open
	_defer _setup_disks_luks_close
	_setup_disks_luks_backup
}
_setup_disks_luks_get_device() {
	GENTOO_DISK_DEVICE_LUKS_PARTITION_ID=2
	GENTOO_DISK_DEVICE_LUKS=${GENTOO_DISK_DEVICE}${GENTOO_DISK_DEVICE_PARTITION_PREFIX}$GENTOO_DISK_DEVICE_LUKS_PARTITION_ID
}
_setup_disks_luks_open() {
	printf '%s\n' "$GENTOO_LUKS_PASSPHRASE" | cryptsetup luksOpen $GENTOO_DISK_DEVICE_LUKS gentoo
}
_setup_disks_luks_close() {
	cryptsetup luksClose gentoo
}
_setup_disks_luks_backup() {
	git clone $_CONF_GENTOO_INSTALLER_GIT_LUKS_URL /tmp/luks || error "Unable to clone $_CONF_GENTOO_INSTALLER_GIT_LUKS_URL"
	local opwd=$PWD
	cd /tmp/luks
	mkdir -p $GENTOO_DISK_ID/activity
	_setup_disks_luks_header_backup
	_setup_disks_luks_smartctl_backup
	git config --global user.email "$(whoami)@$(hostname)"
	git config --global user.name "$(whoami)@$(hostname)"
	git add $GENTOO_DISK_ID
	git commit $GENTOO_DISK_ID -m "Backup $GENTOO_DISK_ID"
	git push
	cd $opwd
	rm -rf /tmp/luks
}
_setup_disks_luks_header_backup() {
	cryptsetup luksHeaderBackup $GENTOO_DISK_DEVICE_LUKS --header-backup-file=$GENTOO_DISK_ID/luks
}
_setup_disks_luks_smartctl_backup() {
	local drive_smart_activity_file=$GENTOO_DISK_ID/activity/$(date +%Y/%m/%d-%H.%M.%S)
	mkdir -p $(dirname $drive_smart_activity_file)
	smartctl -a ${GENTOO_DISK_DEVICE} |
		$_CONF_GNU_GREP -P '^[\s]*[\d]+ [\w_-]{3,}' \
			>$drive_smart_activity_file
}
_setup_disks_zfs() {
	GENTOO_ZFS_POOL_NAME=z_$GENTOO_DISK_LABEL
	info "Creating $GENTOO_ZFS_POOL_NAME on $GENTOO_DISK_DEVICE"
	zpool create -f -o ashift=12 -o autotrim=on -O acltype=posixacl -O xattr=sa -O relatime=on -O compression=zstd -m none $GENTOO_ZFS_POOL_NAME /dev/mapper/gentoo
	zpool export $GENTOO_ZFS_POOL_NAME
	_setup_disks_zfs_import
	_defer _zpool_export
	_setup_disks_zfs_create_datasets
}
_setup_disks_zfs_import() {
	[ -z "$GENTOO_ZFS_POOL_NAME" ] && GENTOO_ZFS_POOL_NAME=z_$GENTOO_DISK_LABEL
	zpool import -NR $_CONF_GENTOO_INSTALL_PATH $GENTOO_ZFS_POOL_NAME
}
_setup_disks_zfs_create_datasets() {
	zfs create \
		-o mountpoint=/ \
		-o canmount=noauto \
		$GENTOO_ZFS_POOL_NAME/gentoo
	zpool set bootfs=$GENTOO_ZFS_POOL_NAME/gentoo $GENTOO_ZFS_POOL_NAME
	zfs mount $GENTOO_ZFS_POOL_NAME/gentoo
	zfs create \
		-o setuid=off \
		-o mountpoint=/home \
		$GENTOO_ZFS_POOL_NAME/home
	zfs create \
		-o exec=on \
		-o setuid=off \
		-o mountpoint=/tmp \
		$GENTOO_ZFS_POOL_NAME/tmp
	zfs create -p \
		-o exec=off \
		-o setuid=off \
		-o mountpoint=/var/log \
		$GENTOO_ZFS_POOL_NAME/var/log
	zfs create -p \
		-o exec=on \
		-o setuid=off \
		-o mountpoint=/usr/src \
		$GENTOO_ZFS_POOL_NAME/usr/src
	zfs create -p \
		-o exec=off \
		-o setuid=off \
		-o mountpoint=/var/db/repos/gentoo \
		$GENTOO_ZFS_POOL_NAME/var/db/repos/gentoo
	zfs create -p \
		-o exec=off \
		-o setuid=off \
		-o mountpoint=/var/cache/distfiles \
		$GENTOO_ZFS_POOL_NAME/var/cache/distfiles
	zfs create -p \
		-o setuid=off \
		-o mountpoint=/var/tmp/portage \
		$GENTOO_ZFS_POOL_NAME/var/tmp/portage
	udevadm trigger
	zgenhostid -f
}
_zpool_export() {
	zpool export $GENTOO_ZFS_POOL_NAME
}
_setup_git() {
	rm -rf $GENTOO_REPOSITORY_PREFIX/tmp/gentoo
	_setup_git_clone $GENTOO_SYSTEM_NAME $GENTOO_REPOSITORY_PREFIX/tmp/gentoo
	cd $GENTOO_REPOSITORY_PREFIX/tmp/gentoo
}
_setup_git_clone() {
	mkdir -p $2
	git archive --remote $_CONF_GENTOO_INSTALLER_GIT_URL $1 | tar xp -C $2 || {
		ping -c1 git >/dev/null 2>&1 || warn "Unable to ping git"
		ping -c1 google.com >/dev/null 2>&1 || warn "Unable to ping google"
		error "Error setting up git $_CONF_GENTOO_INSTALLER_GIT_URL [$*]"
	}
	cd $2
	[ -e .import ] || {
		detail "No imports detected - $2"
		return
	}
	detail "Setting up import"
	local git_import_contents=$(head -1 .import)
	GENTOO_SYSTEM_IMPORTS="$GENTOO_SYSTEM_IMPORTS imports/$git_import_contents"
	_setup_git_clone $git_import_contents $GENTOO_REPOSITORY_PREFIX/tmp/gentoo/imports/$git_import_contents
}
_hardware() {
	_write_cpu_flags
	[ -z "$GENTOO_VIDEO_CARDS" ] && _get_video_cards
	_write_video_cards
	_makeopts
}
_makeopts() {
	local system_memory=$(free -g | awk '/^Mem:/{print $2}')
	local allowed_jobs=$(($system_memory / 2))
	local load_average=$(($allowed_jobs + 1))
	printf '# @see: https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Stage#MAKEOPTS\n' >>$_CONF_GENTOO_INSTALL_PATH/etc/portage/make.conf
	printf 'MAKEOPTS="-j%s -l%s"\n' $allowed_jobs $load_average >>$_CONF_GENTOO_INSTALL_PATH/etc/portage/make.conf
}
_setup_system_architecture() {
	local system_architecture=$(lscpu | grep Architecture | awk {'print$2'})
	case $system_architecture in
	x86_64)
		GENTOO_CPU_ARCHITECTURE=amd64
		;;
	*)
		error "Unsupported architecture: $system_architecture"
		;;
	esac
	local cpu_vendor=$(lscpu | grep '^Vendor ID:' | awk {'print$3'})
	case $cpu_vendor in
	*Intel*)
		GENTOO_CPU_VENDOR=Intel
		;;
	*AMD*)
		GENTOO_CPU_VENDOR=AMD
		;;
	*)
		error "Unsupported CPU $cpu_vendor"
		;;
	esac
}
_get_video_cards() {
	oIFS="$IFS"
	IFS=$'\n'
	local lspci_line
	local video_api="vulkan"
	for lspci_line in $(lspci | $_CONF_GNU_GREP -Pi '(VGA compatible controller|Display controller)'); do
		case $lspci_line in
		*AMD/ATI*)
			GENTOO_VIDEO_CARDS="$GENTOO_VIDEO_CARDS radeon radeonsi"
			mkdir -p $_CONF_GENTOO_INSTALL_PATH/etc/portage/package.use
			printf 'x11-libs/libdrm video_cards_amdgpu\n' >>$_CONF_GENTOO_INSTALL_PATH/etc/portage/package.use/amdgpu
			;;
		*Intel\ Corporation*)
			GENTOO_VIDEO_CARDS="$GENTOO_VIDEO_CARDS intel"
			;;
		*Intel\ Corporation*)
			GENTOO_VIDEO_CARDS="$GENTOO_VIDEO_CARDS intel"
			;;
		*NVIDIA\ Corporation*)
			case $lspci_line in
			*K3100M*)
				GENTOO_VIDEO_CARDS="$GENTOO_VIDEO_CARDS nouveau"
				video_api="$video_api vaapi"
				;;
			*)
				if [ -n "$GENTOO_PROPRIETARY_NVIDIA" ]; then
					GENTOO_VIDEO_CARDS="$GENTOO_VIDEO_CARDS nvidia"
				else
					GENTOO_VIDEO_CARDS="$GENTOO_VIDEO_CARDS nouveau"
					video_api="$video_api vaapi"
				fi
				;;
			esac
			video_api="$video_api cuda vdpau nvenc"
			;;
		*)
			printf 'Other: %s\n' "$lspci_line"
			;;
		esac
	done
	printf '# video cards\nUSE="$USE %s"\n\n' "$video_api" >>$_CONF_GENTOO_INSTALL_PATH/etc/portage/make.conf
	IFS="$oIFS"
}
_write_cpu_flags() {
	mkdir -p $_CONF_GENTOO_INSTALL_PATH/etc/portage/package.use
	printf '*/* %s\n' "$(cpuid2cpuflags)" >$_CONF_GENTOO_INSTALL_PATH/etc/portage/package.use/00cpu-flags
}
_write_video_cards() {
	printf '*/* VIDEO_CARDS: -* %s\n' "$GENTOO_VIDEO_CARDS" >$_CONF_GENTOO_INSTALL_PATH/etc/portage/package.use/00video
}
_load_modules() {
	lsmod | grep -qm1 ^iptable_filter || modprobe iptable_filter
	lsmod | grep -qm1 ^ip6table_filter || modprobe ip6table_filter
	lsmod | grep -qm1 ^br_netfilter || modprobe br_netfilter
}
_mounts() {
	mkdir -p $_CONF_GENTOO_INSTALL_PATH/dev $_CONF_GENTOO_INSTALL_PATH/run $_CONF_GENTOO_INSTALL_PATH/sys $_CONF_GENTOO_INSTALL_PATH/proc $_CONF_GENTOO_INSTALL_PATH/efi $_CONF_GENTOO_INSTALL_PATH/boot/efi
	_mount_rbind dev
	_mount_rbind run
	_mount_rbind sys
	mount --types proc /proc $_CONF_GENTOO_INSTALL_PATH/proc
	_setup_disks_efi
	mkdir -p $_CONF_GENTOO_INSTALL_PATH/efi $_CONF_GENTOO_INSTALL_PATH/boot/efi
	mount ${GENTOO_DISK_DEVICE_EFI_PARTITION} $_CONF_GENTOO_INSTALL_PATH/efi
	mount ${GENTOO_DISK_DEVICE_EFI_PARTITION} $_CONF_GENTOO_INSTALL_PATH/boot/efi
	[ "$(basename $0)" = "gentoo-install" ] && _defer _umount
	return 0
}
_mount_rbind() {
	mount --rbind /$1 $_CONF_GENTOO_INSTALL_PATH/$1
	mount --make-rslave $_CONF_GENTOO_INSTALL_PATH/$1
}
_umount() {
	umount -fl $_CONF_GENTOO_INSTALL_PATH/dev $_CONF_GENTOO_INSTALL_PATH/sys $_CONF_GENTOO_INSTALL_PATH/run $_CONF_GENTOO_INSTALL_PATH/proc $_CONF_GENTOO_INSTALL_PATH/efi $_CONF_GENTOO_INSTALL_PATH/boot/efi
}
_networking() {
	dhcpcd $_INTERFACE
}
_backup_portage() {
	_backup_dir /var/db/repos/gentoo
	_backup_dir /var/cache/distfiles
}
_backup_dir() {
	[ -e $1 ] && {
		warn "$1 already backed up"
		return
	}
	mkdir -p $1
	tar cp -C $_CONF_GENTOO_INSTALL_PATH/$1 . | tar xp -C $1
}
_restore_portage() {
	_restore_dir /var/db/repos/gentoo
	_restore_dir /var/cache/distfiles
}
_restore_dir() {
	[ ! -e $1 ] && {
		warn "$1 does not exist, unable to restore"
		return
	}
	mkdir -p $_CONF_GENTOO_INSTALL_PATH/$1
	tar cp -C $1 . | tar xp -C $_CONF_GENTOO_INSTALL_PATH/$1
}
_pre_chroot() {
	warn "Executing pre_chroot"
	find . -type f -path '*/system/pre_chroot' -type f -exec {} \;
}
_stage3() {
	_stage3_fetch || {
		[ -n "$stage3_retry" ] && error "Stage3 failed: already retried"
		warn "File failed verification, discarding: $_DOWNLOADED_FILE"
		rm -f $STAGE3_VERSION_FILE $STAGE3_FILE $STAGE3_SIGNATURE_FILE
		stage3_retry=1 _stage3
	}
	_stage3_extract $STAGE3_FILE
}
_stage3_fetch() {
	LATEST_STAGE3_NAME=$(_stage3_latest_version)
	_require "$LATEST_STAGE3_NAME" LATEST_STAGE3_NAME
	_download https://distfiles.gentoo.org/releases/$GENTOO_CPU_ARCHITECTURE/autobuilds/current-stage3-$GENTOO_CPU_ARCHITECTURE-$GENTOO_STAGE3_TYPE/stage3-$GENTOO_CPU_ARCHITECTURE-$GENTOO_STAGE3_TYPE-$LATEST_STAGE3_NAME.tar.xz
	STAGE3_FILE=$_DOWNLOADED_FILE
	_download https://distfiles.gentoo.org/releases/$GENTOO_CPU_ARCHITECTURE/autobuilds/current-stage3-$GENTOO_CPU_ARCHITECTURE-$GENTOO_STAGE3_TYPE/stage3-$GENTOO_CPU_ARCHITECTURE-$GENTOO_STAGE3_TYPE-$LATEST_STAGE3_NAME.tar.xz.asc
	STAGE3_SIGNATURE_FILE=$_DOWNLOADED_FILE
	_gpg_verify $STAGE3_SIGNATURE_FILE
}
_stage3_latest_version() {
	_download https://distfiles.gentoo.org/releases/$GENTOO_CPU_ARCHITECTURE/autobuilds/current-stage3-$GENTOO_CPU_ARCHITECTURE-$GENTOO_STAGE3_TYPE/latest-stage3-$GENTOO_CPU_ARCHITECTURE-$GENTOO_STAGE3_TYPE.txt
	STAGE3_VERSION_FILE=$_DOWNLOADED_FILE
	_gpg_verify $STAGE3_VERSION_FILE
	grep "$GENTOO_STAGE3_TYPE" $STAGE3_VERSION_FILE | sed -e 's/\.tar\.xz.*$//' -e 's/^.*\-//'
}
_stage3_extract() {
	tar ${_CONF_GENTOO_VERBOSE_TAR}xpf $1 --xattrs-include='*.*' --numeric-owner -C $_CONF_GENTOO_INSTALL_PATH
}
_validate() {
	_require "$GENTOO_SYSTEM_NAME" "GENTOO_SYSTEM_NAME"
	_require "$GENTOO_DISK_DEVICE" "GENTOO_DISK_DEVICE"
	_require "$GENTOO_LUKS_PASSPHRASE" "GENTOO_LUKS_PASSPHRASE"
	_require "$GENTOO_INIT" "GENTOO_INIT"
	_value_in "$GENTOO_INIT" "bliss|dracut|ugrd|walterjwhite"
	_require "$GENTOO_BOOT_LOADER" "GENTOO_BOOT_LOADER"
	_value_in "$GENTOO_BOOT_LOADER" "efibootmgr|grub"
	_require "$GENTOO_CRON" "GENTOO_CRON [cronie|dcron|fcron|bcron|anacron]"
	_value_in "$GENTOO_CRON" "cronie|dcron|fcron|bcron|anacron"
	_require "$GENTOO_SYSLOG" "GENTOO_SYSLOG [sysklogd|syslog-ng|rsyslog|metalog]"
	_value_in "$GENTOO_SYSLOG" "sysklogd|syslog-ng|rsyslog|metalog"
	_require "$GENTOO_KERNEL" "GENTOO_KERNEL [gentoo-kernel]"
	_value_in "$GENTOO_KERNEL" "gentoo-kernel"
}
_write_system() {
	local gentoo_system_id_file=$_CONF_GENTOO_INSTALL_PATH/$_CONF_GENTOO_INSTALLER_SYSTEM_IDENTIFICATION
	mkdir -p $(dirname $gentoo_system_id_file)
	printf '%s\n' $GENTOO_SYSTEM_NAME >$gentoo_system_id_file
	printf '%s\n' $GENTOO_SYSTEM_BRANCH >>$gentoo_system_id_file
	printf '%s\n' $_CONF_GENTOO_INSTALLER_GIT_URL >>$gentoo_system_id_file
	git ls-remote $_CONF_GENTOO_INSTALLER_GIT_URL -b $GENTOO_SYSTEM_NAME | awk {'print$1'} >>$gentoo_system_id_file
	printf 'Provision Date: %s\n' "$(date)" >>$gentoo_system_id_file
}
_require_file() {
	_require "$1" filename _require_file
	local level=error
	[ -n "$_WARN" ] && level=warn
	if [ ! -e $1 ]; then
		$level "File: $1 does not exist | $2"
		return 1
	fi
}
_download() {
	mkdir -p $_CONF_CACHE_PATH
	local _cached_filename
	if [ $# -gt 1 ]; then
		_cached_filename="$2"
	else
		_cached_filename=$(basename $1 | sed -e 's/?.*$//')
	fi
	_DOWNLOADED_FILE=$_CONF_CACHE_PATH/$_cached_filename
	if [ -e $_DOWNLOADED_FILE ]; then
		detail "$1 already downloaded to: $_DOWNLOADED_FILE"
		return
	fi
	if [ -z "$_DOWNLOAD_DISABLED" ]; then
		info "Downloading $1 -> $_DOWNLOADED_FILE"
		curl $_CURL_OPTIONS -o $_DOWNLOADED_FILE -s -L "$1"
	else
		_continue_if "Please manually download: $1 and place it in $_DOWNLOADED_FILE" "Y/n"
	fi
}
_download_install_file() {
	_require "$1" "1 (_download_install_file) target filename"
	info "Installing $_DOWNLOADED_FILE -> $1"
	_sudo mkdir -p $(dirname $1)
	_sudo cp $_DOWNLOADED_FILE $1
	_sudo chmod 444 $1
	unset _DOWNLOADED_FILE
	[ ! -e $1 ] && return 1
	return 0
}
_include beep context gentoo-installer logging net paths platform wait
: ${_CONF_LOG_HEADER:="##################################################"}
: ${_CONF_LOG_C_ALRT:="1;31m"}
: ${_CONF_LOG_C_ERR:="1;31m"}
: ${_CONF_LOG_C_SCS:="1;32m"}
: ${_CONF_LOG_C_WRN:="1;33m"}
: ${_CONF_LOG_C_INFO:="1;36m"}
: ${_CONF_LOG_C_DETAIL:="1;0;36m"}
: ${_CONF_LOG_C_DEBUG:="1;35m"}
: ${_CONF_LOG_C_STDIN:="1;34m"}
: ${_CONF_LOG_DATE_FORMAT:="%Y/%m/%d|%H:%M:%S"}
: ${_CONF_LOG_DATE_TIME_FORMAT:="%Y/%m/%d %H:%M:%S"}
: ${_CONF_LOG_AUDIT:=0}
: ${_CONF_LOG_LEVEL:=2}
: ${_CONF_LOG_INDENT:="  "}
: ${_CONF_LOG_CONF_VALIDATION_FUNCTION:=warn}
: ${_CONF_LOG_WAITER_LEVEL:=debug}
: ${_CONF_LOG_FEATURE_TIMEOUT_ERROR_LEVEL:=warn}
: ${_CONF_LOG_LONG_RUNNING_CMD:=30}
: ${_CONF_LOG_LONG_RUNNING_CMD_LINES:=1000}
[ -t 0 ] && INTERACTIVE=1
: ${LIB:="beep.sh context.sh environment.sh exec.sh exit.sh help.sh include.sh logging.sh mktemp.sh platform.sh processes.sh stdin.sh syslog.sh sudo.sh wait.sh validation.sh net/mail.sh alert.sh"}
: ${CFG:="logging platform context wait beep paths net"}
: ${SUPPORTED_PLATFORMS:="Apple FreeBSD Linux Windows"}
: ${BUILD_PLATFORMS:="FreeBSD Linux Apple Windows"}
which pgrep >/dev/null 2>&1 && _PARENT_PROCESSES_FUNCTION=_parent_processes_pgrep
_DETECTED_PLATFORM=$(uname)
case $_DETECTED_PLATFORM in
Darwin)
	_DETECTED_PLATFORM=Apple
	;;
MINGW64_NT-*)
	_DETECTED_PLATFORM=Windows
	;;
esac
: ${_CONF_INSTALL_CONTEXT:=$_CONSOLE_CONTEXT_ID}
: ${_CONF_INSTALL_CONTEXT:=default}
: ${_CONF_WAIT_INTERVAL:=30}
: ${RSRC_BEEP:=/tmp/beep}
: ${_CONF_LOG_BEEP_TIMEOUT:=5}
: ${_CONF_LOG_BEEP_ERR:='L32c'}
: ${_CONF_LOG_BEEP_ALRT:='L32f'}
: ${_CONF_LOG_BEEP_SCS:='L32a'}
: ${_CONF_LOG_BEEP_WRN:=''}
: ${_CONF_LOG_BEEP_INFO:=''}
: ${_CONF_LOG_BEEP_DETAIL:=''}
: ${_CONF_LOG_BEEP_DEBUG:=''}
: ${_CONF_LOG_BEEP_STDIN:='L32ab'}
[ "$HOME" = "/" ] && HOME=/root
: ${_CONF_LIBRARY_PATH:=/usr/local/walterjwhite}
: ${_CONF_BIN_PATH:=/usr/local/bin}
_CONF_DATA_PATH=$HOME/.data
_CONF_CACHE_PATH=$_CONF_DATA_PATH/.cache
_CONF_CONFIG_PATH=$HOME/.config/walterjwhite
_CONF_RUN_PATH=/tmp/$USER/walterjwhite/app
_CONF_DATA_ARTIFACTS_PATH=$_CONF_DATA_PATH/install-v2/artifacts
_CONF_DATA_REGISTRY_PATH=$_CONF_DATA_PATH/install-v2/registry
_CONF_APPLICATION_DATA_PATH=$_CONF_DATA_PATH/$_APPLICATION_NAME
_CONF_APPLICATION_CONFIG_PATH=$_CONF_CONFIG_PATH/$_APPLICATION_NAME
_CONF_APPLICATION_LIBRARY_PATH=$_CONF_LIBRARY_PATH/$_APPLICATION_NAME
: ${_CONF_NETWORK_TEST_TIMEOUT:=5}
: ${_CONF_NETWORK_TEST_TARGETS:="http://connectivity-check.ubuntu.com http://example.org http://www.google.com http://telehack.com http://lxer.com"}
_REQUIRED_APP_CONF="_CONF_GENTOO_INSTALLER_GIT_LUKS_URL _CONF_GENTOO_INSTALLER_GIT_URL _CONF_GENTOO_INSTALLER_SYSTEM_IDENTIFICATION _CONF_GENTOO_INSTALL_PATH _CONF_GNU_GREP _CONF_LOG_SUDO_BEEP_TONE"
_sub_platform
case $_SUB_PLATFORM in
Alpine)
	_INSTALL_INSTALLER=apk
	_CONF_INSTALL_STAT_ARGUMENTS='-c %a'
	_CONF_GNU_GREP=ugrep
	_CONF_GNU_SED=sed
	_is_backgrounded() {
		:
	}
	REMOVE_UNUSED_FUNCTIONS=''
	;;
Debian | Ubuntu)
	_INSTALL_INSTALLER=apt
	_CONF_GNU_GREP=grep
	_CONF_GNU_SED=sed
	;;
Gentoo)
	_CONF_GNU_GREP=grep
	_CONF_GNU_SED=sed
	_PLATFORM_PACKAGES="app-eselect/eselect-repository app-portage/mirrorselect app-portage/cpuid2cpuflags sys-apps/pciutils sys-fs/dosfstools dev-vcs/git dev-tcltk/expect net-misc/curl dev-util/sh app-admin/sudo sys-apps/usbutils"
	_PLATFORM_PACKAGES_ACCEPT_KEYWORDS="dev-util/sh ~amd64"
	_NPM_PACKAGE="net-libs/nodejs"
	_RUST_PACKAGE="dev-lang/rust"
	_PYPI_PACKAGE="dev-lang/python"
	_GO_PACKAGE="dev-lang/go"
	_INSTALL_INSTALLER=emerge
	_CONF_INSTALL_STAT_ARGUMENTS='-c %a'
	ASSUME_ALWAYS_YES=yes
	: ${_EMERGE_OPTIONS:="-q --quiet-build --quiet-fail"}
	[ -n "$_ROOT" ] && [ "$_ROOT" != "/" ] && _EMERGE_OPTIONS="$_EMERGE_OPTIONS --root=$_ROOT"
	;;
CentOS | RedHat)
	_CONF_GNU_GREP=grep
	_CONF_GNU_SED=sed
	_INSTALL_INSTALLER=yum
	;;
*)
	error "Unknown Linux Distribution: $_SUB_PLATFORM"
	;;
esac
_is_backgrounded && _BACKGROUNDED=1
_init_logging
unset _DEFERS _EXIT
_APPLICATION_START_TIME=$(date +%s)
_APPLICATION_CMD=$(basename $0)
trap _on_exit INT 0 1 2 3 4 6 15
for _ARG in "$@"; do
	case $_ARG in
	-conf-* | -[a-z0-9][a-z0-9][a-z0-9]*)
		_configuration_name=${_ARG#*-}
		_configuration_name=${_configuration_name%%=*}
		if [ $(printf '%s' "$_configuration_name" | grep -c '_') -eq 0 ]; then
			if [ $(printf '%s' "$_configuration_name" | grep -c '^conf') -gt 0 ]; then
				_configuration_name=$(printf '%s' "$_configuration_name" | sed -e "s/-/-$_APPLICATION_NAME-/")
			else
				_configuration_name=$(printf '%s' "$_configuration_name" | sed -e "s/^/$_APPLICATION_NAME-/")
			fi
		fi
		_configuration_name=$(printf '%s' $_configuration_name | tr '-' '_' | tr '[:lower:]' '[:upper:]')
		if [ $(printf '%s' "$_ARG" | grep -c '=') -eq 0 ]; then
			_configuration_value=1
		else
			_configuration_value=${_ARG#*=}
		fi
		export _$_configuration_name="$_configuration_value"
		unset _configuration_name
		shift
		;;
	-h | --help)
		_print_help_and_exit
		;;
	-w=*)
		_WAITER_PID="${1#*=}"
		shift
		;;
	-w)
		_WAITEE=1
		shift
		;;
	*)
		break
		;;
	esac
done
for _REQUIRED_APP_CONF_ITEM in $_REQUIRED_APP_CONF; do
	_variable_is_set $_REQUIRED_APP_CONF_ITEM || {
		warn "$_REQUIRED_APP_CONF_ITEM is unset"
		_MISSING_REQUIRED_CONF=1
	}
done
[ -n "$_MISSING_REQUIRED_CONF" ] && error "Required configuration is missing, please refer to above error(s)"
if [ -z "$_CONTEXT_VALIDATED" ]; then
	_context_id_is_valid "$_CONF_INSTALL_CONTEXT"
	_CONTEXT_VALIDATED=0
fi
_APPLICATION_CONTEXT_GROUP=$_CONF_RUN_PATH/$_CONF_INSTALL_CONTEXT
_APPLICATION_CMD_DIR=$_APPLICATION_CONTEXT_GROUP/$_APPLICATION_NAME/$_APPLICATION_CMD
_waitee_init
_waiter
_is_root || error "This app must be run as root"
_set_logfile /var/log/gentoo-install.log
_gentoo_cleanup_install
_ _load_modules
_ _import_gentoo_gpg_keys
_ _networking
_ _setup_git
_ _configure
_ _setup_system_architecture
_ _validate
_ _setup_disks
_ _stage3
_ _write_system
_ _portage_write_package_license
_ _portage_system_use_flags
_ _hardware
_ _mounts
_ _restore_portage
_ _pre_chroot
_ _prepare_chroot
GENTOO_INSTALLER_CHROOT=1 _ chroot $_CONF_GENTOO_INSTALL_PATH _gentoo-install-chroot
_ _backup_portage
